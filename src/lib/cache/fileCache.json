{
  "advanced-guides/visualize": {
    "name": "visualize",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nResponse Visualization\n\n\nThe `bru.visualize` function in the Bruno CLI allows for rendering various types of visualizations such as tables and HTML. It supports different providers for each visualization type, offering flexibility in how data is displayed. Below are examples and details on the supported types and providers.\n\n```javascript\nbru.visualize(type, config)\n```\n\n1. **type**: The type of visualization to render (e.g., 'table', 'html').\n\n2. **config**: A configuration object that includes:\n\n    - **name**: The name of the visualization instance.\n\n    - **provider**: The rendering library or provider used to display the visualization (e.g., 'ag-grid', 'react-table').\n\n    - **props**: Additional properties required by the provider to configure the visualization.\n\nSupported Visualization Types and Providers\n\n\nTable Visualization ('table')\n\n\nYou can render tables using different providers like `ag-grid` and `react-table`.\n\nUsing **ag-grid**\n\n\n*Example:*\n\n![ag-grid](/screenshots/visualization/ag-grid.png)\n\n```javascript\nconst rowData = [\n  { name: 'John Doe', age: 28, email: 'john@example.com', city: 'New York' },\n  { name: 'Jane Smith', age: 32, email: 'jane@example.com', city: 'London' }\n];\n\nconst columnDefinitions = [\n  { field: \"name\", filter: true, floatingFilter: true },\n  { field: \"age\", filter: true, floatingFilter: true },\n  { field: \"email\", filter: true, floatingFilter: true },\n  { field: \"city\", filter: true, floatingFilter: true }\n];\n\nbru.visualize('table', {\n  name: 'table1',\n  provider: 'ag-grid',\n  props: { rowData, columnDefinitions }\n});\n```\n\nThis will render a table using the ag-grid provider with filters enabled on all columns.\n\nUsing **react-table**\n\n\n*Example:*\n\n![react-table](/screenshots/visualization/react-table.png)\n\n```javascript\nconst rowData1 = Array.from({ length: 2500 })\n  .map((_) => [\n    { firstName: 'Tanner', lastName: 'Linsley', age: 24, visits: 100 },\n    { firstName: 'Tandy', lastName: 'Miller', age: 40, visits: 40 },\n    { firstName: 'Joe', lastName: 'Dirte', age: 45, visits: 20 },\n  ]).flat();\n\n\nconst columnDefinitions1 = [\n  {\n    id: \"firstName\",\n    cell: (info) => info.getValue(),\n    header: () => `First Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  {\n    id: \"lastName\",\n    cell: (info) => info.getValue(),\n    header: () => `Last Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  // Additional column definitions here...\n];\n\nbru.visualize('table', {\n  name: 'table2',\n  provider: 'react-table',\n  props: { rowData: rowData1, columnDefinitions: columnDefinitions1 }\n});\n```\n\nThis example renders a large table using the react-table provider, with custom headers and filter variants.\n\nHTML Visualization ('html')\n\n\nYou can also render custom HTML content using the html type. This allows for advanced templating and formatting, such as generating a data table or a report.\n\nUsing **HTML** String\n\n\n*Example:*\n\n![html](/screenshots/visualization/html.png)\n\n```javascript\nconst htmlString = `\n\n  \n    \n      table { width: 100%; border-collapse: collapse; }\n      th, td { border: 1px solid black; padding: 8px; }\n      th { background-color: #f2f2f2; }\n    \n  \n  \n    \n      NameAgeEmailCity\n      John Doe28john@example.comNew York\n      Jane Smith32jane@example.comLondon\n    \n  \n\n`;\n\nbru.visualize('html', {\n  name: 'htmlReport',\n  content: htmlString\n});\n```\n\nThis example will render an HTML table with predefined data using the html type.\n\nParameters\n\n\n| Name     | Type     | Description                                                                                     |\n|----------|----------|-------------------------------------------------------------------------------------------------|\n| `type`   | `string` | The type of visualization to render. Supported values: `'table'`, `'html'`.                     |\n| `config` | `object` | Configuration object for the visualization. See below for available properties.                 |\n\nConfig Properties\n\n\n| Property   | Type     | Description                                                                                     |\n|------------|----------|-------------------------------------------------------------------------------------------------|\n| `name`     | `string` | Name of the visualization instance.                                                             |\n| `provider` | `string` | The provider or rendering engine to use for the visualization. E.g., `'ag-grid'`, `'react-table'`. |\n| `props`    | `object` | Additional properties required by the provider to configure the visualization.                  |\n| `content`  | `string` | (For `html` type only) The HTML content to render.                                             |\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/visualize"
  },
  "advanced-guides/working-with-bigint": {
    "name": "working-with-bigint",
    "content": "Working with BigInt\n\n\nWhen your response data contains `BigInt`, the parsed value may become corrupted because Bruno parses the response data by default, which can lead to a loss of fidelity.\nThis occurs because `JSON.parse()` does not handle `BigInt` values correctly by default.\n\nHowever, if you need access to the raw response data (for example, if it contains `BigInt`), you can bypass the parsing step.\n\nTo prevent automatic parsing and work directly with the raw response data, add the below expression to the `pre-request` script.\n\n```js\nreq.disableParsingResponseJson();\n```\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/working-with-bigint"
  },
  "auth/add-and-manage-certs": {
    "name": "add-and-manage-certs",
    "content": "Adding and managing certifications \n\n\nBruno supports adding custom Client Authorization (CA) and client certificates to your requests if required by the API you are working with. \n\nAdding a custom CA certificate\n\n\nNavigate to the `Preferences` menu in Bruno and select `Use custom CA Certificate`, then upload the selected file. \n\n![Custom CA Certificate](/screenshots/auth/customcacert.webp)\n\nAdding client certificates to Collections\n\n\nYou can add and manage client certificate(s) on any Collection by going to the `Collection Settings` menu and selecting `Client Certificates`. \n\nSimply enter the domain, designate the type of certificate, and then upload the relevant file(s). \n\n![Client Certificate](/screenshots/auth/clientcerts.webp)",
    "parentName": "auth",
    "path": "auth/add-and-manage-certs"
  },
  "auth/aws-signature": {
    "name": "aws-signature",
    "content": "Authenticate using AWS Signature \n\n\nAWS Signature is the authorization workflow for Amazon Web Services requests. AWS uses a custom HTTP scheme based on a keyed-HMAC (Hash Message Authentication Code) for authentication.\n\nThe official AWS Signature documentation provides more detail:\n\n- [Signing and Authenticating Requests](\n\n- [How to call an API]( \n\nTo use AWS Signature, do the following:\n\n1. In the `Auth` tab for a request, select `AWS Sig V4` from  dropdown list.\n\n2. Enter your *AccessKeyID* and *SecretKey* values. \n\n> For extra security, integrate Bruno with your secret manager to store these values in a single location. Learn more (here) [../secrets-management/hashicorp-vault/overview].\n\nThe AWS Signature parameters are as follows:\n\n- Session Token - Required only when using temporary security credentials.\n- Service Name - The service receiving the request.\n- AWS Region - The region receiving the request.\n- Profile Name - name of your AWS signing profile\n\n",
    "parentName": "auth",
    "path": "auth/aws-signature"
  },
  "auth/basic": {
    "name": "basic",
    "content": "Using Basic authentication\n\n\nBasic authentication involves sending a verified username and password with your request. In the request `Auth` tab, select `Basic Auth` from the Auth Type dropdown list.\n\nEnter your API username and password in the Username and Password fields. For extra security, store these in variables.\n\n![Basic](/screenshots/auth/basic.webp)\n\nIn the request Headers, the Authorization header passes the API a Base64 encoded string representing your username and password values, appended to the text `Basic`.",
    "parentName": "auth",
    "path": "auth/basic"
  },
  "auth/bearer": {
    "name": "bearer",
    "content": "Authenticate with a Bearer token\n\n\nBearer tokens enable requests to authenticate using an access key, such as a JSON Web Token (JWT). The token is a text string, included in the request header. \nIn the request `Auth` tab, select `Bearer Token` from the Auth Type dropdown list. In the Token field, enter your API key value. For added security, store it in a variable and reference the variable by name.\n\n![Bearer](/screenshots/auth/bearer.webp)\n\nBruno appends the token value to the text `Bearer` in the required format to the request Authorization header. ",
    "parentName": "auth",
    "path": "auth/bearer"
  },
  "auth/digest": {
    "name": "digest",
    "content": "Authenticate with Digest Access\n\n\nWith Digest auth, the client sends a first request to the API, and the server responds back with details.\nResponse details include a number that can be used only once (a nonce), a realm value, and a 401 Unauthorized response. \nYou then send back an encrypted array of data, including a username and password combined with the data received from the server in the first request. \nThe server uses the passed data to generate an encrypted string and compares it against what you sent to authenticate your request.\n\nIn the Authorization tab for a request, select Digest Auth from the Auth Type dropdown list. \n\n![Digest](/screenshots/auth/digest.webp)\n\n",
    "parentName": "auth",
    "path": "auth/digest"
  },
  "auth/oauth2/authorization-code": {
    "name": "authorization-code",
    "content": "How to Use OAuth2 for the Authorization Code Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_post_response_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_post_response_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_post_response_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/authorization-code"
  },
  "auth/oauth2/client-credentials": {
    "name": "client-credentials",
    "content": "How to Use OAuth2 for the Client Credentials Grant Type\n\n\nOAuth 2.0 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `OAuth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/client-credentials"
  },
  "auth/oauth2/overview": {
    "name": "overview",
    "content": "Oauth 2.0 authentication in Bruno\n\n\nBruno currently supports OAuth2 authentication for the following three grant types:\n\n- [Authorization Code](/auth/oauth2/authorization-code)\n- [Client Credentials](/auth/oauth2/client-credentials)\n- [Password Credentials](/auth/oauth2/password-credentials)\n",
    "parentName": "auth",
    "path": "auth/oauth2/overview"
  },
  "auth/oauth2/password-credentials": {
    "name": "password-credentials",
    "content": "How to Use OAuth2 for the Password Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/password-credentials"
  },
  "auth/overview": {
    "name": "overview",
    "content": "Authentication in Bruno\n\n\nBruno allows you to send authentication details with your API requests.\nAuthentication methods can be set on the request level or collection level, if you want all of your requests to use the same method.\n\n> Some APIs will require a digital certificate to establish a client's identity. You can add your certificate authority (CA) or client certificates to Bruno. \n> See [Add and Manage Certificates](auth/add-and-manage-certs) for more information. \n\nYou can pass auth details along with any request in Bruno in the header, body, or as a parameter. \nIf you enter your auth details to the `Auth` tab of your requests, we will automatically populate the relevant parts of the request for your chosen auth method. \n\nBruno currently supports the following authentication protocols: \n\n- [OAuth 2.0](/auth/oauth2/overview)\n- [AWS Sig v4](/auth/aws-signature)\n- [Basic Auth](/auth/basic)\n- [Bearer Auth](/auth/bearer)\n- [Digest Auth](/auth/digest)",
    "parentName": "auth",
    "path": "auth/overview"
  },
  "bru-cli/overview": {
    "name": "overview",
    "content": "Bruno CLI\n\n\nWith Bruno CLI, you can run your API collections with ease using simple command line commands.\n\nThis makes it easier to test your APIs in different environments, automate your testing process, and integrate your API tests with your continuous integration and deployment workflows.\n\nInstallation\n\nTo install the Bruno CLI, use the node package manager of your choice, such as NPM:\n```bash copy\nnpm install -g @usebruno/cli\n```\n\nGetting Started\n\n\nNavigate to the directory where your API collection resides, and run the following command:\n\n```bash copy\nbru run\n```\n\nThis will run all the requests in your collection. If you want to run a single request, specify its filename:\n\n```bash copy\nbru run request.bru\n```\n\nRunning Requests in a Folder\n\nTo run all the requests within a folder, use:\n\n```bash copy\nbru run folder\n```\n\nUsing Environments\n\nIf you need to use a specific environment, you can pass it with the --env option:\n\n\n```bash copy\nbru run folder --env Local\n```\n\nPassing Environment Variables\n\nYou can pass environment variables directly to your collection with the --env-var option:\n\n\n```bash copy\nbru run folder --env Local --env-var JWT_TOKEN=1234\n```\n\nRunning a Collection with a CSV File\n\nIf you need to run a collection using data from a CSV file, specify the path to the file with the --csv-file-path option:\n\n```bash copy\nbru run folder --csv-file-path /path/to/csv/file.csv\n```\n\nOutputting Results\n\nTo save the results of your API tests to a file, use the --output option:\n\n\n```bash copy\nbru run folder --output results.json\n```\n\nGenerating Reports\n\n\nBruno CLI provides built-in support for generating reports in three formats: **JSON**, **JUnit**, and **HTML**. These reports help with analyzing test results and integrating with various CI/CD tools.\n\nYou can generate any combination of these reports and even run them simultaneously.\n\nJSON Report\n\n\nTo generate a report in JSON format, use the `--reporter-json` option:\n\n```bash copy\nbru run request.bru --reporter-json results.json\n```\n\nThis will output the test results in a results.json file, which can be useful for further processing or programmatic analysis.\n\nJUnit Report\n\n\nTo generate a report in JUnit format, use the --reporter-junit option:\n\n```bash copy\nbru run request.bru --reporter-junit results.xml\n```\n\nThe results.xml file will be in a format compatible with JUnit, making it ideal for integration with CI/CD pipelines that rely on JUnit reporting.\n\n\nHTML Report\n\n\nTo generate a human-readable HTML report, use the --reporter-html option:\n\n```bash copy\nbru run request.bru --reporter-html results.html\n```\n\nThis will create an results.html file that provides a visual representation of the test outcomes, ideal for quick reviews.\n\nRunning Multiple Reporters Simultaneously\n\n\nYou can generate multiple reports at once by specifying more than one reporter option. For example, to generate JSON, JUnit, and HTML reports simultaneously, run:\n\n```bash copy\nbru run request.bru --reporter-json results.json --reporter-junit results.xml --reporter-html results.html\n```\n\nThis command will create three files: results.json, results.xml, and results.html, allowing you to analyze the results in different formats as needed.\n\n\nOptions\n\n| Option                    | Details                                                                       |\n|---------------------------|-------------------------------------------------------------------------------|\n| -h, --help                | Show help                                                                     |\n| --version                 | Show version number                                                           |\n| -r                        | Indicates a recursive run (default: false)                                    |\n| --cacert [string]         | CA certificate to verify peer against                                         |\n| --env [string]            | Specify environment to run with                                               |\n| --env-var [string]        | Overwrite a single environment variable, multiple usages possible             |\n| -o, --output [string]     | Path to write file results to                                                 |\n| -f, --format [string]     | Format of the file results; available formats are \"json\" (default) or \"junit\" |\n| --reporter-json [string]  | Path to generate a JSON report                                                |\n| --reporter-junit [string] | Path to generate a JUnit report                                               |\n| --reporter-html [string]  | Path to generate an HTML report                                               |\n| --insecure                | Allow insecure server connections                                             |\n| --tests-only              | Only run requests that have tests                                             |\n| --bail                    | Stop execution after a failure of a request, test, or assertion               |\n| --csv-file-path           | CSV file to run the collection with                                           |\n\nDemo\n\n![bru cli](/screenshots/cli-demo.webp)\n\nSupport\n\nIf you encounter any issues or have any feedback or suggestions, please raise them on our [GitHub repository](\n",
    "parentName": "bru-cli",
    "path": "bru-cli/overview"
  },
  "bru-lang/language": {
    "name": "language",
    "content": "Language Design\n\n\nA Bru file is made up of blocks.\nThere are three kinds of blocks\n- Dictionary block\n- Text block\n- Array block\n\nDictionary block\n\nA dictionary block contains a set of key value pairs. \n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer 123\n  ~transaction-id: {{transactionId}}\n}\n```\nAny key in the dictionary block can be prefixed with `~` to indicate that it is disabled.\n\nText block\n\nA text block is a set of lines\n```bash\nbody {\n  {\n    \"hello\": \"world\"\n  }\n}\n\ntests {\n  expect(res.status).to.equal(200);\n}\n```\n\nArray block\n\nAn array block is a list of strings\n```bash\nvars:secret [\n  access_key,\n  access_secret,\n  ~transactionId\n]\n```\nAny key in the array block can be prefixed with `~` to indicate that it is disabled.\n\n\n\n\n\n",
    "parentName": "bru-lang",
    "path": "bru-lang/language"
  },
  "bru-lang/overview": {
    "name": "overview",
    "content": "Bru Markup Language\n\n\nBru is a simple markup language that utilizes plain text files to document and organize information for your API requests.\n\nThe API requests in your collections are stored as plain text files using this language.\n\nThis allows you to save your API collections in a folder within your code repository, and use your preferred version control system to manage and share them with your team. Collaboration on your API collections can be done through pull requests, as the human-readable file format makes it easy for developers to understand the changes made to the API collection.\n\nBelow is a sample of a Bru file for a `GET` request with some query params\n\n![bru lang sample](/screenshots/github-collection.webp)\n\nYou can checkout the sample repository which contains GitHub rest API collection [here](\n\nIf you are wondering why we designed a DSL instead of just using JSON/YAML, you can checkout this [github discussion](\n",
    "parentName": "bru-lang",
    "path": "bru-lang/overview"
  },
  "bru-lang/samples": {
    "name": "samples",
    "content": "Samples\n\n\nHere are a few sample Bru files.\n\nGET\n\n```bash\nget {\n  url: \n}\n```\n\nGET with headers\n\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nPOST with body\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"apiKey\": \"secret\",\n    \"numbers\": \"9988776655\",\n    \"message\": \"Woof! lets play with some apis\"\n  }\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nScripting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\n\nTesting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\ntests {\n  test(\"should be able to login\", function() {\n    expect(res.status).to.equal(201);\n  });\n\n  test(\"should receive the token\", function() {\n    expect(res.body.token).to.be.a('string');\n  });\n}\n```",
    "parentName": "bru-lang",
    "path": "bru-lang/samples"
  },
  "bru-lang/syntax-highlighting": {
    "name": "syntax-highlighting",
    "content": "Syntax Highlighting Support\n\n\nBruno has editor extension released for VS Code.  You can download it from the [Visual Studio Marketplace](\n\nExtensions for IntelliJ and the JetBrains family of IDEs are under development.\n",
    "parentName": "bru-lang",
    "path": "bru-lang/syntax-highlighting"
  },
  "bru-lang/tag-reference": {
    "name": "tag-reference",
    "content": "Bru Tag Reference\n\n\nmeta\n\nStore metadata about your request\n```bash\nmeta {\n  name: Get users,\n  type: http\n  seq: 1\n}\n```\n\nThe `seq` is used to store the sequence number. This decides the sort position of your request in the UI.\nThe `type` can be either `http` or `graphql`\n\nget\n\n\nMake a `GET` http call\n```bash\nget {\n  url: \n}\n```\npost\n\n\nMake a `POST` http call\n```bash\npost {\n  url: \n}\n```\nput\n\n\nMake a `PUT` http call\n```bash\nput {\n  url: \n}\n```\ndelete\n\n\nMake a `DELETE` http call\n```bash\ndelete {\n  url: \n}\n```\noptions\n\n\nMake a get `OPTIONS` call\n```bash\noptions {\n  url: \n}\n```\ntrace\n\n\nMake a `TRACE` http call\n```bash\ntrace {\n  url: \n}\n```\nconnect\n\n\nMake a `CONNECT` http call\n```bash\nconnect {\n  url: \n}\n```\nhead\n\n\nMake a `HEAD` http call\n```bash\nhead {\n  url: \n}\n```\nquery\n\n\nThe request query params\n```bash\nget {\n  url: \n}\n\nquery {\n  apiKey: secret\n  numbers: 9988776655\n  message: hello\n}\n```\nheaders\n\n\nThe request query headers\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nbody\n\nThe request body (defaults to json)\n```bash\nbody {\n  {\n    username: 'john',\n    password: 'governingdynamics'\n  }\n}\n```\nbody:text\n\nThe request body as text\n```bash\nbody:text {\n  This is a text body\n}\n```\nbody:xml\n\nThe request body as xml\n```bash\nbody:xml {\n  \n    John\n    30\n  \n}\n```\nbody:form-urlencoded\n\nThe request body as form-urlencoded\n```bash\nbody:form-urlencoded {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:multipart-form\n\nThe request body as multipart-form\n```bash\nbody:multipart-form {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:graphql\n\nThe request body as graphql\n```bash\nbody:graphql {\n  {\n    launchesPast {\n      launch_site {\n        site_name\n      }\n      launch_success\n    }\n  }\n}\n```\nbody:graphql:vars\n\nThe request body as graphql vars\n```bash\nbody:graphql:vars {\n  {\n    \"limit\": 5\n  }\n}\n```\nscript:pre-request\n\nThe request body as pre-request\n```bash\nscript:pre-request {\n  req.setHeader(\"Authorization\", \"{{token}}\");\n}\n```\nscript:post-response\n\nThe request body as post-response\n```bash\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\ntest\n\nThe tests\n```bash\nbody:test {\n  expect(res.status).to.equal(200);\n}\n```\n",
    "parentName": "bru-lang",
    "path": "bru-lang/tag-reference"
  },
  "get-started/bruno-basics/create-a-collection": {
    "name": "create-a-collection",
    "content": "Creating a Collection \n\n\n> *If you have an existing collection inside of another tool that you would like to import, please see [Importing Collections](\n\nCreate a collection by selecting `Create Collection` from the **home screen** or **top left corner** of the app.\nA popup dialog will appear, asking you to name your collection and choose its location in the file system. You can also choose to edit the generated folder's name.\n\n![create collection dialog](/screenshots/new-collection.webp)\n\nSelect `Create` and ... Congratulations! You have successfully created your first collection into Bruno!\n\n[Add a request]( to your collection as a next step! \n\n> *If you’re looking to collaborate and share with your team, please see Please see [Collaboration in Bruno]( \n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-collection"
  },
  "get-started/bruno-basics/create-a-request": {
    "name": "create-a-request",
    "content": "Creating a Request\n\n\nSelect your Collection from the sidebar, and click on the `···` button followed by `New Request` in the dropdown menu.\n\nA dialog will appear, asking you choose the **type** of your request (HTTP, GraphQL, or from cURL), the **name** of your request, the **HTTP verb** and the **URL**.\n\n![create request dialog](/screenshots/new-request.webp)\n\nFill in the details and click `Create`. You have successfully created your first request in Bruno! \n\nFeel free to add headers, query parameters, and a request body to your request, or play around with the other options available.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-request"
  },
  "get-started/bruno-basics/create-a-test": {
    "name": "create-a-test",
    "content": "Create a Test \n\nTo ensure your API is behaving as expected, create a test against it. \n\nBruno supports writing tests by through either:\n- Assertions to declaratively write tests\n- JavaScript\n\nTo get familiar with testing, open a Collection, select a request, and click on the `Assertions` tab\n\nYou can then dictate an expression, operator, and value to test against. \n\n![bru assertions](/screenshots/assertions.webp)\n\n>For more advanced testing scenarios and tips, view the [Scripting]( docs\n\n\n\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-test"
  },
  "get-started/bruno-basics/download": {
    "name": "download",
    "content": "Download Bruno's Desktop Application \n\n\nTo get started, download and install the latest version of Bruno. \n\nVisit the [Downloads page]( and select the option for your operating system. \n\nBruno is available as a native desktop app for macOS, Windows, and Linux.\n\nThe application also comes packaged for these popular distributions:\n\n- **Linux**: snap, apt\n- **macOS**: Homebrew\n- **Windows**: Chocolatey or Scoop\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/download"
  },
  "get-started/bruno-basics/run-a-collection": {
    "name": "run-a-collection",
    "content": "Run a Collection \n\n\nRunning your Bruno Collection allows you to interact with, and test, an API. We allow you to run your Collections a few different ways:\n\nCollection Runner\n\n\nWe have a built-in Collection Runner that allows for **unlimited** runs. \n\nRun your Collection by either clicking the `...` button next to your Collection in the sidebar then select `Run`\n\n![Click Run](/screenshots/collection-runner/collectionrunroot.webp)\n\nor click the Collection Runner icon in the top bar of the application. \n\n![Collection Runner](/screenshots/collection-runner/runnericon.webp)\n\nYou'll now have access to run the collection, add parameters, or set a delay between requests. \n\n> *Data-driven testing by using a .CSV file is available in our Golden and Ultimate Edition*\n\n![Collection Runner](/screenshots/collection-runner/collectionrunner.webp)\n\nAutomating Runs in CI/CD\n\n\nBruno offers a command-line utility to run Collections. This allows you to integrate your tests into a CI and build process. \n\nFor more information, head to the page for [Bruno CLI](",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/run-a-collection"
  },
  "get-started/import-export-data/export-collections": {
    "name": "export-collections",
    "content": "Exporting Collections\n\n\nIf your whole team isn't using Bruno (yet), no fear! You can export Bruno collections to other formats. \n\nOur preffered recommendation for sharing collections is using native Git versioning, but we realize there are other scenarios where exporting makes sense. \n\nBruno allows you to export as:\n- Bruno Collection\n- Postman Collection\n- OpenAPI Specification\n\n> *Exporting as an OpenAPI Specification is only available in our Golden and Ultimate Editions*\n\nTo export, simply hover on the Collection you'd like to export, click the `...` menu and select `Export` \n\n![ExportDialog](/screenshots/migration/CollectionExport.webp)\n\n\nYou can then chose the format you'd like to export to and then designate a location for the file to be saved\n\n![ExportModal](/screenshots/migration/ExportModal.webp)\n\n\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/export-collections"
  },
  "get-started/import-export-data/import-collections": {
    "name": "import-collections",
    "content": "Importing Collections \n\n\nIt's very common that users transition to Bruno from another tool, or chose to use Bruno while their colleagues may chose something else. \n\nWhatever the case, you can import the following formats as Bruno Collections:\n\n- Bruno Collection (if a Collection is manually shared with you)\n- Postman Collection\n- Postman Data Export\n- Insomnia Collection\n- Cloning a Git Repository\n- OpenAPI V3 file \n- OpenAPI V3 URL \n\n> `Cloning a Git Repository` is available in our Golden and Ultimate Editions. Please see [Collaboration in Bruno]( for more details.\n> `Postman Data Export` is available in our Ultimate Edition. Please see [Migrating from Postman]( for more details.\n\nImporting Process\n\n\nEither click `Import Collection` on the home screen of Bruno or select the elipses in the top-left corner then navigate to `Import Collection`. \n\n>*Home screen*\n>\n>![Import from home screen](/screenshots/migration/ImportCollectionHomePage.webp)\n\n>*Options menu*\n>\n>![Import from options menu](/screenshots/migration/ImportcollectionElipses.webp)\n\n\nThen simply select the format you'd like and complete the import process.\n\n>Select your format\n>\n>![Select your format](/screenshots/migration/ImportCollectionModal.webp)\n\n> `Postman Data Export` has [additional steps]( in the import process. \n\n\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/import-collections"
  },
  "get-started/import-export-data/postman-migration": {
    "name": "postman-migration",
    "content": "import Image from 'next/image'\nimport PremiumBadge from \"@/components/premium-badge\";\n\nMigrating from Postman\n\n\nBruno makes migrating from Postman easy. All you need to do is export your collections and environments and import them to Bruno. \n\nCollection Export\n\nOpen Postman and select the collection you want to migrate. Click on the `···` followed by `View more actions` to open the dropdown menu and scroll down until you find `Export`, then click on it.\n\n\n  \n  \n\n\nA popup dialog will appear, select either `Collection v2` or `Collection v2.1` format and click on the `Export` button.\n\n\n\nThe collection will be downloaded as a JSON file. \n\nNow simply follow the instructions for [Importing Collections]( and you're done! \n\nExport Data Dump\n\nYou can export a data dump of all your collections and environments in Postman. You can then import the data into any Bruno.\n\n**To [export a data dump]( do the following in Postman:**\n\n- Select the settings icon in the header, then select `Settings`.\n\n- Select the Data tab, then select `Request Data Export`.\n\n- Select `Export Data`, then select the data types you want to export. You can export collections, environments, or both.\n\n- Select `Request Data Export`.\n\n**To import your Data Dump to Bruno:**\n\n- Open the import menu and select `Postman Data Export`\n\n- Select the zip file where the export was saved\n\n- You will now see a list of all collections available for import. By default, all collections will be selected. You can chose to omit any from the import that you'd like. \n\n- Designate a location for the collections and press `import` \n\n> Although we have a translator for Postman scripts, it's always good practice to review the collections after import, especially if you are using deprecated Postman syntax in your scripts. \n\nEnvironment Export\n\n\nOpen Postman and select the environment you want to migrate. Click on the `···` to open the dropdown menu, followed by `Export` and eventually choose a location to save the environment file.\n\n\n\nNow open Bruno and open a collection by clicking on any request.\nA button in the upper right corner will appear, click on it and select `Configure`.\n\n\n\nA dialog will appear, displaying your previously exported environment file. Select the `Import` button in the bottom left corner to proceed.\nSelect `Postman Environment`, provide the environment file and that's it!",
    "parentName": "get-started",
    "path": "get-started/import-export-data/postman-migration"
  },
  "get-started/javascript-sandbox": {
    "name": "javascript-sandbox",
    "content": "Javascript Sandbox\n\n\nYour collections might include JavaScript code in Variables, Scripts, Tests, and Assertions. \nWe take security seriously and want to ensure you can safely interact with collections, regardless of their source or original authors. \n\nThere are two modes you can choose from:\n![Javascript Sandbox](/screenshots/javascript-sandbox.png)\n\nSafe Mode\n\nJavaScript code is executed in a secure sandbox and cannot access your filesystem or execute system commands. We recommend Safe Mode for most users.\n\n> **Note**: When in doubt, leave the Collection in Safe Mode. You can always switch to Developer Mode later.\n\nDeveloper Mode\n\nJavaScript code has access to the filesystem, can execute system commands and access sensitive information.\n\nWhen to use Developer Mode\n\n- You trust the collection source/authors (Ex: Collection maintained by you/your team) and Safe Mode is not enough for your use case.\n- You need to use external npm packages in your scripts\n- Your collection needs access to filesystem / system commands\n\nWhen to avoid Developer Mode\n\n- You are running a collection that you do not trust (Ex: Downloaded from the internet)\n\n> **Warning**: Developer Mode can be dangerous and should only be used when you fully understand the implications.\n",
    "parentName": "get-started",
    "path": "get-started/javascript-sandbox"
  },
  "get-started/variables/collection-variables": {
    "name": "collection-variables",
    "content": "Collection Variables\n\n\nCollection variables are variables that are scoped to a specific collection. They are useful for storing variables that are used across multiple requests in a collection.\n\nCreating a Collection Variable\n\n* Go to Collection Settings\n* Go to the Variables tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Collection Variables](/screenshots/variables/collection-variables.png)\n\nUsing a Collection Variable\n\nYou can use the `{{varName}}` syntax to use a collection variable in a request.\n\n![Collection Variables Usage](/screenshots/variables/collection-variables-usage.png)\n\nAccess Collection Variable inside scripts\n\nYou can also use the `bru.getCollectionVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nlet namespace = bru.getCollectionVar(\"namespace\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/collection-variables"
  },
  "get-started/variables/folder-variables": {
    "name": "folder-variables",
    "content": "Folder Variables\n\n\nFolder variables are variables that are scoped to a specific folder. They are useful for storing variables that are used across multiple requests in a folder.\n\nCreating a Folder Variable\n\n* Go to Folder Settings (can be accessed from dropdown menu of the folder in the sidebar)\n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Folder Variables](/screenshots/variables/folder-variables.png)\n\nUsing a Folder Variable\n\nYou can use the `{{varName}}` syntax to use a folder variable in a request.\n\n![Folder Variables Usage](/screenshots/variables/folder-variables-usage.png)\n\nAccess Folder Variable inside scripts\n\nYou can also use the `bru.getFolderVar()` function to get the value of a folder variable and use it inside your scripts.\n\n```javascript\nlet bearerToken = bru.getFolderVar(\"bearerToken\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/folder-variables"
  },
  "get-started/variables/overview": {
    "name": "overview",
    "content": "Variables\n\n\n> **Note**: With the release of v1.28.0, we’ve shifted to treating all Request Variables as strings instead of inferring the data type from the value. See [discussion]( for more information.\n\nOverview\n\nVariables in the Bruno allow you to store dynamic values that can be reused across multiple API requests, environments, and workflows. This feature enhances flexibility, maintainability, and efficiency by enabling you to manage frequently changing data points such as tokens, environment-specific URLs, or user-defined values in one place.\n\nTypes\n\n\nThere are 5 types of variables you can create:\n\n- [Collection Variables](./collection-variables.mdx)\n- Environment Variables\n- [Folder Variables](./folder-variables.mdx)\n- [Request Variables](./request-variables.mdx)\n- [Runtime Variables](./runtime-variables.mdx)\n- Process Environment Variables\n\nVariable Precedence\n\n\nWhen a variable is accessed, the following precedence is used to determine which value is used:\n\n1. Collection Variables\n2. Environment Variables\n3. Folder Variables\n4. Request Variables\n5. Runtime Variables\n\nRuntime variables get the highest precedence. Process Environment Variables are accessed using the `{{process.env.VAR_NAME}}` syntax and hence don't compete with the above.\n\nVariable Data Type\n\nAll variables are stored as strings. Bruno does not infer or change the data type of the variable based on the value you set.\n\nScripting API\n\nPlease see the [Scripting API](/scripting/javascript-reference#collection-variables) for more information on how to access variables in your scripts.",
    "parentName": "get-started",
    "path": "get-started/variables/overview"
  },
  "get-started/variables/request-variables": {
    "name": "request-variables",
    "content": "Request Variables\n\n\nRequest variables are variables that are scoped to a specific request. They are useful for storing variables that is used in a specific request.\n\n> **Note**: With the release of v1.28.0, we’ve shifted to treating all Request Variables as strings instead of inferring the data type from the value. See [discussion]( for more information.\n\nCreating a Request Variable\n\n* Go to the Request \n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Request Variables](/screenshots/variables/request-variables.png)\n\nUsing a Request Variable\n\nYou can use the `{{varName}}` syntax to use a request variable in a request.\n\n![Request Variables Usage](/screenshots/variables/request-variables-usage.png)\n\nAccess Request Variable inside scripts\n\nYou can also use the `bru.getRequestVar()` function to get the value of a request variable and use it inside your scripts.\n\n```javascript\nlet source = bru.getRequestVar(\"source\");\nlet destination = bru.getRequestVar(\"destination\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/request-variables"
  },
  "get-started/variables/runtime-variables": {
    "name": "runtime-variables",
    "content": "Runtime Variables\n\n\nOverview\n\n\nRuntime variables are **ephemeral variables** that exist only during the runtime of the API client. These variables are scoped within a collection, meaning they are accessible to all requests within that collection. However, once the API client is closed or restarted, the values of these variables are lost. They are ideal for managing temporary data such as session tokens, dynamic parameters, or other values that are generated or updated during the execution of requests.\n\nCreating a Runtime Variable\n\n\nTo create a runtime variable, you can use the `bru.setVar(name, value)` function. This function allows you to store any value (e.g., tokens, response data, temporary user inputs) as a runtime variable.\n\nExample:\n\nSuppose you receive an authentication token as part of a response body and want to reuse it in subsequent requests. You can capture it using the `bru.setVar()` function in your post response script.\n\n```javascript\nbru.setVar(\"token\", \"res.body.token\");\n```\n\nUsing a Runtime Variable\n\nOnce a runtime variable is created, you can use it in subsequent API requests by referencing it with the `{{variableName}}`syntax. The variable's value will be dynamically injected into the request at runtime.\n\nExample:\n\nIf you’ve stored a token variable using `bru.setVar()`, you can use it in headers, query parameters, body, or URL of subsequent requests like this:\n\n```plaintext\nAuthorization: Bearer {{token}}\n```\n\nYou can also use the `bru.getVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nconst token = bru.getVar(\"token\");\nreq.setHeader(\"Authorization\", `Bearer ${token}`);\n```",
    "parentName": "get-started",
    "path": "get-started/variables/runtime-variables"
  },
  "git-integration/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nCollaboration in Bruno\n\n\nBruno’s superpower is the ability to collaborate natively using version control systems like [Git ↗]( [CVS ↗]( etc, and platforms like GitHub, Gitlab, Bitbucket, etc. This gives you and your teammates confidence that a collection is current as it can live directly next to the application code.\n\nThe process of collaborating on a Bruno collection is more or less the same in all of the above-mentioned platforms. For beginners, you can take a look at this tutorial on version control [here ↗](\n\nThere are two ways to collaborate via native Git in Bruno:\n\n1. Using the terminal or command line to execute Git commands\n2. Using the Bruno's GUI-based Git functionality.\n> GUI-based Git functionality is available within Golden and Ultimate Editions of Bruno.\n\nThese approaches are documented separately for ease of access. So let's dive into the next section.\n\n- [Collaboration via CLI](/git-integration/using-cli)\n- [Collaboration via GUI](/git-integration/using-gui)",
    "parentName": "git-integration",
    "path": "git-integration/overview"
  },
  "git-integration/using-cli": {
    "name": "using-cli",
    "content": "Collaboration via CLI\n\n\nIn the open-source version of Bruno,  Git operations are performed manually using the terminal or tools like VSCode's Git features. \n\nThis includes:\n\n- [Initializing a Git repository](#initializing-git-in-bruno-collection)\n- [Adding and committing changes](#adding-and-committing-changes)\n- [Pushing and pulling updates](#pushing-and-pulling-changes)\n\nBelow is a step-by-step guide on how to use Git with Bruno in the open-source version.\n\nInitializing Git in a Collection\n\n\nTo add your collection to version control, you need to initialize a Git repository in the directory where your .bru files are stored using the following steps:\n\n1. **Navigate to the Bruno Collection Location:**\n\n   - Navigate to the location on your PC where you created the Bruno collection, and copy the path. [^1]\n\n2. **Change directory in Terminal:**\n\n   - Run the following command in the terminal:\n\n     ```bash\n     cd path/to/your/bruno/collection\n     ```\n\n3. **Initialize Git:**\n   - Run the following command to initialize Git in the Bruno collection directory:\n\n     ```bash\n     git init\n     ```\n\nAdding and Committing Changes\n\n\nAfter initializing the Git repository, you can add and commit changes to your collection.\n\n1. **Creating a New HTTP Request in Bruno App**\n\n    - Hover over the collection name in the Bruno app.\n    - Click on the three dots, then click on \"New Request.\"\n    - Type in the name of the request and populate the URL field with `\n    - After populating the fields with appropriate values, click on the \"Create\" button, or you can press ENTER/RETURN on your keyboard to create the request. This will create a new `.bru` file with the name that you just specified.\n\n2. **Adding and committing the changes**\n   - Stage all the changes made inside the collection:\n\n     ```bash\n     git add .\n     ```\n   - Commit the changes:\n\n     ```bash\n     git commit -m \"Created my first Bruno request 🐶\"\n     ```\n\nPushing and Pulling Changes\n\n\nTo share your changes with others, you can push and pull your commits to/from a remote repository.\n\n1. **Pushing changes**\n\n   ```bash\n   git push -u origin main\n   ```\n\n2. **Pulling changes**\n\n   ```bash\n   git pull origin main\n   ```\n",
    "parentName": "git-integration",
    "path": "git-integration/using-cli"
  },
  "git-integration/using-gui": {
    "name": "using-gui",
    "content": "import Video from \"@/components/Video\"\nimport PremiumBadge from \"@/components/premium-badge\";\n\nCollaboration using GUI\n\n> GUI-based Git collaboration is available in Golden and Ultimate Editions of Bruno.\n\nInitializing GIT is simpler in the Golden edition of Bruno. Simply click on the \"initialize\" button in the Git modal dialogue to initialize the Collection with Git.\n\n\n\nAdding and Committing the Changes\n\n\nOnce you make the changes, you can click on the Git UI button and include the changes you made to be committed.\n\n\n\nPushing and pulling the Changes\n\n\nLeveraging Bruno's GUI-based Git integration allows both engineering and non-engineering teammates work in an easy, efficient, and quick manner to ensure there is confidence in the accuracy of your Collections. \n\n\n\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui"
  },
  "introduction/feedback-community": {
    "name": "feedback-community",
    "content": "Feedback & Community \n\n\nBruno is building a community of API practioners who want to challenge the state of tooling available. Our roadmap and releases are driven by your feedback and, as an open-source project, sometimes directly from your PRs. \n\nHelp us continue building the most powerful, logical, and dev-friendly API tool available today!\n\nHow to Engage\n\n- Raise a [GitHub Issue]( \n- Star us on [Github](\n- Join our [Discord](\n- Email our [Support Team](mailto:support@usebruno.com)\n",
    "parentName": "introduction",
    "path": "introduction/feedback-community"
  },
  "introduction/manifesto": {
    "name": "manifesto",
    "content": "Manifesto\n\n\nIt's time for a revolution in API client technology! \n\nWe refuse to be shoehorned into a proprietary version control system for collaborating on API collections and we don't want the details of our APIs, API requests, or API responses synced to the cloud and potentially be made public. \n\nWe are an opensource project, rising up against the monopoly of bloated and closed systems. We believe that API collections should be co-located within your source code repository, serving as a living set of examples on how to use the API.\n\nWith Bruno, collections become first-class citizens, co-located with related information and easily version controlled. We say goodbye to bloated workspaces and global environments, and embrace the benefits of co-location.\n\nWe dream of a world where developers can clone a code repo, get it up and running, use Bruno to browse the examples on how to use the API and start playing with it. No more horror stories of *\"Tim had the collections for the payment-api service, but he left the company last month.\"*\n\nJoin us in our mission to create a better API client for developers. Say goodbye to bloatware and hello to simplicity, efficiency and freedom. Try Bruno today and experience the difference for yourself.\n",
    "parentName": "introduction",
    "path": "introduction/manifesto"
  },
  "introduction/what-is-bruno": {
    "name": "what-is-bruno",
    "content": "What is Bruno? \n\n\nBruno is a Git-friendly and offline-first open-source API client aimed at revolutionizing the status quo represented by tools like Postman and Insomnia. \n\nWe aim to solve two core issues: \n\n**Collaboration**\n\n\nBruno’s superpower is collaboration through a live connection to your version control system, such as Git. \n\nWith Bruno, collections are stored directly in a folder on the filesystem. A plain text markup language, Bru, is used to save information about API requests. \n\n> *Go to documentation for [Collaboration via Git](../git-integration/overview)*\n\n**Data Privacy and Security**\n\n\nLegacy API clients have moved towards capturing every piece of data they can, from your PII (name, email), to the actual contents of your API requests and responses (keys, tokens, etc).\n\nBruno is an offline tool. There's no concept of a login or account, and there is no cloud connection or syncing of the work you do in Bruno. \n\n\n\n>\n> - *If you or your organization purchases a Golden Edition license, your email is required simply for the issuance of a license key.* \n> - *If your organization purchases an Ultimate Edition license, your email can be held in a self-hosted licensing server which you manage.*\n>\n",
    "parentName": "introduction",
    "path": "introduction/what-is-bruno"
  },
  "license-management/overview": {
    "name": "overview",
    "content": "License Management\n\n\nFor our open-source users, there is no concept of license management! Simply download, install, and go! \n\nOur commercial plans have different license management aspects. \nIf you have any questions about what plan is best suited for you, please see our [pricing page]( or [contact us](mailto:sales@usebruno.com) to discuss. \n\nLicense Types\n\n\nGolden Edition License\n\n\nFor Individual Use\n\n\n- [Activating License](/license-management/golden-edition/individual/activate-license)\n\nFor Organizations\n\n\n- [Managing License](/license-management/golden-edition/organization/manage-licenses)\n- [Activating License](/license-management/golden-edition/organization/activate-license)\n\nUltimate Edition License\n\n\n- [Managing License](/license-management/ultimate-edition/manage-licenses)\n- [Activating License](/license-management/ultimate-edition/activate-license)",
    "parentName": "license-management",
    "path": "license-management/overview"
  },
  "scripting/external-libraries": {
    "name": "external-libraries",
    "content": "External Libraries\n\n\nBruno supports loading any npm module to use in your scripting workflows.\n\nYou need to add a `package.json` file where your collection is stored.\n```js\n{\n  \"name\": \"github-rest-api-collection\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"homepage\": \"\n  \"dependencies\": {\n    \"@faker-js/faker\": \"8.3.1\"\n  }\n}\n```\n\nAnd then run npm install inside your collection folder\n```bash\nnpm install\n```\n\nAnd then you can require the node module in your script as usual.\n**Example:**\n```js\nconst { faker } = require('@faker-js/faker');\n\nconst randomName = faker.name.fullName();\nconst randomEmail = faker.internet.email();\n\nreq.setBody({\n  name: randomName,\n  email: randomEmail\n});\n```\n",
    "parentName": "scripting",
    "path": "scripting/external-libraries"
  },
  "scripting/inbuilt-libraries": {
    "name": "inbuilt-libraries",
    "content": "Inbuilt Libraries\n\n\nBelow are the list of inbuilt libraries that you can `require`  in your scripts.\n\n- [ajv]( - Ajv JSON schema validator\n- [axios]( - Promise based HTTP client for the browser and node.js\n- [node-fetch]( - A light-weight module that brings Fetch API to Node.js.\n- [atob]( -  Turn base64-encoded ascii data back to binary.\n- [btoa]( -  Turn binary data to base64-encoded ascii.\n- [chai]( -  BDD/TDD assertion library for node.js and the browser.\n- [lodash]( -  A modern JavaScript utility library delivering modularity, performance & extras.\n- [moment]( -  Parse, validate, manipulate, and display dates and times in JavaScript.\n- [uuid]( -  For the creation of RFC4122 UUIDs\n- [nanoid]( - A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n- [crypto-js]( - JavaScript library of crypto standards.\n\n> **Note:** `node-fetch` is not available in [Safe Mode](/get-started/javascript-sandbox/overview).\n\n**Example:**\n```js\nconst { nanoid } = require(\"nanoid\");\n\nreq.setHeader(\"transaction-id\", nanoid());\n```\n",
    "parentName": "scripting",
    "path": "scripting/inbuilt-libraries"
  },
  "scripting/javascript-reference": {
    "name": "javascript-reference",
    "content": "JavaScript API Reference\n\n\nHere is the complete set of API reference for the scripting feature in Bruno.\n\nRequest\n\nThis `req` variable is available inside your scripting and testing context.\n\nBelow is the API documentation for the methods available on `req`\n`getUrl`\n\nGet the current request url\n\n**Example:**\n```javascript\nlet url = req.getUrl();\n```\n\n`setUrl`\n\nSet the current request url\n\n**Example:**\n```javascript\nreq.setUrl(\"\n```\n\n`getMethod`\n\nGet the current request method\n\n**Example:**\n```javascript\nconst method = req.getMethod();\n```\n\n`setMethod`\n\nSet the current request method\n\n**Example:**\n```javascript\nreq.setMethod(\"POST\");\n```\n\n`getHeader`\n\nGet the request header by name\n\n**Example:**\n```javascript\nreq.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the current request headers\n\n**Example:**\n```javascript\nconst headers = req.getHeaders();\n```\n\n`setHeader`\n\nSet the request header by name\n\n**Example:**\n```javascript\nreq.setHeader( \"content-type\", \"application/json\");\n```\n\n`setHeaders`\n\nSet the current request headers\n\n**Example:**\n```javascript\nreq.setHeaders({\n  \"content-type\": \"application/json\",\n  \"transaction-id\": \"foobar\"\n});\n```\n\n`getBody`\n\nGet the current request body/payload\n\n**Example:**\n```javascript\nconst body = req.getBody();\n```\n\n`setBody`\n\nSet the request body/payload\n\n**Example:**\n```javascript\nreq.setBody({\n  \"username\": \"john nash\",\n  \"password\": \"governingdynamics\"\n});\n```\n\n`setMaxRedirects`\n\nSet the maximum number of redirects to follow\n\n**Example:**\n```javascript\nreq.setMaxRedirects(5);\n```\n\nResponse\n\nThis `res` variable is available inside your scripting and testing context.\n\nBelow are the properties available on the `res` object.\n| Property | Description |\n|----------|-------------|\n| status | The response status code|\n| statusText | The response status text|\n| headers | The response headers|\n| body | The response body|\n| responseTime | The API response time|\n\nBelow are the methods available on the `res` object.\n\n`getStatus`\n\nGet the response status\n\n**Example:**\n```javascript\nlet status = res.getStatus();\n```\n\n`getHeader`\n\nGet the response header by name\n\n**Example:**\n```javascript\nlet transactionId = res.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\nGet the response headers\n\n**Example:**\n```javascript\nlet headers = res.getHeaders();\n```\n\n`getBody`\n\nGet the response data\n\n**Example:**\n```javascript\nlet data = res.getBody();\n```\n\n`getResponseTime`\n\nGet the response time\n\n**Example:**\n```javascript\nlet responseTime = res.getResponseTime();\n```\n\n\nBru\n\nThe `bru` variable is available inside your scripting and testing context.\nIt exposes methods that allow you to interact with, e.g., process variables,\nenvironment variables and collection variables.\n\nBelow is the API documentation for the methods available on `bru`\n\nHelpers\n\n`sleep`\n\nPauses execution for the specified duration. This is useful for introducing delays or waiting for a specific amount of time before proceeding with the next operation.\n\n**Example:**\n```javascript\nawait bru.sleep(3000);\n```\n\n`disableParsingResponseJson`\n\nTo prevent the automatic parsing of the JSON response body and work directly with the raw data, you can use the expression below in the pre-request script of the request.\n\n**Example:**\n```javascript\nbru.disableParsingResponseJson();\n```\n\nNode process environment\n\nBruno allows you to get Node process environment variables on the fly.\n\n`getProcessEnv`\n\nGet the Node process environment variable.  This allows secret token usage without committing secrets to version control.\n\n**Example:**\n```javascript\nlet secret_token = bru.getProcessEnv(\"secret_access_token\");\n```\nEnvironments\n\nBruno allows you to get and set Bruno environment variables on the fly.\n\n`getEnvVar`\n\nGet the Bruno environment variable\n\n**Example:**\n```javascript\nlet token = bru.getEnvVar(\"access_token\");\n```\n`setEnvVar`\n\nSet the Bruno environment variable\n\n**Example:**\n```javascript\nfunction onResponse(res) {\nlet data = res.getBody();\nlet token = bru.setEnvVar(\"access_token\", data.token);\n}\n```\n\nCollection Variables\n\nBruno allows you to get collection variables on the fly.\n\n`getCollectionVar`\n\nGet the collection variable\n\n**Example:**\n```javascript\nlet namespace = bru.getCollectionVar(\"namespace\");\n```\n\nFolder Variables\n\nBruno allows you to get folder variables on the fly.\n\n`getFolderVar`\n\nGet the folder variable\n\n**Example:**\n```javascript\nlet company = bru.getFolderVar(\"company\");\n```\n\nRuntime Variables\n\nBruno allows you to get, set and delete runtime variables on the fly.\n\n`getVar`\n\nGet the runtime variable\n\n**Example:**\n```javascript\nlet petId = bru.getVar(\"petId\");\n```\n`setVar`\n\nSet the runtime variable\n\n**Example:**\n```javascript\nlet data = res.getBody();\nbru.setVar(\"petId\", data.id);\n```\n\n`deleteVar`\n\nDelete the runtime variable\n\n**Example:**\n```javascript\nbru.deleteVar(\"petId\");\n```\n\nRequest Order\n\nYou can influence the order in which requests are being run by the request-runner (UI) or the CLI.\n\n`setNextRequest`\n\nBy default, the collection runner (UI) and the CLI run requests in order.\nYou can change the order by calling `setNextRequest` with the name of the next request to be run.\nThis works only in a post-request script or test-script.\n\n**Example:**\n```javascript\nbru.setNextRequest(\"Get process status\");\n```\n\nYou can also abort the run by explicitly setting the next request to `null`\n**Example:**\n```javascript\nbru.setNextRequest(null);  // aborts the run gracefully\n```",
    "parentName": "scripting",
    "path": "scripting/javascript-reference"
  },
  "scripting/request/request-object": {
    "name": "request-object",
    "content": "Request Object\n\n\nThe `req` object represents the HTTP request made to the server. It contains various properties that define the request details.\n\n`req` Sub-Object\n\n\nThe `req` sub-object contains detailed information about the request.\n\n- `assertions` : An array containing any assertions associated with the request. *See [assertions](/testing/assertions)*.\n- `auth` : An object containing authentication credentials, such as username and password.\n- `headers` : A sub-object representing the HTTP headers associated with the request.\n- `method` : The HTTP method used for the request (e.g., \"GET\", \"POST\").\n- `mode` : The mode of the request (e.g., \"none\", \"cors\").\n- `responseType` : The expected response type for the request (e.g., \"text\", \"json\").\n- `script` : An object containing script-related information for the request.\n- `signal` : A signal object used to abort the request.\n- `url` : The URL of the request.\n- `vars` : An object containing any variables associated with the request. *See [variables](/scripting/vars)*.\n\nHeaders\n\n\nThe `headers` sub-object of the `req` object contains key-value pairs representing the HTTP headers associated with the request.\n\n```javascript\n// Example usage\nconsole.log(req.headers);\n/* Output: {\n  authorization: 'Bearer ',\n  'content-type': 'application/json',\n  accept: 'application/json',\n  // Add more headers as needed...\n} */\n```\n\nMethod\n\n\nThe `method` property of the `req` object specifies the HTTP method used for the request. Common HTTP methods include \"GET\", \"POST\", \"PUT\", \"DELETE\", etc. The method indicates the type of action the request wishes to perform on the resource. The value of the `method` property should be a string representing the desired HTTP method for the request.\n\n```javascript\n// Example usage\nconsole.log(req.method); // Output: \"GET\"\n```\n\nURL\n\n\nThe `url` property of the `req` object represents the Uniform Resource Locator (URL) of the request. It specifies the address of the resource being requested by the client. Variables enclosed within double curly braces (`{{...}}`) in the URL string are placeholders that may be replaced with actual values at runtime. These variables are not directly visible within the URL string and are typically encapsulated during request processing.\n\n```javascript\n// Example usage\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\n```\n\n\nExample Usage\n\n\n```javascript\n// Example request object\nconst req = {\n  assertions: [],\n  auth: { username: 'myUsername', password: 'mySuperPassword' },\n  headers: {\n    authorization: 'Bearer ',\n    'content-type': 'application/json',\n    accept: 'application/json',\n    // Add more headers as needed...\n  },\n  method: 'GET',\n  mode: 'none',\n  responseType: 'arraybuffer',\n  script: {\n    req: \"// Create an array of objects\\nconst data = [\\n  { i…q);\\nconst myVariable = bru.getEnvVar('password');\"\n  },\n  signal: {},\n  url: '{{base.url}}/users/2?queryTest=queryResult',\n  vars: {}\n};\n\n\n// Accessing request properties\nconsole.log(req.method); // Output: \"GET\"\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\nconsole.log(req.headers.authorization); // Output: \"Bearer \"\nconsole.log(req.auth.username); // Output: \"myUsername\"\n```",
    "parentName": "scripting",
    "path": "scripting/request/request-object"
  },
  "scripting/request/sync-requests": {
    "name": "sync-requests",
    "content": "Sync requests\n\n\nYou can make synchronous requests in your pre/post scripts. By synchronous, we mean that you can await a request in your scripting code.\n\nBelow is an inbuilt example of using `axios` library to\n```js\nconst axios = require(\"axios\");\n\nconst response = await axios.get(\"\n\nbru.setVar(\"avatarUrl\", response.data.avatar_url);\n```\n\n**Example:**\n![sync requests](/screenshots/sync-requests.webp)\n\n",
    "parentName": "scripting",
    "path": "scripting/request/sync-requests"
  },
  "scripting/response/response-object": {
    "name": "response-object",
    "content": "Response Object\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](/testing/assertions), [scripting](../getting-started) and [testing](/testing/introduction)\ncontexts can be used to extract values from the response body, headers and status.\n\n*Note that the `res` object is only available in the context of a request.*\n\nYou can also access it with [response queries](./response-query).\n\nObject Structure\n\n\nThe `res` object has the following properties:\n\n- `body`: Represents the response body containing data returned to the client.\n- `headers`: Contains key-value pairs representing HTTP headers associated with the response.\n- `status`: Represents the HTTP status code indicating the outcome of the request.\n\nProperty Descriptions\n\n\n`body`\n\n\nThe `body` property of the `res` object contains the response data sent to the client. It can be a string, an object, or a stream, depending on the application's needs.\n\n`headers`\n\n\nThe `headers` property contains HTTP headers associated with the response. These headers provide metadata about the response, such as content type, encoding, and caching directives.\n\n`status`\n\n\nThe `status` property represents the HTTP status code of the response. It indicates the outcome of the request, such as success, redirection, client error, or server error.\n\nExample Usage\n\n\n```javascript\n// Example response object\nconst res = {\n  body: '{\"message\": \"Hello, world!\"}',\n  headers: {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache',\n  },\n  status: 200,\n};\n\n// Accessing response properties\nconsole.log(res.body); // Output: '{\"message\": \"Hello, world!\"}'\nconsole.log(res.headers['Content-Type']); // Output: 'application/json'\nconsole.log(res.status); // Output: 200\n```\n\n\n\n\n\n\n\n",
    "parentName": "scripting",
    "path": "scripting/response/response-object"
  },
  "scripting/response/response-query": {
    "name": "response-query",
    "content": "Response Query\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](/testing/assertions), [scripting](../getting-started) and [testing](/testing/introduction) contexts can be queried for data by invoking it like below.\n\nThink of it as `lodash.get()` on steroids\n\n```javascript\nres('order.total')\n```\n\nExamples\n\n```javascript\nconst data = {\n  customer: {\n    address: {\n      city: \"bangalore\"\n    },\n    orders: [\n      {\n        id: \"order-1\",\n        items: [\n          { id: 1, amount: 10 },\n          { id: 2, amount: 20 }\n        ]\n      },\n      {\n        id: \"order-2\",\n        items: [\n          { id: 3, amount: 30 },\n          { id: 4, amount: 40 }\n        ]\n      }\n    ]\n  },\n};\n```\n| Query                                   | Output                             |\n|-----------------------------------------|------------------------------------|\n| res(\"customer.address.city\")            | bangalore                          |\n| res(\"customer.orders.items.amount\")     | [10, 20, 30, 40]                   |\n| res(\"\"customer.orders.items.amount[0]\") | 10                                 |\n| res(\"..items.amount\")                   | [10, 20, 30, 40]                   | |\n| res(\"..amount\")                         | [10, 20, 30, 40]                   |\n| res(\"..items.amount[0]\")                | 10                                 |\n| res(\"..items[0].amount\")                | 10                                 |\n| res(\"..items[5].amount\")                | undefined                          |\n| res(\"..id\")                             | [\"order-1\", 1, 2, \"order-2\", 3, 4] |\n| res(\"customer.orders.foo\")              | undefined                          |\n| res(\"..customer.foo\")                   | undefined                          |\n| res(\"..address\")                        | [\\{ city: \"bangalore\" \\}]          |\n| res(\"..address[0]\")                     | \\{ city: \"bangalore\" \\}            |\n\nAPI\n\n\nStandard dot notation\n\n\n**Example:**\n```javascript\nres('customer.orders.items.amount')\n```\n\nDeep navigation .. double dots\n\n\n**Example:**\n```javascript\nres('..items.amount')\n```\n\nArray indexing\n\n\n**Example:**\n```javascript\nres('..items[0].amount')\n```\n\nArray filtering [?] with corresponding filter function\n\n\n**Example:**\n```javascript\nres('..items[?].amount', i => i.amount > 20)\n```\n\n\nArray mapping [?] with corresponding mapper function\n\n\n**Example:**\n```javascript\nres('..items..amount[?]', amt => amt + 10)\n```\n\n\n\n\n\n\n\n\n",
    "parentName": "scripting",
    "path": "scripting/response/response-query"
  },
  "scripting/vars": {
    "name": "vars",
    "content": "Vars\n\n\nVars allow you to set variables before request, and after you receive the response.\n\nVars are scoped within the request and cannot be accessed outside of it.\n\n> Note: Prior to v1.20.0, request vars were accessible at the collection scope, but this is no longer the case.\n\nIn the *Pre Request Variables* section, you can write any Strings, Numbers or any valid JavaScript literal.\n\nIn the *Post Response Variables* section, you can write any valid JavaScript expression. The res object is available, allowing you to declaratively parse the [response](./javascript-reference#response) and set variables, instead of writing scripts to do the same.\n\nFor parsing the response, you can checkout the [response query](./response/response-object) that allows you to easily query your response.\n\n**Example:**\n![bru vars](/screenshots/vars.webp)\n\n![Screenshot showing how to use defined variables in the request body](/screenshots/set-vars.webp)\n",
    "parentName": "scripting",
    "path": "scripting/vars"
  },
  "scripting/whitelisting-modules": {
    "name": "whitelisting-modules",
    "content": "Whitelisting Modules\n\n\nNot all built-in modules are accessible in scripts out of the box in Bruno for security reasons. You can manually enable/whitelist these modules by modifying your `bruno.json`.\n\n**Example:**\n\nTo enable the `child_process` module, you can put the following in your `bruno.json` file:\n\n```json\n{\n  \"scripts\": {\n    \"moduleWhitelist\": [\"child_process\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    }\n  }\n}\n```\n\nNote that `filesystemAccess` is required for `child_process` to work as expected. This may be required for other built-in modules as well",
    "parentName": "scripting",
    "path": "scripting/whitelisting-modules"
  },
  "secrets-management/dotenv-file": {
    "name": "dotenv-file",
    "content": "Secrets Management\n\n\nDotEnv File\n\n\nThis approach is inspired by how usually developers manage secrets in their source code.\n\nIn this approach, you can store all your secrets in a `.env` file at the root of your collection folder.\n\nBruno will automatically load the secrets from this file and make them available to your collection via `process.env.`.\n\n![dot env vars](/screenshots/dot-env-vars.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: \n  jwtToken: {{process.env.JWT_TOKEN}}\n}\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\nDon't forget to add `.env` to your `.gitignore` file.\n\nYou can store a `.env.sample` file in your collection folder to help other developers get started with the collection.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/dotenv-file"
  },
  "secrets-management/hashicorp-vault/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nYou have the option to integrate [HashiCorp Cloud Vault]( [Vault Enterprise Server]( or a [Local Vault server]( as your secret provider.\n\nSetting Up Vault Server\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo configure a **Vault server** secret provider, you can opt for either **Token** or **AppRole** authentication.\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Choose **Vault Server** as the provider type and select your preferred authentication method.\n\n4. Enter ` if using a local server, or the URL of the hosted server (e.g., `\n\n5. Provide the necessary [Token]( or [AppRole]( credentials.\n\n6. Click on **Add** to save the secret provider.\n\n\n\n\nSetting up Vault Cloud\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo set up a **Vault Cloud** secret provider, follow these steps:\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Select **Vault Cloud** as the provider type.\n\n4. Maintain the default settings for `Token Endpoint` and `Secrets Endpoint`, or modify them if necessary.\n\n5. Provide the required [Client Credentials](\n\n6. Add one or more Projects (Apps) to the secret provider.\n\n7. Click on **Add** to save the secret provider.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/adding-a-secret-provider"
  },
  "secrets-management/hashicorp-vault/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nConfiguring and Fetching secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n2. Select `Vault` as the provider.\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n5. Provide a name for the secret and specify the relative path to where the secret is stored in Vault.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the secret providers, and click on the `Fetch` button.\n\n7. The fetched secrets will be displayed in the table along with their names and paths.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/configuring-and-fetching-secrets"
  },
  "secrets-management/hashicorp-vault/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHashiCorp Vault\n\n\nHashiCorp Vault is a tool for managing secrets and protecting sensitive data. It is designed to provide a secure, reliable, and scalable solution for managing secrets such as API keys, passwords, certificates, and other sensitive data. Vault provides a centralized platform for storing and accessing secrets, and includes features such as encryption, access control, auditing, and more.\n\nBruno allows you to easily integrate Hashicorp Vault and access your secrets securely. With Bruno, you can securely store your Vault credentials and access them without exposing sensitive information.\n\nIn this guide, we will show you how to set up HashiCorp Vault with Bruno.\n\n- [Adding a secret provider](/secrets-management/hashicorp-vault/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/hashicorp-vault/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/overview"
  },
  "secrets-management/hashicorp-vault/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nSecrets are accessed in the same way as collection and environment variables. The secrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\n\n\nSecrets need to be prefixed with `$secrets` followed by the `secret name` and then the `key name`, all separated by periods.\n\n\n\nPattern: `$secrets`.``.``.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/using-secrets"
  },
  "secrets-management/hashicorp-vault/using-with-cli": {
    "name": "using-with-cli",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing with Bruno CLI\n\nPre-requisites\n\n\nAdd the vault connection configuration to the collection's **secrets.json** file (create one if it doesn't exist).\nYou can use environment variables in the configuration to avoid hardcoding sensitive information.\n\nThis is the only additional configuration required to use the vault secrets in the collection using the CLI.\n\n\nUsage\n\n\nThere are 3 different CLI configurations that can be used.\n\nVault server with token authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"token\",\n        \"token\": \"{{authToken}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var authToken=your-vault-token\n```\n\n\nVault server with appRole authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"app_role\",\n        \"appRole\": {\n          \"role\": \"bruno\",\n          \"roleId\": \"{{roleId}}\",\n          \"secretId\": \"{{secretId}}\"\n        }\n      }\n    }\n  }\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var roleId=your-role-id --env-var secretId=your-secret-id\n```\n\n\nVault cloud with client credentials authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-cloud\",\n    \"vaultCloudConfig\": {\n      \"auth\": {\n        \"method\": \"client-credentials\",\n        \"clientCredentials\": {\n          \"tokenEndpoint\": \"{{tokenEndpoint}}\",\n          \"secretsEndPoint\": \"{{secretsEndpoint}}\",\n          \"clientId\": \"{{clientId}}\",\n          \"clientSecret\": \"{{clientSecret}}\"\n        }\n      },\n      \"project\": {\n        \"name\": \"{{projectName}}\",\n        \"projectId\": \"{{projectId}}\",\n        \"organizationId\": \"{{organizationId}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var tokenEndpoint=your-token-endpoint --env-var secretsEndpoint=your-secrets-endpoint --env-var clientId=your-client-id --env-var clientSecret=your-client-secret --env-var projectName=your-project-name --env-var projectId=your-project-id --env-var organizationId=your-organization-id\n```\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/using-with-cli"
  },
  "secrets-management/overview": {
    "name": "overview",
    "content": "Secrets Management\n\n\nProblem Statement\n\n\nIn any collection, there are secrets that need to be managed. These secrets can be anything such as API keys, passwords, or tokens.\n\nA common practice is to store these secrets in environment variables.\n\nThere are two ways in which developers share bruno collections:\n* Check in the collection folder to source control (like git)\n* Export the collection to a file and share it\n\nIn both these cases we want to ensure that the secrets are stripped out of the collection before it is shared.\n\nSolution\n\n\nBruno offers two approaches to manage secrets in collections.\n\n- [DotEnv File](/secrets-management/dotenv-file)\n- [Secret Variables](/secrets-management/secret-variables)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/overview"
  },
  "secrets-management/secret-variables": {
    "name": "secret-variables",
    "content": "Secrets Management\n\n\nSecret Variables\n\n\nIn this approach, you can check the `secret` checkbox for any variable in your environment.\n\nBruno will manage your secrets internally and will not write them into the environment file.\n\n![secret variables](/screenshots/secret-variables.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: \n}\nvars:secret [\n  jwtToken\n]\n\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\n\nWhen you export your collection as a file, Bruno will not export the secret variables.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-variables"
  },
  "testing/assertions": {
    "name": "assertions",
    "content": "Assertions\n\n\nAssertions allow you to declaratively write tests.\n\nThis should cover most of your testing needs. For complex tests, you can write test scripts.\n\n**Example:**\n![bru assertions](/screenshots/assertions.webp)",
    "parentName": "testing",
    "path": "testing/assertions"
  },
  "testing/data-driven-testing": {
    "name": "data-driven-testing",
    "content": "import Video from \"../../components/Video\"\n\n\nIterate Using Data Files \n\n\nThe **Collection Runner** feature allows you to iterate over data files, making it easy to automate and manage data-driven requests. Bruno supports both CSV and JSON files for running requests, so you can efficiently run tests or process multiple data inputs.\n\nIntroduction \n\n\n  In this tutorial, we'll explore the Collection Runner feature, which enables you to run collections using custom data for each iteration. \nSteps to Get Started\n\n\n1. **Open the Bruno app.**\n2. **Create a collection** called `runner-example`\n3. **Create a POST request** and name it `runner-request`\n4. **Use the URL**: `\n5. **Select the JSON format for the request body** and add the following data:\n\n```bash\n{\n    \"name\": \"morpheus\",\n    \"job\": \"leader\"\n}\n```\n\n> Selecting the JSON option for the request body and adding JSON data is optional.\n\n\nUsing the Collection Runner\n\n\nWe will create a sample data file `csv-example.csv` that includes input fields such as `name` and `job` to be used in data-driven testing. You need to create a CSV or JSON file according to the specific requirements of the API you're working with.\n\nSince the API in this case expects two data inputs  `name` and `job`  the file should contain these fields. Here's an example of how to structure your data:\n\n\n**1. CSV Format Example**  \nA sample CSV file might look like this:\n\n```bash copy\n\nname, job\nJohn Doe, Software Engineer\nJane Smith, Product Manager\nMark Lee, Data Scientist\n\n```\n\n**2. JSON Format Example**  \nA sample JSON file might look like this:\n\n``` bash copy\n[\n  { \"name\": \"John Doe\", \"job\": \"Software Engineer\" },\n  { \"name\": \"Jane Smith\", \"job\": \"Product Manager\" },\n  { \"name\": \"Mark Lee\", \"job\": \"Data Scientist\" }\n]\n```\n\nNow you're ready to use the Collection Runner. You can access it in two ways:\n\nUsing the Bruno App\n\n\n1. Click on the runner icon in the right-hand navbar.\n2. Check the **Run with Parameters** option.\n3. Select the file type: CSV or JSON.\n4. Click **Run Collection**.\n\nOnce the execution is complete, you can review the results for each individual request and check their statuses.\n\n\n\n\nUsing the Bruno CLI\n\n\n\n\n1. Navigate to the root directory of your Bruno collection.\n2. Run the following command:\n\n   \n```bash copy\n   bru run --reporter-html results.html --csv-file-path /path/to/csv/file.csv \n```\nor \n\n```bash copy\n   bru run --output results.html --format html --csv-file-path /path/to/csv/file.csv \n```\n   \n\n\n\n\nIt will create a `results.html` file in your Bruno collection's root directory. You can view this file in your browser.\n\n\nCommand Overview \n\n1. `--reporter-html results.html`: Generates a human-readable HTML report.\n2. `--csv-file-path /path/to/csv/file.csv`: Specifies the path to the CSV file you want to use.\n\n\n[Bruno CLI Overview](../bru-cli/overview)",
    "parentName": "testing",
    "path": "testing/data-driven-testing"
  },
  "testing/introduction": {
    "name": "introduction",
    "content": "Testing\n\n\nBruno supports writing automation test scripts in JavaScript for your API requests to assert its behaviour.\n\nSome of the benefits include\n- Increased efficiency: The tests can be run repeatedly, reducing the time and effort required for manual testing.\n- Increased coverage: Automated tests can cover a larger range of scenarios and edge cases compared to manual testing.\n- Continuous integration/continuous delivery (CI/CD): Automated API tests can be integrated into a CI/CD pipeline, ensuring that API changes are thoroughly tested before deployment.\n- Easier maintenance: Automated tests can be easily updated as the API evolves, reducing the maintenance burden compared to manual tests.\n- Easier regression testing: Automated tests can be easily repeated after changes are made to the API, reducing the time required for regression testing.\n\n**Example:**\n```javascript\ntest(\"should be able to login\", function() {\n  const data = res.getBody();\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should receive the token\", function() {\n  const data = res.getBody();\n  expect(data.token).to.be.a('string');\n});\n```\n\n**Screenshot:**\n\n![bru lang sample](/screenshots/testing.webp)\n\nScripting API\n\nPlease see the [Scripting API](/scripting/javascript-reference#collection-variables) for a comprehensive set of methods that enable you to write custom JavaScript code to automate and test your API requests in Bruno. It allows you to manipulate request variables, modify headers, handle response data, and implement complex logic directly within your test scripts.",
    "parentName": "testing",
    "path": "testing/introduction"
  },
  "tools/translator": {
    "name": "translator",
    "content": "import { Translator } from \"../../components/translator/translator\";\n\nexport async function getStaticProps() {\n  const fs = require('fs');\n  const path = require('path');\n  const themesDir = path.join(process.cwd(), 'public/static/themes');\n  const themeFiles = fs.readdirSync(themesDir);\n  const themes = themeFiles\n    .filter(file => file.endsWith('.json'))\n    .map(file => file.replace('.json', ''));\n  return {\n    props: {\n      ssg: {\n        themes\n      }\n    }\n  };\n}\n\nScripts Translator\n\n\nWelcome to the **Postman** to **Bruno** scripts translator. \\\nThis is the same function that runs behind the **Import Postman Collection** feature in Bruno\n\n",
    "parentName": "tools",
    "path": "tools/translator"
  }
}