{
  "advanced-guides/starter-guide": {
    "name": "starter-guide",
    "content": "import { Callout } from 'nextra/components'\n\nBruno Starter Guide\n\n\nBruno offers a fast, Git-friendly approach to API development that's fundamentally different from traditional API clients. This comprehensive guide will take you from your first request to advanced automation through structured, hands-on learning.\n\nWhat You'll Learn\n\n\nThis guide provides a progressive learning path through 13 carefully designed challenges, each building on skills from previous sections. You'll master everything from basic requests to advanced automation and team collaboration.\n\nPrerequisites\n\n\nTo get the most from this guide, you should have:\n\n- Basic understanding of HTTP and REST principles\n- Bruno installed on your system ([download here](\n- Git for version control challenges (optional)\n\nGetting Started\n\n\nThe Bruno Starter Guide is available on GitHub repository with hands-on challenges:\n\nFor the full hands-on experience, import the Bruno Starter Guide collection by either clicking the `Fetch in Bruno` button below, or cloning the Git repository where the collection is stored:\n\n\n  \n    \n  \n\n\nThis repository contains:\n- Structured challenges\n- Sample collections and requests\n- Complete documentation for each challenge\n- **Solution folders** with working examples for each challenge\n\nOnce cloned, open the collection in Bruno to start working through the challenges at your own pace.\n\nChallenge Path\n\n\nProgress through these challenges to build your Bruno expertise step by step:\n\n1. Bruno Basics ðŸš€\n\n\nChallenge Objective\n\nCreate your first API request in Bruno and understand the basic interface elements.\n\nWhat You'll Learn\n\n- Navigating Bruno's interface\n- Creating a new request\n- Setting request methods and URLs\n- Executing your first API call\n\nInstructions\n\n\n1. Right-click on `Basics` folder\n2. Select **New Request**\n3. Name it `echo bruno`\n4. Set method to **POST**\n5. Enter URL: `\n6. Execute the request\n\nSuccess Criteria\n\nâœ… Request is created successfully  \nâœ… Request executes with a 200 status code  \n\nChallenge Complete! ðŸŽ‰\n\nCongrats on creating your first request inside Bruno! You've taken your first step into API development with Bruno's intuitive interface.\n\n**Next Up**: In Challenge 2, you'll learn how to use environment variables to make your requests more flexible and reusable.\n\n2. Environment and Collection Variables ðŸ”„\n\n\nChallenge Objective\n\nSet up and use environment variables to make your API requests more flexible and reusable.\n\nWhat You'll Learn\n\n- Creating environment configurations\n- Setting environment variables\n- Using variables in your requests\n- Switching between environments\n\nInstructions\n\n\nCreating Environments\n\n1. Navigate to the **Environment** section (top right)\n2. Click on **No Environment** and select **Configure**\n3. Click **Create Environment** and name it `echo-bruno`\n4. Under your `echo-bruno` environment, click **Add Variable**\n5. Enter the variable name as `base-url` and set the value to `\n\nUsing Environments\n\n1. Create a `New Request` inside `Environment and Collection` folder\n2. Name it as `echo-bruno-env` and select post method\n3. Use `{{base-url}}` as request URL and ensure that you have selected the `echo-bruno` environment from the environment dropdown\n4. Execute the request\n\nYou will see your request is executed successfully with status code `200`.\n\nSuccess Criteria\n\nâœ… Environment is created successfully  \nâœ… Variable is set up correctly  \nâœ… Request using the variable executes successfully  \nâœ… Response returns status code 200  \n\nChallenge Complete! ðŸŽ‰\n\nGreat job! You've mastered environment variables, a crucial skill for working with different API endpoints across development, staging, and production environments.\n\n**Next Up**: In Challenge 3, you'll learn how to construct API requests with different data formats, a key skill for interacting with modern APIs.\n\n3. API Requests with Data ðŸ“¦\n\n\nChallenge Objective\n\nLearn to construct requests with different HTTP methods and body formats to interact with APIs effectively.\n\nWhat You'll Learn\n\n- Setting different HTTP methods (POST, GET, etc.)\n- Structuring JSON request bodies\n- Understanding request and response formats\n- Interpreting API responses\n\nInstructions\n\n\nStep 1: Create a New Request\n\n1. Click on the **Context Menu** (...) and select **New Request**\n2. Name your request as `Data Request`\n3. Set the **Request URL** to `{{base-url}}` and make sure to select `echo-bruno` as environment\n\nStep 2: Set HTTP Method to POST\n\n1. In your new request, select the **POST** method from the dropdown next to the URL field\n2. POST is used when you need to send data to create or update a resource on the server\n\nStep 3: Add JSON Body Data\n\n1. In the **Body** section, select **JSON** from the dropdown\n2. Add the following JSON data to the body of the request:\n```json\n{\n  \"title\": \"Bruno\",\n  \"role\": \"Chief Joy Officer\"\n}\n```\n\nStep 4: Execute the Request\n\nClick on **Send** (arrow button) to execute the request.\n\nYou will receive the same response you sent through the request.\n\nSuccess Criteria\n\nâœ… Request is configured correctly with JSON body  \nâœ… POST method is selected properly  \nâœ… Request executes successfully  \nâœ… Response contains the same data you sent  \n\nChallenge Complete! ðŸŽ‰\n\nExcellent work! You now understand how to send structured data to APIs, a fundamental skill for creating and updating resources on servers.\n\n**Next Up**: In Challenge 4, you'll explore how to debug API responses and understand what's happening behind the scenes in your requests.\n\n4. Response Handling and Debugging ðŸ”\n\n\nChallenge Objective\n\nMaster Bruno's debugging tools to inspect responses and troubleshoot API requests effectively.\n\nWhat You'll Learn\n\n- How to access and manipulate request objects with scripting\n- Using Bruno's Timeline tab for request debugging\n- Reading and interpreting HTTP response data\n- Troubleshooting common API request issues\n\nInstructions\n\n\n\n  The `req` object is only available in the **Pre-Script** section.\n\n\nStep 1: Use `req` object in Pre-Script\n\n1. Use the same request from Challenge 3\n2. Go to the **Script** tab **Pre Request** section at request level\n3. Add the following code:\n```js\nreq.setBody({\n  \"name\": \"Bruno Starter Guide\",\n  \"task id\": \"04\"\n})\n``` \n4. Click **->** to execute the request\n\nCheck your response data and it should be similar to the data we sent using the `req.setBody()` function. You will get all request-specific details in the `Timeline` tab, including network logs for debugging purposes.\n\nSuccess Criteria\n\nâœ… Your request executes successfully with status code 200  \nâœ… Response body matches what you set in the Pre-Script  \nâœ… You can view network logs in the Timeline tab  \n\n**Next Up**: In Challenge 5, you'll learn how to authenticate your API requests using API keys - a critical skill for working with most modern APIs.\n\n5. Authentication Methods ðŸ”\n\n\nChallenge Objective\n\nLearn how to implement API authentication using API keys to access protected endpoints.\n\nWhat You'll Learn\n\n- Understanding API authentication concepts\n- Obtaining and managing API keys\n- Storing authentication data in environment variables\n- Adding API key authentication to requests\n\nInstructions\n\n\nStep 1: Get Your API Key\n\n1. Go to [\n2. Sign up or log in to your account\n3. From your dashboard, **copy your API Key**\n\nStep 2: Store the API Key as an Environment Variable\n\n1. Go to Bruno Starter Guide collection\n2. Navigate to the **Environment Variables** (top right)\n3. Configure new environment called **NEWS_API**\n4. Click on **Add Variable**\n5. Add:\n   - **Key:** `news-api-key`\n   - **Value:** *(paste your News API key)*\n\nStep 3: Create Request Using the API Key\n\n1. Create a new request named `News Articles`\n2. Set the **Method** to `GET`\n3. Use the following URL:\n```bash  \n\n```\n4. Go to the **Auth** tab of your request\n5. Choose **API Key** from the dropdown\n6. Fill in the following:\n   - **Key:** `apiKey`\n   - **Value:** `{{news-api-key}}`\n7. Set the **Add To** option to: `Query Params`\n\nYou will receive articles and news-related data in the response as JSON. Congrats on adding `API-key` authentication to your request.\n\nSuccess Criteria\n\nâœ… API key is obtained successfully  \nâœ… Environment variable is configured correctly  \nâœ… Authentication is added to the request  \nâœ… Request returns authenticated response with news data  \n\nChallenge Complete! ðŸŽ‰\n\nWell done! You've mastered API key authentication, one of the most common methods for accessing protected API endpoints. This technique is essential for working with most commercial and public APIs.\n\n**Next Up**: In Challenge 6, you'll learn about secret management, a critical skill for handling sensitive information securely.\n\n6. Secret Management ðŸ”’\n\n\nChallenge Objective\n\nLearn how to securely handle sensitive information like API keys and passwords in Bruno.\n\nWhat You'll Learn\n\n- Managing sensitive information securely\n- Using Bruno's secret variables feature\n- Protecting credentials in shared collections\n- Best practices for API security\n\nInstructions\n\n\nStep 1: Mark Environment Variable as Secret\n\n1. Go to environment variables (top-right) and select `echo-bruno`\n2. Add a new variable:\n```json\nKey: my_secret_key\nValue: Bruno\n```\n3. Enable the **Secret** checkbox next to the variable\n\nStep 2: Use the Secret Variable in a Request\n\n1. Create a request named: `env-secret`\n2. Set the method to `POST`\n3. Enter `{{base-url}}` URL placeholder and select `echo-bruno` as environment\n4. Go to the `Body` tab and select `JSON`\n5. Add this JSON:\n```json\n{\n  \"secret\": \"{{my_secret_key}}\"\n}\n```\n6. Run the request\n\nYou will get the value of the secret variable as `Bruno` in the response tab. Verify this value with your output data and make sure both are the same to complete this challenge.\n\nSuccess Criteria\n\nâœ… Secret variable is created with the Secret flag enabled  \nâœ… Request correctly uses the secret variable  \nâœ… Variable value is correctly passed in the request  \nâœ… Response shows the secret value was properly transmitted  \n\nChallenge Complete! ðŸŽ‰\n\nGreat job! You've learned how to handle sensitive information securely in Bruno. This practice is essential for protecting credentials, tokens, and other sensitive data, especially when sharing collections with your team.\n\n**Next Up**: In Challenge 7, you'll explore request scripting to automate and customize your API requests.\n\n7. Request Scripting ðŸ“\n\n\nChallenge Objective\n\nLearn to use Bruno's scripting capabilities to dynamically modify requests and process responses.\n\nWhat You'll Learn\n\n- Writing pre-request scripts to modify requests\n- Using JavaScript to manipulate request properties\n- Capturing and processing response data\n- Automating repetitive API tasks\n\nInstructions\n\n\nStep 1: Create a Request\n\n1. Right-click on `Script` folder and create a request `echo-script`\n2. Select `POST` as method and `{{base-url}}` as request URL\n\nStep 2: Pre-Script - Set Up the Request\n\n1. Go to the request -> Script tab\n2. Paste the following code:\n```javascript\nreq.setBody({\n  \"title\": \"Bruno Starter Guide\",\n  \"id\": \"07\"\n});\n\nreq.setHeaders({\"Content-Type\": \"application/json\"});\n\nreq.setMethod(\"POST\");\n```\n\nStep 3: Post-Script â€” Log the Response\n\n1. Go to the Script tab â†’ Select Post-Script\n2. Paste the following code:\n```js\nconsole.log(res.body);\n```\n\nStep 4: Run and Observe\n\n- Execute the request\n- Open Console (via context menu(...) or press Ctrl + Shift + I)\n\nYou will get the response body object printed on your console with all details including body, header type, and more. Make sure it matches with the configuration you have.\n\nSuccess Criteria\n\nâœ… Pre-script executes and modifies the request  \nâœ… Request is sent with the dynamically set properties  \nâœ… Post-script successfully logs the response  \nâœ… You can view the logged data in the console  \n\nChallenge Complete! ðŸŽ‰\n\nWell done! You've mastered Bruno's powerful scripting capabilities. This skill enables you to automate complex API workflows, transform data, and create dynamic requests based on previous responses.\n\n**Next Up**: In Challenge 8, you'll learn how to create robust API tests with assertions.\n\n8. Test Assertions âœ…\n\n\nChallenge Objective\n\nLearn to create robust API tests with assertions to validate your API responses and ensure quality.\n\nWhat You'll Learn\n\n- Writing test assertions for API responses\n- Using Bruno's assertion UI for quick tests\n- Creating custom test scripts for complex validations\n- Implementing test-driven API development\n\nInstructions\n\n\nStep 1: Create a Request\n\n1. Right-click on `Assert and Testing` folder and create a request called `echo-test`\n2. Select `POST` as method and `{{base-url}}` as request URL\n3. Make sure you have selected `echo-bruno` as environment\n4. Go to the **Body** tab\n5. Select `JSON` and paste the following payload:\n```json\n{\n  \"task id\": 8,\n  \"title\": \"Assert and Testing\",\n  \"you_love_bruno\": true\n}\n```\n\nStep 2: Add an Assertion\n\nBruno lets you create basic assertions without writing code.\n- Go to the Assert tab\n- Add following details:\n\n| Expr        | Operator | Value |\n|-------------|----------|-------|\n| res.status  | equals   | 200   |\n\nStep 3: Add a Test Script\n\n- Go to the `Test` tab\n- Add the following code:\n```js\ntest(\"Check response body contains 'title' property\", function () {\n  expect(res.getBody()).to.have.property(\"title\");\n});\n\ntest(\"You must love Bruno! ðŸ§¡\", function () {\n  expect(res.getBody().you_love_bruno).to.be.true;\n});\n```\n- Save and execute the request.\n\nYou will see all test cases are passed by visiting the `Test` tab. Make sure your test cases are also passing to complete this challenge.\n\nSuccess Criteria\n\nâœ… Request is configured correctly with JSON body  \nâœ… Assertion is properly set up in the Assert tab  \nâœ… Test script is added with two valid test cases  \nâœ… All tests pass when you execute the request  \n\nChallenge Complete! ðŸŽ‰\n\nExcellent work! You've learned how to create tests that validate your API responses. This is a crucial skill for ensuring your APIs behave as expected and for catching regressions early.\n\n**Next Up**: In Challenge 9, you'll learn to use Bruno's Collection Runner to execute multiple requests in sequence.\n\n9. Collection Runner ðŸ”„\n\n\nChallenge Objective\n\nLearn to execute multiple requests in sequence to automate complex API workflows.\n\nWhat You'll Learn\n\n- Running collections of requests in sequence\n- Viewing results from multiple requests\n- Understanding collection execution flow\n- Automating multi-step API processes\n\nInstructions\n\n\nStep 1: Setup the Collection\n\n1. Right-click on `Bruno Starter Guide`\n2. Select `Run` from the dropdown list\n3. Click on `Run Collection`\n\nYou will see all your requests running one by one. You can also check the request response, data, and more by clicking on the request.\n\nSuccess Criteria\n\nâœ… Collection runner starts successfully  \nâœ… Multiple requests execute in sequence  \nâœ… You can view results for each request  \nâœ… All requests complete with expected results  \n\nChallenge Complete! ðŸŽ‰\n\nGreat job! You've learned how to run entire collections at once, which is essential for testing complex API workflows and automating multi-step processes.\n\n**Next Up**: In Challenge 10, you'll learn how to create comprehensive API documentation that helps others understand and use your APIs.\n\n10. API Documentation ðŸ“š\n\n\nChallenge Objective\n\nCreate clear, comprehensive documentation for your APIs that helps users understand and use them effectively.\n\nWhat You'll Learn\n\n- Best practices for API documentation\n- Adding documentation at collection, folder, and request levels\n- Using markdown to format documentation\n- Creating user-friendly API guides\n\nInstructions\n\n\nStep 1: Add Collection-Level Docs\n\n1. Right-click on the `Bruno Starter Guide` collection\n2. Select `Settings` from the dropdown\n3. You will see `Documentations` in right-hand side\n4. Click the âœï¸ pencil icon\n5. Add the following markdown at the bottom \n```md\nBruno Starter Guide Progress:\n\n\n1. Name: \n2. Task: API Documentations\n3. Mood: ðŸ˜Ž \n```\n\nStep 2: Add Folder-Level Docs\n\n1. Right-click on the `API Documentation` folder\n2. Select setting from dropdown\n3. Go to Docs tab and paste this content:\n```md\nðŸ“š Learning API Documentation\n\n\nThis folder-level doc is brought to you by:  \nA determined dev on a mission to document like a pro! ðŸ’ª\n\nâœ… Completed:\n- API Documentation challenge  \n- Added glorious markdown content to both Collection and Folder levels ðŸŽ‰\n\nNow this folder isn't just functional â€” it's fabulous!\n```\n\nStep 3: Add Request-Level Docs\n\n1. Go to `api-docs` request inside `API Documentation` folder\n2. Go to `Docs` tab\n3. Click on `Edit` and paste the following content:\n```md\nRequest-Level API Documentation\n\n\nBelow are some API documentation best practices:\n\n- Clarity: Clearly describe the purpose of the request and how to use it.\n- Examples: Include sample requests and responses to help users test quickly.\n- Consistency: Use consistent structure and formatting across all docs.\n```\nNow you've successfully added API documentation at all levels.\n\nSuccess Criteria\n\nâœ… Collection-level documentation is added  \nâœ… Folder-level documentation is added  \nâœ… Request-level documentation is added  \nâœ… Documentation follows markdown formatting guidelines  \n\nChallenge Complete! ðŸŽ‰\n\nExcellent work! You've learned how to document APIs at different levels, making them easier to understand and use. Good documentation is the key to API adoption and successful collaboration.\n\n**Next Up**: In Challenge 11, you'll learn how to leverage Bruno's Git integration for version control and collaboration.\n\n11. Git Collaboration ðŸ”€\n\n\nChallenge Objective\n\nLearn to use Bruno's Git integration for version control, collaboration, and tracking changes to your API collections.\n\nWhat You'll Learn\n\n- Initializing Git in a Bruno collection\n- Creating commits to track changes\n- Setting up GitHub repositories\n- Sharing collections with teammates\n\nInstructions\n\n\nStep 1: Initialize Git\n\n\nOption A: Using Bruno UI (License Required)\n\n1. Click the Git icon near the Safe Mode toggle\n2. Select \"Initialize Git Repository\"\n3. Bruno initializes a Git repo inside the collection folder\n\nOption B: Using Git CLI (Opensource)\n\n```bash\ncd path/to/your/bruno-collection\ngit init\n```\n\nStep 2: Commit Changes\n\n\nUsing Bruno Git UI\n\n1. Make edits (e.g., add headers, body, etc.)\n2. Open the Git panel via the Git icon -> Git UI\n3. Stage changes with the + icon\n4. Enter a commit message:\n```\nInitial commit of Bruno Git Collaboration collection\n```\n5. Click Commit\n\nUsing CLI\n\n```bash\ngit add .\ngit commit -m \"Initial commit of Bruno Git Collaboration collection\"\n```\n\nStep 3: Create GitHub Repository\n\n1. Go to GitHub and log in\n2. Click New Repository\n3. Name it `bruno-git-collab` (or similar)\n4. Choose visibility: public\n5. Click Create Repository\n6. Copy the HTTPS URL:\n```\n\n```\n\nStep 4: Add Remote and Push\n\n\nUsing Bruno UI \n\n1. In Bruno's Git panel, go to Remotes > Add Remote\n2. Name: `origin`\n3. URL: Paste your `GitHub URL`\n4. Click Push to upload your collection to GitHub\n\nUsing CLI\n\n```bash\ngit remote add origin \ngit branch -M main\ngit push -u origin main\n```\nNow you can share the collection with anyone just like you do for your software projects.\n\nSuccess Criteria\n\nâœ… Git repository is initialized for your collection  \nâœ… Changes are committed successfully  \nâœ… GitHub repository is created and connected  \nâœ… Collection is pushed to GitHub  \n\nChallenge Complete! ðŸŽ‰\n\nGreat job! You've mastered Git integration with Bruno, enabling version control and collaboration on your API collections. This is essential for team environments and maintaining a history of your API development.\n\n**Next Up**: In Challenge 12, you'll learn to work with OpenAPI specifications, an industry standard for API definitions.\n\n12. OpenAPI Integration ðŸ“‹\n\n\nChallenge Objective\n\nLearn to import, export, and work with OpenAPI specifications in Bruno to leverage industry-standard API definitions.\n\nWhat You'll Learn\n\n- Understanding OpenAPI specifications\n- Importing OpenAPI specs into Bruno\n- Exploring generated collections\n- Testing imported API endpoints\n\nInstructions\n\n\nStep 1: Find an OpenAPI Specification\n\nYou can use any OpenAPI spec, but for this challenge, we recommend:\n- The Petstore API: [\n- Or download a sample OpenAPI spec from [GitHub examples](\n\nStep 2: Import the OpenAPI Spec\n\n1. Open Bruno\n2. Click on the context menu (three dots) next to the Bruno logo\n3. Select \"Import\"\n4. Choose \"OpenAPI\"\n5. Browse for your OpenAPI spec file or paste the URL\n6. Follow the import wizard\n7. Choose a location to save the collection\n\nStep 3: Explore the Imported Collection\n\nAfter importing, you'll see:\n1. A new collection created with the API name\n2. Folders organized by resource/tag\n3. Requests for each endpoint with:\n   - Correct paths\n   - Sample parameters\n   - Authentication methods\n   - Request bodies\n\nStep 4: Test an Endpoint\n\n1. Navigate through the imported collection\n2. Select an endpoint (e.g., GET /pets)\n3. Review request details that Bruno has pre-configured\n4. Click Send to test the endpoint\n\nSuccess Criteria\n\nâœ… OpenAPI specification is found and ready for import  \nâœ… Spec is successfully imported into Bruno  \nâœ… Collection structure matches the API definition  \nâœ… You can execute requests from the imported collection  \n\nChallenge Complete! ðŸŽ‰\n\nExcellent work! You've learned to work with OpenAPI specifications in Bruno, bridging the gap between API design and testing. This skill is invaluable for teams that use OpenAPI as part of their API development lifecycle.\n\n**Next Up**: In Challenge 13, the final challenge, you'll learn to use Bruno's CLI for automation and CI/CD integration.\n\n13. CLI Automation ðŸ–¥ï¸\n\n\nChallenge Objective\n\nMaster Bruno's command-line interface to run collections headlessly and integrate with CI/CD pipelines.\n\nWhat You'll Learn\n\n- Installing and using the Bruno CLI\n- Running collections from the command line\n- Automation for CI/CD pipelines\n- Headless API testing workflows\n\nPrerequisites\n\nMake sure you have:\n1. Node.js installed\n2. A Bruno collection ready with at least one request\n\nInstructions\n\n\nStep 1: Install Bruno CLI\n\nOpen your terminal and run:\n```bash\nnpm install -g @usebruno/cli\n```\n\nStep 2: Navigate to Your Bruno Collection\n\nUse cd to go into the root folder of your Bruno collection:\n```bash\ncd path/to/bruno-starter-guide\n```\n\nStep 3: Run Collection with Environment\n\nIn the terminal, run the following:\n```bash\nbru run --env echo-bruno\n```\nThis will run all the requests in your collection using the specified environment.\n\nSuccess Criteria\n\nâœ… Bruno CLI is installed successfully  \nâœ… You navigate to your collection directory  \nâœ… Collection runs successfully via CLI  \nâœ… You can see the results of the execution  \n\nChallenge Complete! ðŸŽ‰\n\nCongratulations on completing the final challenge! You've now mastered Bruno's CLI, enabling you to automate API testing and integrate with CI/CD pipelines. This is a powerful skill for DevOps workflows and automated testing.\n\n**You've completed all 13 challenges!** You now have a comprehensive understanding of Bruno and its capabilities for API development and testing. Keep exploring and building great APIs!\n\nReady to begin your journey? Clone the [Bruno Starter Guide repository]( and start with Challenge 1 to transform the way you work with APIs!\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/starter-guide"
  },
  "advanced-guides/visualize": {
    "name": "visualize",
    "content": "Response Visualization\n\n\nBruno provides a powerful visualization feature that allows you to display API response data in a more readable and interactive format using the `bru.visualize` function.\n\n```javascript\nbru.visualize(type, config)\n```\n\n1. **type**: The type of visualization to render (e.g., 'table', 'html').\n\n2. **config**: A configuration object that includes:\n\n    - **name**: The name of the visualization instance.\n\n    - **provider**: The rendering library or provider used to display the visualization (e.g., 'ag-grid', 'react-table').\n\n    - **props**: Additional properties required by the provider to configure the visualization.\n\nSupported Visualization Types and Providers\n\n\nTable Visualization ('table')\n\n\nYou can render tables using different providers like `ag-grid` and `react-table`.\n\nUsing **ag-grid**\n\n\n*Example:*\n\n![ag-grid](/screenshots/visualization/ag-grid.webp)\n\n\n```javascript\nconst rowData = [\n  { name: 'John Doe', age: 28, email: 'john@example.com', city: 'New York' },\n  { name: 'Jane Smith', age: 32, email: 'jane@example.com', city: 'London' }\n];\n\nconst columnDefinitions = [\n  { field: \"name\", filter: true, floatingFilter: true },\n  { field: \"age\", filter: true, floatingFilter: true },\n  { field: \"email\", filter: true, floatingFilter: true },\n  { field: \"city\", filter: true, floatingFilter: true }\n];\n\nbru.visualize('table', {\n  name: 'table1',\n  provider: 'ag-grid',\n  props: { rowData, columnDefinitions }\n});\n```\n\nThis will render a table using the ag-grid provider with filters enabled on all columns.\n\nUsing **react-table**\n\n\n*Example:*\n\n![react-table](/screenshots/visualization/react-table.webp)\n\n\n```javascript\nconst rowData1 = Array.from({ length: 2500 })\n  .map((_) => [\n    { firstName: 'Tanner', lastName: 'Linsley', age: 24, visits: 100 },\n    { firstName: 'Tandy', lastName: 'Miller', age: 40, visits: 40 },\n    { firstName: 'Joe', lastName: 'Dirte', age: 45, visits: 20 },\n  ]).flat();\n\n\nconst columnDefinitions1 = [\n  {\n    id: \"firstName\",\n    cell: (info) => info.getValue(),\n    header: () => `First Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  {\n    id: \"lastName\",\n    cell: (info) => info.getValue(),\n    header: () => `Last Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  // Additional column definitions here...\n];\n\nbru.visualize('table', {\n  name: 'table2',\n  provider: 'react-table',\n  props: { rowData: rowData1, columnDefinitions: columnDefinitions1 }\n});\n```\n\nThis example renders a large table using the react-table provider, with custom headers and filter variants.\n\nHTML Visualization ('html')\n\n\nYou can also render custom HTML content using the html type. This allows for advanced templating and formatting, such as generating a data table or a report.\n\nUsing **HTML** String\n\n\n*Example:*\n\n![html](/screenshots/visualization/html.webp)\n\n```javascript\nconst htmlString = `\n\n  \n    \n      table { width: 100%; border-collapse: collapse; }\n      th, td { border: 1px solid black; padding: 8px; }\n      th { background-color: #f2f2f2; }\n    \n  \n  \n    \n      NameAgeEmailCity\n      John Doe28john@example.comNew York\n      Jane Smith32jane@example.comLondon\n    \n  \n\n`;\n\nbru.visualize('html', {\n  name: 'htmlReport',\n  content: htmlString\n});\n```\n\nThis example will render an HTML table with predefined data using the html type.\n\nViewing Your Visualization\n\n\n1. Add the visualization code to your request's script section\n2. Execute the request\n3. Click on the **Table** option (next to Raw)\n\n![View Table Option](/screenshots/visualization/1-view-table.webp)\n\n4. Your visualization will be displayed in the panel\n\n![Visualization Output](/screenshots/visualization/2-use-table.webp)\n\nParameters\n\n\n| Name     | Type     | Description                                                                                     |\n|----------|----------|-------------------------------------------------------------------------------------------------|\n| `type`   | `string` | The type of visualization to render. Supported values: `'table'`, `'html'`.                     |\n| `config` | `object` | Configuration object for the visualization. See below for available properties.                 |\n\nConfig Properties\n\n\n| Property   | Type     | Description                                                                                     |\n|------------|----------|-------------------------------------------------------------------------------------------------|\n| `name`     | `string` | Name of the visualization instance.                                                             |\n| `provider` | `string` | The provider or rendering engine to use for the visualization. E.g., `'ag-grid'`, `'react-table'`. |\n| `props`    | `object` | Additional properties required by the provider to configure the visualization.                  |\n| `content`  | `string` | (For `html` type only) The HTML content to render.                                             |\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/visualize"
  },
  "advanced-guides/working-with-bigint": {
    "name": "working-with-bigint",
    "content": "Working with BigInt\n\n\nWhen your response data contains `BigInt`, the parsed value may become corrupted because Bruno parses the response data by default, which can lead to a loss of fidelity.\nThis occurs because `JSON.parse()` does not handle `BigInt` values correctly by default.\n\nHowever, if you need access to the raw response data (for example, if it contains `BigInt`), you can bypass the parsing step.\n\nTo prevent automatic parsing and work directly with the raw response data, add the below expression to the `pre-request` script.\n\n```js\nreq.disableParsingResponseJson();\n```\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/working-with-bigint"
  },
  "api-docs/collection-docs": {
    "name": "collection-docs",
    "content": "Document a Collection\n\n\nBruno allows you to add documentation directly at the collection level, which can be extremely useful for providing a high-level overview of your entire API collection.\n\nBy configuring documentation at the collection level, you ensure that users and developers have a centralized place to understand the key concepts, actions, and flow of your API before diving into individual requests or folders.\n\nCreate Collection Docs\n\n\n1. Go to the **Collection** and click on **More Options**.\n2. Select **Settings** from the dropdown menu.\n\n![collection-settings](/screenshots/send-request/api-docs/collection-settings-docs.webp)\n\n3. Click on the **Edit** icon on the right-hand side.\n\n![collection-preview](/screenshots/send-request/api-docs/collection-preview.webp)\n\n4. Click the **Save** button to view the formatted output.  \n\n![collection-preview](/screenshots/send-request/api-docs/save-collection-docs.webp)\n\n5. Formatted Preview for Collection Documentation.\n\n![collection-preview](/screenshots/send-request/api-docs/formatted-output.webp)",
    "parentName": "api-docs",
    "path": "api-docs/collection-docs"
  },
  "api-docs/folder-docs": {
    "name": "folder-docs",
    "content": "Document a Folder\n\n\nTo add Folder-level documentation in Bruno, you need to first create a folder within your collection. Once the folder is created, you can add specific details for the folder-level API documentation.\n\nCreate Folder Docs\n\n\n1. Go to the collection, click on the **More Options** menu, and select **Create Folder**.\n\n![create-folder](/screenshots/send-request/api-docs/create-folder.webp)\n\n2. Enter a name for the folder and click the **Create button**.\n3. After creating the folder, navigate to the folder settings.\n\n![folder-level-setting](/screenshots/send-request/api-docs/folder-level-settings.webp)\n\n4. Go to the Docs tab.\n5. Click the **Edit** button and add your folder-level API documentation.\n6. Click the **Preview** button to view the formatted output.\n\n![docs-preview-folder-level](/screenshots/send-request/api-docs/docs-preview-folder-level.webp)\n",
    "parentName": "api-docs",
    "path": "api-docs/folder-docs"
  },
  "api-docs/overview": {
    "name": "overview",
    "content": "APIs Documentation\n\n\nBruno allows you to create API documentation at three distinct levels: **Request, Folder, and Collection**.\n\nWith full Markdown support you can write clear, concise, and well-structured documentation at each level supplemented with any relevant screenshots, gifs, or other elements to ensure your users have a seamless onboarding experience.\n\nAlthough Collections are the machine-readable instructions for interacting with an API, offering human-readable instructions to your users can significantly reduce the time to their first interaction.\n\n1. [Document a request](./request-docs.mdx)\n2. [Document a folder](./folder-docs.mdx)\n3. [Document a collection](./collection-docs.mdx)\n",
    "parentName": "api-docs",
    "path": "api-docs/overview"
  },
  "api-docs/request-docs": {
    "name": "request-docs",
    "content": "Document a Request\n\n\nIn Bruno, you can create Request-level documentation to provide specific details about your API and its functions. Bruno offers a **Docs** section where you can easily write and manage your request-level documentation.\n\nCreate Request Docs\n\n\n1. Go to the **Docs** tab within your request.\n2. Click the **Edit** button.\n3. Enter your API details in the provided textarea.\n4. Click the **Preview** button to see the formatted output.\n\n![request-level-edit-docs](/screenshots/send-request/api-docs/request-level-edit-docs.webp)\n\n![request-level-preview-docs](/screenshots/send-request/api-docs/request-level-preview-docs.webp)\n",
    "parentName": "api-docs",
    "path": "api-docs/request-docs"
  },
  "auth/add-and-manage-certs": {
    "name": "add-and-manage-certs",
    "content": "Adding and managing certificates\n\n\nBruno supports adding custom Client Authorization (CA) and client certificates to your requests if required by the API you are working with. \n\nAdding a custom CA certificate\n\n\nNavigate to the `Preferences` menu in Bruno and select `Use Custom CA Certificate`, then upload the selected file. \n\n![Custom CA Certificate](/screenshots/auth/customcacert.webp)\n\nAdding client certificates to Collections\n\n\nYou can add and manage client certificate(s) on any Collection by going to the `Collection Settings` menu and selecting `Client Certificates`. \n\nSimply enter the domain, designate the type of certificate, and then upload the relevant file(s). \n\n![Client Certificate](/screenshots/auth/clientcerts.webp)",
    "parentName": "auth",
    "path": "auth/add-and-manage-certs"
  },
  "auth/aws-signature": {
    "name": "aws-signature",
    "content": "import { Callout } from \"nextra/components\";\n\nAuthenticate using AWS Signature \n\n\nAWS Signature is the authorization workflow for Amazon Web Services requests. AWS uses a custom HTTP scheme based on a keyed-HMAC (Hash Message Authentication Code) for authentication.\n\nThe official AWS Signature documentation provides more detail:\n\n- [Signing and Authenticating Requests](\n\n- [How to call an API]( \n\nTo use AWS Signature, do the following:\n\n1. In the `Auth` tab for a request, select `AWS Sig V4` from  dropdown list.\n\n2. Enter your *AccessKeyID* and *SecretKey* values. \n\n\n  For extra security, integrate Bruno with your secret manager to store these values in a single location. Learn more [here](../secrets-management/hashicorp-vault/overview).\n\n\nThe AWS Signature parameters are as follows:\n\n- Session Token - Required only when using temporary security credentials.\n- Service Name - The service receiving the request.\n- AWS Region - The region receiving the request.\n- Profile Name - name of your AWS signing profile\n\n",
    "parentName": "auth",
    "path": "auth/aws-signature"
  },
  "auth/basic": {
    "name": "basic",
    "content": "Using Basic authentication\n\n\nBasic authentication involves sending a verified username and password with your request. In the request `Auth` tab, select `Basic Auth` from the Auth Type dropdown list.\n\nEnter your API username and password in the Username and Password fields. For extra security, store these in variables.\n\n![Basic](/screenshots/auth/basic.webp)\n\nIn the request Headers, the Authorization header passes the API a Base64 encoded string representing your username and password values, appended to the text `Basic`.",
    "parentName": "auth",
    "path": "auth/basic"
  },
  "auth/bearer": {
    "name": "bearer",
    "content": "Authenticate with a Bearer token\n\n\nBearer tokens enable requests to authenticate using an access key, such as a JSON Web Token (JWT). The token is a text string, included in the request header. \nIn the request `Auth` tab, select `Bearer Token` from the Auth Type dropdown list. In the Token field, enter your API key value. For added security, store it in a variable and reference the variable by name.\n\n![Bearer](/screenshots/auth/bearer.webp)\n\nBruno appends the token value to the text `Bearer` in the required format to the request Authorization header. ",
    "parentName": "auth",
    "path": "auth/bearer"
  },
  "auth/digest": {
    "name": "digest",
    "content": "Authenticate with Digest Access\n\n\nWith Digest auth, the client sends a first request to the API, and the server responds back with details.\nResponse details include a number that can be used only once (a nonce), a realm value, and a 401 Unauthorized response. \nYou then send back an encrypted array of data, including a username and password combined with the data received from the server in the first request. \nThe server uses the passed data to generate an encrypted string and compares it against what you sent to authenticate your request.\n\nIn the Authorization tab for a request, select Digest Auth from the Auth Type dropdown list. \n\n![Digest](/screenshots/auth/digest.webp)\n\n",
    "parentName": "auth",
    "path": "auth/digest"
  },
  "auth/ntlm": {
    "name": "ntlm",
    "content": "Authenticate with NTLM \n\n\nNTLM (NT LAN Manager) is a Microsoft authentication protocol used for Windows-based systems. Its challenge-response authentication mechanism is primarily used for:\n- SharePoint\n- Exchange\n- Internal corporate APIs\n\nUnlike basic authentication, which has a less secure protection layer, NTLM has multiple handshake steps and offers more robust security.\n\nNTLM in Bruno\n\n\nFollow these steps to use NTLM authentication:\n\n1. Open your request\n2. Navigate to the **Auth** tab\n3. Select **NTLM** from the dropdown list\n4. Fill in the required fields:\n   - **Username**: Your Windows username\n   - **Password**: Your Windows password\n   - **Domain**: Your Windows domain name\n\n![ntlm-auth](/screenshots/auth/ntlm-auth.webp)\n",
    "parentName": "auth",
    "path": "auth/ntlm"
  },
  "auth/oauth2/authorization-code": {
    "name": "authorization-code",
    "content": "How to Use OAuth2 for the Authorization Code Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_post_response_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_post_response_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_post_response_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/authorization-code"
  },
  "auth/oauth2/client-credentials": {
    "name": "client-credentials",
    "content": "How to Use OAuth2 for the Client Credentials Grant Type\n\n\nOAuth 2.0 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `OAuth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/client-credentials"
  },
  "auth/oauth2/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\n\nOauth 2.0 authentication in Bruno\n\n\n  \n  This OAuth 2 implementation is **specific to Bruno v1.x.x**. If using Bruno v2.x.x, please see the [documentation for that version](/auth/oauth2-2.0/overview).\n\n\n\nBruno currently supports OAuth2 authentication for the following three grant types:\n\n- [Authorization Code](/auth/oauth2/authorization-code)\n- [Client Credentials](/auth/oauth2/client-credentials)\n- [Password Credentials](/auth/oauth2/password-credentials)\n\n\nBruno does not provide a default callback URL for OAuth2. You will need to configure your own callback URL when setting up OAuth2 authentication.\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/overview"
  },
  "auth/oauth2/password-credentials": {
    "name": "password-credentials",
    "content": "How to Use OAuth2 for the Password Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/password-credentials"
  },
  "auth/oauth2-2.0/authorization-code": {
    "name": "authorization-code",
    "content": "import { Callout } from \"nextra/components\";\n\nHow to Use OAuth2 for the Authorization Code Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 authentication at collection, folder, and request level.\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the following fields:\n\n- **Callback URL**: The URL where you want to receive the authorization code\n- **Authorization URL**: The endpoint for authorization\n- **Access Token URL**: The endpoint to exchange the code for a token\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: The requested scope\n- **State**: An opaque value to maintain state between the request and callback\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\nEnable **Use PKCE** if your OAuth provider supports and requires PKCE (Proof Key for Code Exchange).\n\nUnderstanding Callback URLs (Redirect URIs)\n\n\nThe **Callback URL** (also known as **Redirect URI**) is a critical component of the OAuth2 authorization code flow. Here's what you need to know:\n\nWhat is a Callback URL?\n\n\nThe callback URL is the address where the OAuth2 provider (like Azure, Google, Facebook, etc.) will redirect the browser after successful authentication. This redirect contains a sensitive authorization code that Bruno extracts to complete the authentication process.\n\nHow Bruno Handles Callback URLs\n\n\nBruno does not actually redirect to the callback URL. Instead, it intercepts the redirect attempt and extracts the authorization code from the URL that the OAuth2 provider tried to redirect to.\n\nThis means:\n- **Bruno Support all formats**: It can handle any callback URL format that your OAuth2 provider allows\n- **No actual redirection**: Bruno never actually navigates to the callback URL\n- **Security maintained**: The authorization code is extracted securely without exposing it\n\n\nIf your application is already configured with OAuth2, use one of the existing callback URLs from your OAuth2 provider console. Do not add new URLs unless necessary.\n\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n2. **Token Management Settings**:\n   - **Auto-fetch**: When enabled, Bruno will automatically fetch a new token when you try to access a resource and don't have a valid token.\n   - **Auto-refresh**: When enabled, Bruno will automatically refresh your token using the refresh URL when it expires.\n\n   These settings streamline your workflow by reducing manual token management. Note that token refresh operations require a valid refresh token to be available.\n\n\n  You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n\n\n\nIf you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n\n2. Click **Get Access Token** to obtain and store the token.\n\n\n  You can click the 'Clear Cache' button to remove the stored token and request a new one.\n",
    "parentName": "auth",
    "path": "auth/oauth2-2.0/authorization-code"
  },
  "auth/oauth2-2.0/client-credentials": {
    "name": "client-credentials",
    "content": "import { Callout } from \"nextra/components\";\n\nHow to Use OAuth2 for the Client Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 at either the [collection level](/auth/oauth2-experimental/collection-level-configuration) or [request level](/auth/oauth2-experimental/request-level-configuration).\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the following required fields:\n\n- **Access Token URL**: The endpoint to obtain the access token\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: (Optional) The requested scope\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\n\nWhen using client certificates with OAuth2 client credentials, ensure your domain uses wildcard patterns (e.g., `*.domain.com`) instead of specific subdomains. This ensures proper certificate matching and prevents \"Bad credentials\" errors.\n\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n2. **Token Management Settings**:\n   - **Auto-fetch**: When enabled, Bruno will automatically fetch a new token when you try to access a resource and don't have a valid token.\n   - **Auto-refresh**: When enabled, Bruno will automatically refresh your token using the refresh URL when it expires.\n\n   These settings streamline your workflow by reducing manual token management. Auto-refresh is particularly useful for long-running operations or testing sessions.\n\n\n  You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n\n\n \n  If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n\n2. Click **Get Access Token** to obtain and store the token.\n\n\n  You can click the 'Clear Cache' button to remove the stored token and request a new one.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-2.0/client-credentials"
  },
  "auth/oauth2-2.0/collection-level-configuration": {
    "name": "collection-level-configuration",
    "content": "import { Callout } from \"nextra/components\";\n\nOAuth 2.0 Configuration\n\n\nOverview\n\n\nBruno allows you to configure OAuth2 authentication at multiple levels: collection, folder, and request. This guide explains how to set up and use OAuth2 authentication effectively across your API testing workflow.\n\n\nThe configuration process and all settings are identical across all levels. The only difference is where you access the settings and the scope of the configuration.\n\n\nSetting Up OAuth2\n\n\n1. **Access Settings**\n   - **Collection Level**: Open your collection and navigate to Collection Settings > Auth tab\n   - **Folder Level**: Right-click on the folder and select Folder Settings > Auth tab\n   - **Request Level**: Open your request and navigate to Auth tab\n\n2. **Configure OAuth2**\n   - Choose \"OAuth 2.0\" from the authentication dropdown\n   - Select your preferred grant type\n   - Fill in the required OAuth2 parameters\n\nSupported Grant Types\n\n\nBruno supports three OAuth2 grant types:\n\n- [Authorization Code](/auth/oauth2-experimental/authorization-code)\n- [Client Credentials](/auth/oauth2-experimental/client-credentials)\n- [Password Credentials](/auth/oauth2-experimental/password-credentials)\n\nManaging Access Tokens\n\n\nGenerating Tokens\n\n\n1. Configure OAuth2 parameters as per grant type.\n2. You can choose where to add this token in the request by selecting the \"Add token to\" dropdown:\n   - Headers\n     - Adds the token to the request headers\n     - Configure the header prefix (defaults to \"Bearer\")\n   - URL\n     - Adds the token to the request URL\n     - Configure the query parameter name (defaults to \"access_token\")\n3. Click \"Get Access Token\" to obtain and store the token.\n\nAuto-fetch and Auto-refresh Settings\n\n\nBruno provides two important token management features:\n\n- **Auto-fetch**: When enabled, Bruno will automatically fetch a new token when you try to access a resource and don't have a valid token. This eliminates the need to manually retrieve a token before making API calls.\n\n- **Auto-refresh**: When enabled, Bruno will automatically refresh your token using the refresh URL when it expires. This ensures continuous access to protected resources without manual intervention.\n\nThese settings can be found in the OAuth2 configuration panel and provide significant convenience for API testing workflows.\n\n\n  You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n\n\n\n  If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n\nAuthentication Inheritance\n\n\nOnce you configure OAuth2 at the collection or folder level, you can inherit the authentication at the request level without duplicating the configuration.\n\nHow to Inherit Authentication\n\n\n1. Open your request and navigate to **Auth** tab\n2. Select **Inherit** from the authentication dropdown\n\nBruno will automatically determine the source level:\n- **Inherit from Collection**: Uses the collection-level OAuth2 configuration\n- **Inherit from Folder**: Uses the folder-level OAuth2 configuration (if available)\n\n\nThe token will be automatically added to your request according to the inherited configuration.\n\nInheritance Hierarchy\n\n\nBruno follows a specific hierarchy for authentication inheritance:\n\n1. **Request-level configuration** (highest priority)\n2. **Folder-level configuration** (if no request-level config)\n3. **Collection-level configuration** (if no folder-level config)\n4. **No authentication** (if no configuration at any level)\n\n\nFolder-level OAuth2 configuration overrides collection-level settings for requests within that folder. If no folder-level auth is configured, requests will inherit from the collection level.\n\n\nUsing OAuth2 Tokens\n\n\nMethod 1: Collection/Folder Inheritance\n\n\nWhen a collection or folder has OAuth2 configured, individual requests can inherit the authentication:\n\n- Open request settings\n- Select \"Auth\" tab\n- Choose \"Inherit from collection\" or \"Inherit from folder\"\n- The token will be automatically added to the request according to your configuration (Headers or URL)\n\n\n  \n  Your browser does not support the video tag.\n\n\nMethod 2: Direct Token Reference\n\n\nYou can manually reference OAuth2 tokens in your requests using the variable format `{{$oauth2..access_token}}` in headers or query parameters.\n\nExample\n\n\nAs shown in the video above, the Token ID value will be `{{$oauth2.credentials.access_token}}`\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nYou can click the 'Clear Cache' button to remove the stored token and request a new one at any time.\n\n\nConfiguration Comparison\n\n\n| Feature | Collection Level | Folder Level | Request Level |\n|---------|------------------|--------------|---------------|\n| **Scope** | All requests in collection | Requests in specific folder | Individual request |\n| **Inheritance** | Inherit from collection | Inherit from folder | Override collection/folder |\n| **Configuration** | Collection settings | Folder settings | Request settings |\n| **Use Case** | Collection-wide authentication | Folder-specific authentication | Request-specific authentication |\n\nAdditional Parameters\n\n\nBruno supports adding custom headers, query parameters, and body parameters to OAuth2 requests, providing flexibility similar to Bruno v1.x. This feature allows you to customize OAuth2 requests to meet specific provider requirements.\n\n![random](/screenshots/auth/oauth-additional-params.webp)\n",
    "parentName": "auth",
    "path": "auth/oauth2-2.0/collection-level-configuration"
  },
  "auth/oauth2-2.0/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\nimport BrunoButton from '../../../components/BrunoButton';\n\nOAuth 2.0 Authentication in Bruno\n\n\n  \n  This OAuth 2 implementation is **specific to Bruno v2.x.x**. If using Bruno v.1.x.x, please see the [documentation for that version](/auth/oauth2/overview).\n\n\n\nThis document describes the new OAuth 2 implementation available in `v2.x.x`. This new approach simplifies authentication handling compared to the previous version.\n\nOverview\n\n\nBruno supports OAuth 2 authentication at collection, folder and request levels:\n\n- **Collection Level**: Configure once and share across all requests in the collection\n- **Folder Level**: Configure for a specific folder and share across all requests within that folder\n- **Request Level**: Configure for individual requests, providing maximum flexibility\n\n\nFeatures & Improvements\n\n\n1. **Simplified Configuration**: You no longer need to separately configure authorization and resource requests\n2. **Automatic Token Management**: No scripting is required to set headers for the resource URL\n3. **Automatic Token Injection**: Bruno automatically adds the token to request headers or parameters based on your configuration\n4. **Token Data Access**: Access token data using variables: `{{$oauth2..access_token}}` within the collection\n5. **Auto-fetch and Auto-refresh**: Bruno can automatically fetch new tokens when needed and refresh tokens when they expire, providing a seamless authentication experience\n\nAuto-fetch and Auto-refresh\n\n\nBruno includes two powerful token management features:\n\n- **Auto-fetch**: Automatically fetches a new token when you try to access a protected resource and don't have a valid token\n- **Auto-refresh**: Automatically refreshes your token using the refresh URL when it expires\n\nThese settings can be configured separately for each OAuth2 implementation and help streamline your API testing workflow by reducing manual token management tasks.\n\n\n\nAccessing OAuth2 Tokens in Scripts\n\n\nYou can access OAuth2 tokens in your scripts using the `bru.getOauth2CredentialVar()` function.\n\nSyntax\n\n\n```javascript\nbru.getOauth2CredentialVar('$oauth2..access_token')\n```\nGet Started with OAuth2\n\n\nFeel free to explore our OAuth2 tutorial collection to see practical examples and test different OAuth2 grant types:\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-2.0/overview"
  },
  "auth/oauth2-2.0/password-credentials": {
    "name": "password-credentials",
    "content": "import { Callout } from \"nextra/components\";\n\nHow to Use OAuth2 for the Password Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 at either the [collection level](/auth/oauth2-experimental/collection-level-configuration) or [request level](/auth/oauth2-experimental/request-level-configuration).\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the following required fields:\n\n- **Access Token URL**: The endpoint to obtain the access token\n- **Username**: The resource owner's username\n- **Password**: The resource owner's password\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: (Optional) The requested scope\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n2. **Token Management Settings**:\n   - **Auto-fetch**: When enabled, Bruno will automatically fetch a new token when you try to access a resource and don't have a valid token.\n   - **Auto-refresh**: When enabled, Bruno will automatically refresh your token using the refresh URL when it expires.\n\n   These settings streamline your workflow by reducing manual token management. When using password credentials, auto-fetch is especially useful as it eliminates the need to manually authenticate before each testing session.\n\n\n  You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n\n\n\n  If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n\n2. Click **Get Access Token** to obtain and store the token.\n\n\n  You can click the 'Clear Cache' button to remove the stored token and request a new one.\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-2.0/password-credentials"
  },
  "auth/overview": {
    "name": "overview",
    "content": "import { Callout } from 'nextra/components'\n \nAuthentication in Bruno\n\n\nBruno allows you to send authentication details with your API requests.\nAuthentication methods can be set on the request level or collection level, if you want all of your requests to use the same method.\n\n\n  Some APIs will require a digital certificate to establish a client's identity.\n  You can add your certificate authority (CA) or client certificates to Bruno.\n  See [Add and Manage Certificates](./add-and-manage-certs) for more\n  information.\n\n\nYou can pass auth details along with any request in Bruno in the header, body, or as a parameter.\nIf you enter your auth details to the `Auth` tab of your requests, we will automatically populate the relevant parts of the request for your chosen auth method.\n\nBruno currently supports the following authentication protocols:\n\n\n- [OAuth 2.0](/auth/oauth2/overview)\n- [OAuth 2.0 (Experimental)](/auth/oauth2-experimental/overview)\n- [AWS Sig v4](/auth/aws-signature)\n- [Basic Auth](/auth/basic)\n- [Bearer Auth](/auth/bearer)\n- [Digest Auth](/auth/digest)\n",
    "parentName": "auth",
    "path": "auth/overview"
  },
  "bru-cli/builtInReporters": {
    "name": "builtInReporters",
    "content": "Generating Reports\n\n\nBruno CLI provides built-in support for generating reports in three formats: **JSON**, **JUnit**, and **HTML**. These reports help with analyzing test results and integrating with various CI/CD tools.\n\nYou can generate any combination of these reports and even run them simultaneously.\n\nJSON Report\n\n\nTo generate a report in JSON format, use the `--reporter-json` option:\n\n```bash copy\nbru run --reporter-json results.json\n```\n\nThis will output the test results in a results.json file, which can be useful for further processing or programmatic analysis.\n\nJUnit Report\n\n\nTo generate a report in JUnit format, use the `--reporter-junit` option:\n\n```bash copy\nbru run --reporter-junit results.xml\n```\n\nThe results.xml file will be in a format compatible with JUnit, making it ideal for integration with CI/CD pipelines that rely on JUnit reporting.\n\n\nHTML Report\n\n\nTo generate a human-readable HTML report, use the `--reporter-html` option:\n\n```bash copy\nbru run --reporter-html results.html\n```\n\nThis will create an results.html file that provides a visual representation of the test outcomes, ideal for quick reviews.\n\nRunning Multiple Reporters Simultaneously\n\n\nYou can generate multiple reports at once by specifying more than one reporter option. For example, to generate JSON, JUnit, and HTML reports simultaneously, run:\n\n```bash copy\nbru run --reporter-json results.json --reporter-junit results.xml --reporter-html results.html\n```\n\nThis command will create three files: `results.json, results.xml, and results.html`, allowing you to analyze the results in different formats as needed.\n\nSkipping Specific Headers in the Report\n\n\nIf you want to exclude certain headers from the report, use the `--reporter-skip-headers` option. You can list multiple headers to skip, separated by spaces.\n\n```bash\nbru run --reporter-html results.html --reporter-skip-headers \"Authorization\" \"X-Auth-Token\"\n```\n\nSkip All Headers in the Report\n\n\nTo exclude all headers from the report, use the `--reporter-skip-all-headers` option. This will remove all headers from the output report, ensuring a cleaner result.\n\n```bash copy\nbru run --reporter-html results.html --reporter-skip-all-headers\n```\n\n",
    "parentName": "bru-cli",
    "path": "bru-cli/builtInReporters"
  },
  "bru-cli/commandOptions": {
    "name": "commandOptions",
    "content": "import { Callout } from \"nextra/components\";\n\nCommand Options\n\n\nBruno CLI provides a variety of command options to help you customize your API testing and execution process. These options allow you to specify environments, configure reports, handle security, and much more. Below is a comprehensive list of available options:\n\nOptions \n\n\nTo use options, add them to the bru run command after you specify the collection file or folder:\n\n```bash\nbru run [options]\n```\n\nTo view a list of available options for Bruno CLI, run the following command:\n\n```bash\nbru run -h\n```\n\nBasic options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `-h`, `--help`              | Output usage information                                                      |\n| `--version`                 | Output the version number                                                     |\n\nSetup options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `--env [string]`            | Specify environment to run with                                               |\n| `--env-var [string]`        | Overwrite a single environment variable, multiple usages possible             |\n| `--env-file [string]`       | Path to the environment file (.bru or .json) to use for the collection run            |\n| `--sandbox [string]`        | Javascript sandbox to use; available sandboxes are \"developer\" (default) or \"safe\" [string] [default: \"developer\"] |\n| `--csv-file-path`           | CSV file to run the collection with                                           |\n| `--json-file-path`           | Path to the JSON data file                                                   |             \n| `--iteration-count [number]` | Number of times to run the collection                                        |\n| `-r`                        | Indicates a recursive run [boolean] [default: false]                          |\n\nRequest options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `--delay [number]`          | Delay between each requests (in milliseconds)                                 |\n| `--tests-only`              | Only run requests that have tests or active assertions                        |\n| `--bail`                    | Stop execution after a failure of a request, test, or assertion               |\n| `--tags [string]`   | Only run requests that have ALL of the specified tags (comma-separated)        |\n| `--exclude-tags [string]`   | Skip requests that have ANY of the specified tags (comma-separated)           |\n| `--parallel`                | Run requests in parallel order                            |\n\nSSL & Security options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `--cacert [string]`         | CA certificate to verify peer against                                         |\n| `--ignore-truststore`       | Use custom CA certificate exclusively and ignore default truststore [boolean] [default: false] |\n| `--client-cert-config`      | Path to the Client certificate config file used for securing the connection   |\n| `--insecure`                | Allow insecure server connections                                             |\n| `--disable-cookies`         | Automatically save and send cookies with requests [boolean] [default: false] |\n| `--noproxy`                 | Disable all proxy settings (both collection-defined and system proxies) [boolean] [default: false] |\n\nOutput & Reporting options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `-o`, `--output [string]`   | **[DEPRECATED]** Path to write file results to. Use reporter options instead  |\n| `-f`, `--format [string]`   | **[DEPRECATED]** Format of the file results. Use reporter options instead     |\n| `--reporter-json [string]`  | Path to generate a JSON report                                                |\n| `--reporter-junit [string]` | Path to generate a JUnit report                                               |\n| `--reporter-html [string]`  | Path to generate an HTML report                                               |\n| `--reporter-skip-all-headers` | Skip all headers in the report [boolean] [default: false]                   |\n| `--reporter-skip-headers`   | Skip specific headers in the report [array] [default: []]                     |\n\nImport options\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| `--source [string]`         | Path to the OpenAPI specification file (YAML or JSON)                         |\n| `--output-file [string]`    | Output file to export as Bruno collection in JSON format                      |\n| `--collection-name [string]` | Name for the imported collection from OpenAPI                                 |\n\nExamples\n\n\nThis will run all the requests in your collection.\n\n\n```bash copy\nbru run\n```\n\nYou can also run specific files or folders:\n\n```bash copy\nRun a single file\n\nbru run request.bru\n\nRun multiple files\n\nbru run request1.bru request2.bru\n\nRun a folder\n\nbru run folder\n\nRun multiple folders\n\nbru run folder1 folder2\n\nMix of files and folders\n\nbru run folder1 request1.bru folder2 request2.bru\n```\n\n---\n\nNext Steps\n\n\nNow that you're familiar with the command options, explore these guides to get the most out of Bruno CLI:\n\n1. [Run a Collection](/bru-cli/runCollection) - Learn how to execute your collections with the above command options\n2. [Import Data](/bru-cli/import) - Import OpenAPI and WSDL specifications into Bruno collections\n3. [Generate Reports](/bru-cli/builtInReporters) - Create detailed test reports in multiple formats\n\n---\n\nSupport\n\nIf you encounter any issues or have any feedback or suggestions, please raise them on our [GitHub repository â†—](\n",
    "parentName": "bru-cli",
    "path": "bru-cli/commandOptions"
  },
  "bru-cli/gitHubCLI": {
    "name": "gitHubCLI",
    "content": "import { Callout } from \"nextra/components\";\nimport BrunoButton from '../../components/BrunoButton';\n\nGitHub Actions Integration\n\n\n[GitHub Actions]( is a powerful continuous integration and continuous delivery (CI/CD) platform that enables you to automate your software development workflows directly from your GitHub repository. It provides seamless integration with GitHub's ecosystem, making it an ideal choice for teams looking to automate their API testing workflows.\n\nBruno CLI integrates seamlessly with GitHub Actions to automate API testing workflows.\n\nExplore our GitHub Actions collection to see practical examples and test GitHub Actions CI/CD integration:\n\n\n\n\nPrerequisites\n\n- [Git]( Installed.\n- GitHub repository with Bruno collection.\n\n\nAutomate API Testing with GitHub Actions\n\n\n1. Ensure your Bruno collections are properly organized in your repository:\n\n```\nyour-api-project/\nâ”œâ”€â”€ .github/\nâ”‚   â””â”€â”€ workflows/\nâ”‚       â””â”€â”€ api-tests.yml\nâ”œâ”€â”€ collections/\nâ”‚   â”œâ”€â”€ authentication/\nâ”‚   â”‚   â”œâ”€â”€ login.bru\nâ”‚   â”‚   â””â”€â”€ logout.bru\nâ”œâ”€â”€ environments/\nâ”‚   â”œâ”€â”€ development.bru\nâ”‚   â”œâ”€â”€ ci.bru\nâ”‚   â””â”€â”€ production.bru\nâ””â”€â”€ bruno.json\n```\n\n2. In your repository, create the following directory structure:\n\n```bash\nmkdir -p .github/workflows\n```\n\n3. Create a new file `.github/workflows/api-tests.yml` sample script:\n\n```yaml\nname: API Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n      \n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '20'\n    \n    - name: Install Bruno CLI\n      run: npm install -g @usebruno/cli\n    \n    - name: Run API Tests\n      run: bru run --env ci --reporter-html results.html\n    \n    - name: Upload Test Results\n      uses: actions/upload-artifact@v4\n      with:\n        name: test-results\n        path: results.html\n```\n\n4. **Commit and push** your workflow file:\n```bash\ngit add .github/workflows/api-tests.yml\ngit commit -m \"Add GitHub Actions workflow for API testing\"\ngit push origin main\n```\n\n5. **Monitor the workflow**:\n   - Go to your GitHub repository\n   - Click on the \"Actions\" tab\n   - You should see your workflow running\n\n6. **View results**:\n   - Once completed, download the test results from the artifacts section\n   - Open `results.html` in your browser for detailed reports\n\nLearn More\n\n\nFor more advanced GitHub Actions features and configurations, visit the [GitHub Actions documentation](",
    "parentName": "bru-cli",
    "path": "bru-cli/gitHubCLI"
  },
  "bru-cli/import": {
    "name": "import",
    "content": "import { Callout } from \"nextra/components\";\n\nImport Data\n\n\nBruno CLI allows you to import API specifications directly into Bruno collections from the command line, which can be integrated into CI/CD pipelines whenever API changes are committed.\n\nImporting OpenAPI Specifications\n\n\nOption 1: Import to Bruno Collection\n\n\nThis will import the OpenAPI specification (supports both YAML and JSON formats) and generate a Bruno collection in the specified output directory.\n\n```bash copy\nbru import openapi \\\n  --source  \\\n  --output  \\\n  --collection-name \"Petstore API\"\n```\n\nWhere:\n- ``: Path to your OpenAPI specification file (can be either YAML or JSON format)\n- ``: Directory where you want to save the collection\n- `--collection-name`: Custom name for the collection\n\nOption 2: Import to Single JSON File\n\n\nThis will import the OpenAPI specification and generate a Bruno collection as a single JSON file at the specified location.\n\n```bash copy\nbru import openapi \\\n  --source  \\\n  --output-file .json \\\n  --collection-name \"Petstore API\"\n```\n\nWhere:\n- ``: Path to your OpenAPI specification file (can be either YAML or JSON format)\n- ``: Base path and filename for your JSON output\n- `--collection-name`: Custom name for the collection\n\n---\n\nImporting WSDL (SOAP APIs)\n\n\nThis will import the WSDL file and generate a Bruno collection with SOAP requests in the specified output directory.\n\n```bash copy\nbru import wsdl  --output \n```\n\nWhere:\n- ``: Path to your WSDL file\n- ``: Directory where you want to save the collection\n\n\n",
    "parentName": "bru-cli",
    "path": "bru-cli/import"
  },
  "bru-cli/installation": {
    "name": "installation",
    "content": "import { Callout } from 'nextra/components'\nimport { Tabs } from 'nextra/components'\n\nInstallation\n\n\n\n  Make sure you have Node.js installed on your local system. It is recommended to use the latest LTS version (Node 18 or higher). \n\n\nTo install the Bruno CLI, use the node package manager of your choice:\n\n\n  \n  ### Using pnpm\n\n    ```bash\npnpm install -g @usebruno/cli\n```\n  \n  \n    \n    ### Using npm\n```bash\nnpm install -g @usebruno/cli\n```\n\n  \n  \n    \n    ### Using yarn\n```bash\nyarn global add @usebruno/cli\n```\n  \n\nFor more details, visit the official [NPM Page for Bruno CLI â†—](",
    "parentName": "bru-cli",
    "path": "bru-cli/installation"
  },
  "bru-cli/jenkins": {
    "name": "jenkins",
    "content": "import { Callout } from \"nextra/components\";\nimport BrunoButton from '../../components/BrunoButton';\n\nJenkins CI Integration\n\n\n[Jenkins]( is a powerful open-source automation server that enables continuous integration and continuous delivery (CI/CD) for software development workflows. It provides a robust platform for automating build, test, and deployment processes across multiple environments and platforms.\n\nExplore our Jenkins setup collection to see practical examples and test Jenkins CI/CD integration:\n\n\n\nPrerequisites\n\n\n*   A running Jenkins instance (local or remote).\n*   The [NodeJS Plugin]( installed in your Jenkins environment.\n*   A Git repository containing your Bruno collections and a `Jenkinsfile`.\n\nAutomate API Testing with Jenkins\n\n\n\nStep 1: Organize Your Bruno Collections\n\n\nEnsure your Bruno collections and environment files are properly organized within your Git repository. A typical structure looks like this:\n\n```\nyour-api-project/\nâ”œâ”€â”€ Jenkinsfile\nâ”œâ”€â”€ collections/\nâ”‚   â”œâ”€â”€ authentication/\nâ”‚   â”‚   â”œâ”€â”€ login.bru\nâ”‚   â”‚   â””â”€â”€ logout.bru\nâ”œâ”€â”€ environments/\nâ”‚   â”œâ”€â”€ development.bru\nâ”‚   â”œâ”€â”€ ci.bru\nâ”‚   â””â”€â”€ production.bru\nâ””â”€â”€ bruno.json\n```\n\nStep 2: Configure Node.js in Jenkins\n\n\nBefore running Bruno CLI, you need to ensure Jenkins can access a Node.js runtime environment.\n\n1.  **Install the NodeJS Plugin:**\n    *   Navigate to `Manage Jenkins` > `Plugins`.\n    *   Select the `Available plugins` tab, search for \"NodeJS\", and install it.\n\n2.  **Configure a Node.js Installation:**\n    *   Go to `Manage Jenkins` > `Tools` (under `System Configuration`).\n    *   Scroll down to the `NodeJS installations` section.\n    *   Click `Add NodeJS`.\n    *   Provide a descriptive **Name** (e.g., `Node.js 18`). This exact name will be used in your Jenkinsfile.\n    *   Check `Install automatically` and select your desired `Node.js version` (e.g., `NodeJS 18.20.8`).\n    *   **Crucially, ensure the checkbox \"Provide Node & npm folder to PATH\" is checked.** This ensures `node` and `npm` commands are available to your pipeline.\n    *   Click `Save`.\n\nStep 3: Create Your Jenkinsfile\n\n\nCreate a file named `Jenkinsfile` in the root of your Git repository. This file defines the steps of your CI pipeline.\n\n```groovy\n// Sample Jenkinsfile\npipeline {\n    agent any\n    environment {\n        // Capture the path to Node.js 18. This variable will be available globally.\n        // This requires the Node.js tool to be configured in Jenkins.\n        NODE_HOME = tool 'Node.js 18'\n    }\n    stages {\n        stage('Checkout Code') {\n            steps {\n                checkout scm\n            }\n        }\n        stage('Setup Node.js & Install Bruno CLI') {\n            steps {\n                // Ensure the bin directory is added to PATH for all subsequent sh commands\n                withEnv([\"PATH+NODE=${NODE_HOME}/bin\"]) {\n                    echo 'Verifying Node.js and npm versions...'\n                    sh 'node -v'\n                    sh 'npm -v'\n                    echo 'Installing Bruno CLI globally...'\n                    sh 'npm install -g @usebruno/cli'\n                    sh 'bru --version'\n                }\n            }\n        }\n        stage('Run API Tests') {\n            steps {\n                withEnv([\"PATH+NODE=${NODE_HOME}/bin\"]) { // Still need this or declare it inside script block\n                    echo 'Executing Bruno API tests...'\n                    sh 'bru run --env ci --reporter-html results.html'\n                }\n            }\n        }\n        stage('Archive Test Results') {\n            steps {\n                echo 'Archiving test report...'\n                archiveArtifacts artifacts: 'results.html', fingerprint: true\n            }\n        }\n    }\n    post {\n        always {\n            echo 'Pipeline finished.'\n        }\n        success {\n            echo 'API Tests Passed Successfully!'\n        }\n        failure {\n            echo 'API Tests Failed! Check console output for details.'\n        }\n    }\n}\n            \n```\n\nStep 4: Configure Jenkins Pipeline Job\n\n\n1. Create a New Jenkins Job:\n\n\t- From the Jenkins Dashboard, click New Item.\n\t- Enter an Item name (e.g., bruno-api-tests-pipeline).\n\t- Select Pipeline as the item type and click OK.\n\n2. Configure Job Details:\n\n\t- In the job configuration page, navigate to the Pipeline section.\n\t- Set Definition to Pipeline script from SCM and Choose your SCM (e.g., Git).\n\t- Enter your Repository URL (e.g., `\n\t- Specify any Credentials if your repository is private.\n\t- Set Branches to build to ***/main** (or the branch containing your Jenkinsfile).\n\t- Ensure Script Path is Jenkinsfile (this is the default).\n\n3. Click Save to finalize your job configuration.\n\nStep 5: Run and Monitor Your Pipeline\n\n\n1. Trigger a Build:\n\n\t- From your Jenkins pipeline job page, click Build Now (in the left-hand menu) to manually start the pipeline.\n\n2. Monitor Progress:\n\n\t- Observe the Build History section to see the status of your builds (green checkmark for success, red cross mark for failure).\n\t- Click on a specific build number, then select Console Output to view real-time logs and detailed execution steps.\n\n3. View Test Results:\n\n\t- Once a build that generated results.html completes, navigate to that specific build's page.\n\t- Look for the **Artifacts** section (usually on the left sidebar or at the top of the build summary).\n\t- Click on `results.html` to download the report, then open it in your web browser for detailed test outcomes.\n\nLearn More\n\n\nFor more advanced Jenkins features and configurations, visit the [Jenkins documentation]( \n",
    "parentName": "bru-cli",
    "path": "bru-cli/jenkins"
  },
  "bru-cli/overview": {
    "name": "overview",
    "content": "Bruno CLI\n\n\nWith Bruno CLI, you can run your API collections with ease using simple command line commands.\n\nThis makes it easier to test your APIs in different environments, automate your testing process, and integrate your API tests with your continuous integration and deployment workflows.\n\n\nKey Features of Bruno CLI:\n\n\n**1. Execute API Requests & Collections**: Run individual API requests or entire collections directly from the command line.\n\n**2. Generate Test Reports** : Easily create reports in multiple formats, including JSON, JUnit, and HTML, to analyze and share test results.\n\n**3. CI/CD Integration**: Effortlessly integrate with CI/CD pipelines for automated testing and validation.",
    "parentName": "bru-cli",
    "path": "bru-cli/overview"
  },
  "bru-cli/proxyConfiguration": {
    "name": "proxyConfiguration",
    "content": "Proxy and mTLS\n\n\nProxy Configuration\n\n\nBruno CLI allows you to configure proxy settings directly from the terminal. You can also add client certificates through the CLI.\n\nFollow the steps below to set up configurations quickly and efficiently.\n\nDisabling Proxies\n\n\nIf you need to bypass all proxy settings (both collection-defined and system proxies) when running requests, you can use the `--noproxy` flag:\n\n```bash copy\nbru run --noproxy\n```\nThe flag completely disables all proxy settings for that particular CLI run.\n\nUsing Client Certificates for API Requests\n\n\nIf your API requests require client certificates for authentication, you can specify using the `--client-cert-config` option. The configuration should be provided in a JSON file. Here's an example of how to use this option:\n\n```bash copy\nbru run  --client-cert-config /path/to/client-cert-config.json\n```\n\nThe client-cert-config.json file should contain the following fields:\n\n```json\n{\n  \"enabled\": true,\n  \"certs\": [\n    {\n      \"domain\": \"usebruno.com\",\n      \"type\": \"cert\",\n      \"certFilePath\": \"certs/server_1.crt\",\n      \"keyFilePath\": \"private/server_1.key\",\n      \"passphrase\": \"Iu$eBrun0_#Secure!\"\n    },\n    {\n      \"domain\": \"the-example.com\",\n      \"type\": \"pfx\",\n      \"pfxFilePath\": \"pfx/server_3.pfx\",\n      \"passphrase\": \"L!ghT_Y@g@mi_2024!\"\n    }\n  ]\n}\n```",
    "parentName": "bru-cli",
    "path": "bru-cli/proxyConfiguration"
  },
  "bru-cli/runCollection": {
    "name": "runCollection",
    "content": "import { Callout } from \"nextra/components\";\n\nRunning a Collection \n\n\nBruno CLI allows you to run your API collections with ease, either by directly executing requests or using external data sources.\n\nThis guide explains how to run entire collections, specific folders, and how to use data sources like CSV and JSON files to drive your API tests.\n\nBasic Collection Execution\n\n\nTo run an entire collection, navigate to your collection directory and use the `run` command:\n\n```bash copy\nbru run\n```\n\nRunning a Folder within a Collection\n\n\nYou can run all the requests within a specific folder by specifying the folder name:\n\n```bash copy\nbru run \n```\n\nFor example, to run all requests in the **users** folder:\n\n```bash copy\nbru run users\n```\n\nRunning a Collection with a CSV File\n\n\n\n  This feature requires [Bruno CLI â†—]( version 1.35.0 or higher.\n\n\nIf you need to run a collection using data from a CSV file, specify the path to the file with the `--csv-file-path` option:\n\n```bash copy\nbru run --csv-file-path /path/to/csv/file.csv\n```\n\nThis will execute the collection once for each row in the CSV file, with each row's data available as variables in your requests.\n\nRunning a Collection with a JSON File\n\n\nTo run a collection using data from a JSON file, provide the file path using the `--json-file-path` option:\n\n```bash copy\nbru run --json-file-path /path/to/json/file.json\n```\nRunning a Collection Multiple Times\n\n\nYou can run a collection multiple times in a single command using the `--iteration-count` flag:\n\n```bash copy\nbru run --iteration-count=2\n```\n\nThis will execute the collection twice. This is useful for load testing or when you need to repeat the same set of requests multiple times.\n\nRunning a Collection with Environments\n\n\nYou can run a collection using environment variables from either a `.bru` file or a `.json` file. This allows you to attach environments via the CLI from anywhere in the filesystem.\n\nUsing Environment Files\n\n\nTo run a collection with an environment file, use the `--env-file` option:\n\n```bash copy\nbru run --env-file /path/to/environment.bru\n```\n\nYou can specify either a relative or absolute path to the environment file:\n\n```bash copy\nUsing relative path\n\nbru run --env-file ./environments/local.bru\n\nUsing absolute path\n\nbru run --env-file /Users/username/projects/api-testing/environments/prod.bru\n```\n\n\n  The environment file should be in Bruno's `.bru` format. Make sure the file contains valid environment variables and their values.\n\n\nUsing JSON Environment Files\n\n\n\n  This feature requires [Bruno CLI â†—]( version 2.13.0 or higher.\n\n\nBruno CLI now supports JSON environment files, which is particularly useful for global environments created in the Bruno app. This bridges the gap between UI-only global environments and CLI-based workflows.\n\nTo use a JSON environment file:\n\n```bash copy\nbru run --env-file /path/to/environment.json\n```\n\nJSON Environment File Format\n\n\nThe JSON environment file should follow Bruno's environment schema:\n\n```json copy\n{\n  \"name\": \"My Environment\",\n  \"variables\": [\n    { \n      \"name\": \"host\", \n      \"value\": \" \n      \"enabled\": true \n    },\n    { \n      \"name\": \"api_key\", \n      \"value\": \"your-api-key-here\", \n      \"enabled\": true \n    }\n  ]\n}\n```\n\nUsing Environments Names\n\n\nIf you need to use a specific environment, you can pass it with the `--env` option:\n\n```bash copy\nbru run --env Local\n```\n\nPassing Environment Variables\n\n\n\nVariables marked as secrets in Bruno app are not accessible via the CLI. Pass them directly as command-line arguments.\n\n\n```bash copy\nbru run --env Local --env-var JWT_TOKEN=1234\n```\n\nMultiple Environment Variables\n\n\nYou can override multiple environment variables by using additional `--env-var` flags:\n\n```bash copy\nbru run --env Local --env-var JWT_TOKEN=1234 --env-var API_KEY=abcd1234 \n```\n\nEach `--env-var` flag adds or overrides a single environment variable, and you can chain as many as needed.\n\nFiltering Requests with Tags\n\n\nBruno CLI supports filtering requests by tags, allowing you to run only specific subsets of your collection based on tag criteria.\n\n\n  This feature requires [Bruno CLI â†—]( version 2.8.0 or higher.\n\n\nInclude Tags\n\n\nRun only requests that have at least one matching tag.\n\n```bash copy\nbru run --tags=smoke,sanity\n```\n\nExclude Tags\n\n\nSkip requests that have ANY of the specified tags:\n\n```bash copy\nbru run --exclude-tags=skip,draft\n```\n\nCombined Filtering\n\n\nYou can combine include and exclude filters:\n\n```bash copy\nbru run --tags=smoke,sanity --exclude-tags=skip,draft\n```\n\nParallel Execution and Progress Tracking\n\n\nBruno CLI supports running requests in parallel and displaying real-time progress during collection execution.\n\nParallel Execution\n\n\nBy default, Bruno CLI runs requests sequentially. You can enable parallel execution using the `--parallel` flag:\n\n```bash copy\nbru run --iteration-count 2 --parallel\n```\n\n\n",
    "parentName": "bru-cli",
    "path": "bru-cli/runCollection"
  },
  "bru-lang/language": {
    "name": "language",
    "content": "Language Design\n\n\nA Bru file is made up of blocks.\nThere are three kinds of blocks\n- Dictionary block\n- Text block\n- Array block\n\nDictionary block\n\nA dictionary block contains a set of key value pairs. \n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer 123\n  ~transaction-id: {{transactionId}}\n}\n```\nAny key in the dictionary block can be prefixed with `~` to indicate that it is disabled.\n\nText block\n\nA text block is a set of lines\n```bash\nbody {\n  {\n    \"hello\": \"world\"\n  }\n}\n\ntests {\n  expect(res.status).to.equal(200);\n}\n```\n\nArray block\n\nAn array block is a list of strings\n```bash\nvars:secret [\n  access_key,\n  access_secret,\n  ~transactionId\n]\n```\nAny key in the array block can be prefixed with `~` to indicate that it is disabled.\n\n\n\n\n\n",
    "parentName": "bru-lang",
    "path": "bru-lang/language"
  },
  "bru-lang/overview": {
    "name": "overview",
    "content": "Bru Markup Language\n\n\nBru is a simple markup language that utilizes plain text files to document and organize information for your API requests.\n\nThe API requests in your collections are stored as plain text files using this language.\n\nThis allows you to save your API collections in a folder within your code repository, and use your preferred version control system to manage and share them with your team. Collaboration on your API collections can be done through pull requests, as the human-readable file format makes it easy for developers to understand the changes made to the API collection.\n\nBelow is a sample of a Bru file for a `GET` request with some query params\n\n![bru lang sample](/screenshots/github-collection.webp)\n\nYou can checkout the sample repository which contains GitHub rest API collection [here](\n\nIf you are wondering why we designed a DSL instead of just using JSON/YAML, you can checkout this [github discussion](\n",
    "parentName": "bru-lang",
    "path": "bru-lang/overview"
  },
  "bru-lang/samples": {
    "name": "samples",
    "content": "Samples\n\n\nHere are a few sample Bru files.\n\nGET\n\n```bash\nget {\n  url: \n}\n```\n\nGET with headers\n\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nPOST with body\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"apiKey\": \"secret\",\n    \"numbers\": \"9988776655\",\n    \"message\": \"Woof! lets play with some apis\"\n  }\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nScripting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\n\nTesting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\ntests {\n  test(\"should be able to login\", function() {\n    expect(res.status).to.equal(201);\n  });\n\n  test(\"should receive the token\", function() {\n    expect(res.body.token).to.be.a('string');\n  });\n}\n```",
    "parentName": "bru-lang",
    "path": "bru-lang/samples"
  },
  "bru-lang/syntax-highlighting": {
    "name": "syntax-highlighting",
    "content": "Syntax Highlighting Support\n\n\nBruno has an editor extension released for VS Code that enables syntax highlighting for `.bru` files. You can download it from the [Visual Studio Marketplace](",
    "parentName": "bru-lang",
    "path": "bru-lang/syntax-highlighting"
  },
  "bru-lang/tag-reference": {
    "name": "tag-reference",
    "content": "Bru Tag Reference\n\n\nmeta\n\nStore metadata about your request\n```bash\nmeta {\n  name: Get users\n  type: http\n  seq: 1\n  tags: [\n    smoke\n    sanity\n  ]\n}\n```\n\nThe `seq` is used to store the sequence number. This decides the sort position of your request in the UI.\nThe `type` can be either `http` or `graphql`\nThe `tags` is an array of strings that can be used to filter requests during collection runs. Tags are useful for organizing and selectively running requests based on categories like environment, functionality, or priority.\n\nget\n\n\nMake a `GET` http call\n```bash\nget {\n  url: \n}\n```\npost\n\n\nMake a `POST` http call\n```bash\npost {\n  url: \n}\n```\nput\n\n\nMake a `PUT` http call\n```bash\nput {\n  url: \n}\n```\ndelete\n\n\nMake a `DELETE` http call\n```bash\ndelete {\n  url: \n}\n```\noptions\n\n\nMake a get `OPTIONS` call\n```bash\noptions {\n  url: \n}\n```\ntrace\n\n\nMake a `TRACE` http call\n```bash\ntrace {\n  url: \n}\n```\nconnect\n\n\nMake a `CONNECT` http call\n```bash\nconnect {\n  url: \n}\n```\nhead\n\n\nMake a `HEAD` http call\n```bash\nhead {\n  url: \n}\n```\nquery\n\n\nThe request query params\n```bash\nget {\n  url: \n}\n\nparams:query {\n  apiKey: secret\n  numbers: 9988776655\n  message: hello\n}\n```\npath\n\n\nThe request path params\n```bash\nget {\n  url: \n}\n\nparams:path {\n  userId: 13\n}\n```\nheaders\n\n\nThe request query headers\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nbody\n\nThe request body (defaults to json)\n```bash\nbody {\n  {\n    username: 'john',\n    password: 'governingdynamics'\n  }\n}\n```\nbody:text\n\nThe request body as text\n```bash\nbody:text {\n  This is a text body\n}\n```\nbody:xml\n\nThe request body as xml\n```bash\nbody:xml {\n  \n    John\n    30\n  \n}\n```\nbody:form-urlencoded\n\nThe request body as form-urlencoded\n```bash\nbody:form-urlencoded {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:multipart-form\n\nThe request body as multipart-form\n```bash\nbody:multipart-form {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:graphql\n\nThe request body as graphql\n```bash\nbody:graphql {\n  {\n    launchesPast {\n      launch_site {\n        site_name\n      }\n      launch_success\n    }\n  }\n}\n```\nbody:graphql:vars\n\nThe request body as graphql vars\n```bash\nbody:graphql:vars {\n  {\n    \"limit\": 5\n  }\n}\n```\nscript:pre-request\n\nThe request body as pre-request\n```bash\nscript:pre-request {\n  req.setHeader(\"Authorization\", \"{{token}}\");\n}\n```\nscript:post-response\n\nThe request body as post-response\n```bash\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\ntest\n\nThe tests\n```bash\nbody:test {\n  expect(res.status).to.equal(200);\n}\n```\n",
    "parentName": "bru-lang",
    "path": "bru-lang/tag-reference"
  },
  "converters/insomnia-to-bruno": {
    "name": "insomnia-to-bruno",
    "content": "import { Callout } from 'nextra/components'\nimport { Tabs } from 'nextra/components'\n\nConvert Insomnia collection to Bruno collection\n\n\n```javascript\nconst { insomniaToBruno } = require('@usebruno/converters');\n\nconst brunoCollection = insomniaToBruno(insomniaCollection);\n```\n\n```javascript showLineNumbers filename=\"insomnia-to-bruno.js\"\nconst { insomniaToBruno } = require('@usebruno/converters');\nconst { readFile, writeFile } = require('fs/promises');\n\nasync function convertInsomniaToBruno(inputFile, outputFile) {\n  try {\n    const inputData = await readFile(inputFile, 'utf8');\n    const brunoCollection = insomniaToBruno(JSON.parse(inputData));\n    await writeFile(outputFile, JSON.stringify(brunoCollection, null, 2));\n    console.log('Insomnia conversion successful!');\n  } catch (error) {\n    console.error('Error during Insomnia conversion:', error);\n  }\n}\n\n\nconvertInsomniaToBruno('path/to/insomnia-collection.json', 'path/to/bruno-collection.json');\n```",
    "parentName": "converters",
    "path": "converters/insomnia-to-bruno"
  },
  "converters/openapi-to-bruno": {
    "name": "openapi-to-bruno",
    "content": "import { Tabs } from 'nextra/components'\n\nConvert OpenAPI to Bruno collection\n\n\n\n  \n  ### Convert OpenAPI JSON to Bruno collection\n\n  ```javascript\n  const { openApiToBruno } = require('@usebruno/converters');\n  \n  const brunoCollection = openApiToBruno(openApiSpecification);\n  ```\n\n  ```javascript showLineNumbers filename=\"openapi-json-to-bruno.js\"\n  const { openApiToBruno } = require('@usebruno/converters');\n  const { readFile, writeFile } = require('fs/promises');\n\n  async function convertOpenApiToBruno(inputFile, outputFile) {\n    try {\n      \n      const jsonContent = await readFile(inputFile, 'utf8');\n      \n      const openApiSpec = JSON.parse(jsonContent);\n      \n      const brunoCollection = openApiToBruno(openApiSpec);\n      \n      await writeFile(outputFile, JSON.stringify(brunoCollection, null, 2));\n      console.log('OpenAPI JSON conversion successful!');\n    } catch (error) {\n      console.error('Error during OpenAPI JSON conversion:', error);\n    }\n  }\n\n  \n  convertOpenApiToBruno('path/to/openapi-spec.json', 'path/to/bruno-collection.json');\n  ```\n  \n  \n  ### Convert OpenAPI YAML to Bruno collection\n\n  ```javascript\n  const { openApiToBruno, yamlToJson } = require('@usebruno/converters');\n  const { readFile, writeFile } = require('fs/promises');\n\n\nasync function testOpenApiConversion(yamlFile, outputFile) {\n  const yamlContent = await readFile(yamlFile, 'utf8');\n  const jsonSpec = yamlToJson(yamlContent);\n  if (jsonSpec) {\n    try {\n      const brunoCollection = openApiToBruno(jsonSpec);\n      await writeFile(outputFile, JSON.stringify(brunoCollection, null, 2));\n      console.log('Full conversion pipeline successful!');\n    } catch (error) {\n      console.error('Bruno conversion error:', error.message);\n    }\n  }\n}\n\ntestOpenApiConversion('path/to/your/openapi.yaml', 'path/to/bruno-collection.json');\n```\n  \n\n",
    "parentName": "converters",
    "path": "converters/openapi-to-bruno"
  },
  "converters/overview": {
    "name": "overview",
    "content": "import { Callout } from 'nextra/components'\nimport { Tabs } from 'nextra/components'\n\nBruno Converters\n\n\nBruno converter is a standalone NPM package that provides programmatic conversion of various API specification formats to Bruno collections. This package allows you to convert Postman collections, Insomnia collections, OpenAPI specifications, WSDL files, and Postman environments into Bruno collection format.\n\nInstallation\n\n\n \n  Make sure you have Node.js (Node 18 or higher) installed on your local system. It is recommended to use the latest LTS version. \n\n\nTo install the Bruno Converters, use the node package manager of your choice:\n\n\n  \n  ### Using pnpm\n\n    ```bash\npnpm install @usebruno/converters\n```\n  \n  \n    \n    ### Using npm\n```bash\nnpm install @usebruno/converters\n```\n\n  \n  \n    \n    ### Using yarn\n```bash\nyarn add @usebruno/converters\n```\n  \n\n\nFor more details, visit the official [NPM Page for Bruno Converters](\n\nConversions\n\n\n1. [Postman to Bruno](./postman-to-bruno)\n2. [Insomnia to Bruno](./insomnia-to-bruno)\n3. [OpenAPI to Bruno](./openapi-to-bruno)\n4. [WSDL to Bruno](./wsdl-to-bruno)\n\nAPI Reference\n\n\n`postmanToBruno(postmanCollection: object)`\n\n\nConverts a Postman collection to a Bruno collection.\n\n**Parameters:**\n- `postmanCollection`: The Postman collection JSON object\n\n`postmanToBrunoEnvironment(postmanEnvironment: object)`\n\n\nConverts a Postman environment to a Bruno environment.\n\n**Parameters:**\n- `postmanEnvironment`: The Postman environment JSON object\n\n`insomniaToBruno(insomniaCollection: object)`\n\n\nConverts an Insomnia collection to a Bruno collection.\n\n**Parameters:**\n- `insomniaCollection`: The Insomnia collection JSON object\n\n`openApiToBruno(openApiSpec: object)`\n\n\nConverts an OpenAPI specification to a Bruno collection.\n\n**Parameters:**\n- `openApiSpec`: The OpenAPI specification JSON object\n\n`wsdlToBruno(wsdlContent: string)`\n\n\nConverts a WSDL file to a Bruno collection with SOAP requests.\n\n**Parameters:**\n- `wsdlContent`: The WSDL file content as a string",
    "parentName": "converters",
    "path": "converters/overview"
  },
  "converters/postman-to-bruno": {
    "name": "postman-to-bruno",
    "content": "import { Callout } from 'nextra/components'\nimport { Tabs } from 'nextra/components'\n\nPostman Conversions\n\n\n\n  \n  ### Convert Postman collection to Bruno collection\n\n  ```javascript\n  const { postmanToBruno } = require('@usebruno/converters');\n\n  const brunoCollection = postmanToBruno(postmanCollection);\n  ```\n\n  ```javascript showLineNumbers filename=\"postman-to-bruno.js\"\n  const { postmanToBruno } = require('@usebruno/converters');\n  const { readFile, writeFile } = require('fs/promises');\n\n  async function convertPostmanToBruno(inputFile, outputFile) {\n    try {\n      const inputData = await readFile(inputFile, 'utf8');\n      const brunoCollection = postmanToBruno(JSON.parse(inputData));\n      await writeFile(outputFile, JSON.stringify(brunoCollection, null, 2));\n      console.log('Conversion successful!');\n    } catch (error) {\n      console.error('Error during conversion:', error);\n    }\n  }\n\n  // Usage example\n  convertPostmanToBruno('path/to/postman-collection.json', 'path/to/bruno-collection.json');\n  ```\n  \n  \n  ### Convert Postman Environment to Bruno Environment\n\n  ```javascript\n  const { postmanToBrunoEnvironment } = require('@usebruno/converters');\n\n  const brunoEnvironment = postmanToBrunoEnvironment(postmanEnvironment);\n  ```\n\n  ```javascript showLineNumbers filename=\"postman-env-to-bruno.js\"\n  const { postmanToBrunoEnvironment } = require('@usebruno/converters');\n  const { readFile, writeFile } = require('fs/promises');\n\n  async function convertPostmanEnvironment(inputFile, outputFile) {\n    try {\n      const inputData = await readFile(inputFile, 'utf8');\n      const brunoEnvironment = postmanToBrunoEnvironment(JSON.parse(inputData));\n      await writeFile(outputFile, JSON.stringify(brunoEnvironment, null, 2));\n      console.log('Environment conversion successful!');\n    } catch (error) {\n      console.error('Error during environment conversion:', error);\n    }\n  }\n\n  \n  convertPostmanEnvironment('path/to/postman-environment.json', 'path/to/bruno-environment.json');\n  ```\n  \n",
    "parentName": "converters",
    "path": "converters/postman-to-bruno"
  },
  "converters/wsdl-to-bruno": {
    "name": "wsdl-to-bruno",
    "content": "import { Callout } from 'nextra/components'\nimport { Tabs } from 'nextra/components'\n\nConvert WSDL to Bruno Collection\n\n\nBruno supports importing WSDL (Web Services Description Language) files to automatically generate SOAP API collections. This feature is particularly useful when working with legacy SOAP-based web services, as it eliminates the need for manual configuration of SOAP requests.\n\n\n  WSDL import is available in Bruno v2.14.0 and later versions.\n\n\nWhat Gets Generated\n\n\nWhen you import a WSDL file, Bruno automatically:\n\n- **Parses the WSDL structure** and extracts all available service operations\n- **Creates a structured collection** with operations organized as individual `.bru` requests\n- **Generates SOAP envelope templates** for each operation based on the XML schema definitions\n- **Pre-configures required headers** including `Content-Type: text/xml` and `SOAPAction`\n- **Includes XML schema documentation** as comments within the request body\n\nImport WSDL via UI\n\n\nStep 1: Access Import Collection\n\n\n1. Click on the three-dot menu next to any collection in the sidebar\n2. Select **Import Collection** from the dropdown menu\n\n![Import Collection Menu](/screenshots/get-started/import-export/import_collection/import_collection_main_menu.webp)\n\nStep 2: Choose WSDL Option\n\n\n1. In the Import Collection dialog, select the **WSDL** option\n\n![Import Dialog with WSDL Option](/screenshots/get-started/import-export/import_collection/import-modal.webp)\n\n2. You can either:\n   - Click the upload area to browse for a local `.wsdl` file\n   - Drag and drop a WSDL file directly into the dialog\n\n\nStep 3: Import and Review\n\n\n1. After selecting your WSDL file, Bruno will parse it and generate the collection\n2. A new folder will be created containing all the SOAP operations\n3. Each operation will be a separate request with a pre-configured SOAP envelope\n\n\n  Bruno automatically validates the WSDL structure during import. If there are any issues, you'll receive clear error messages.\n\n\nImport WSDL via CLI\n\n\nYou can also import WSDL files using the Bruno CLI, which is useful for automation and CI/CD workflows.\n\nBasic Command\n\n\n```bash\nbru import wsdl path/to/service.wsdl --output ./my-collection\n```\n\nExample\n\n\n```bash\nImport a WSDL file\n\nbru import wsdl ./services/calculator.wsdl --output ./calculator-collection\n\nImport with nested directory structure\n\nbru import wsdl ./wsdl-files/user-service.wsdl --output ./collections/soap/users\n```\n\n\n  For detailed CLI import options and examples, see the [CLI Import Guide](/bru-cli/import).\n\n\nProgrammatic Conversion\n\n\nFor advanced use cases, you can use the `@usebruno/converters` package to programmatically convert WSDL to Bruno collections.\n\nInstallation\n\n\n```bash\nnpm install @usebruno/converters\n```\n\nBasic Usage\n\n\n```javascript\nconst { wsdlToBruno } = require('@usebruno/converters');\nconst { readFile, writeFile } = require('fs/promises');\n\nasync function convertWsdlToBruno(wsdlFile, outputFile) {\n  try {\n    // Read the WSDL file\n    const wsdlContent = await readFile(wsdlFile, 'utf8');\n    \n    // Convert to Bruno collection\n    const brunoCollection = await wsdlToBruno(wsdlContent);\n    \n    // Write the output\n    await writeFile(outputFile, JSON.stringify(brunoCollection, null, 2));\n    console.log('WSDL conversion successful!');\n  } catch (error) {\n    console.error('Error during WSDL conversion:', error.message);\n  }\n}\n\n// Convert WSDL to Bruno\nconvertWsdlToBruno('path/to/service.wsdl', 'path/to/bruno-collection.json');\n```\n\nGenerated Request Structure\n\n\nEach SOAP operation in the imported collection will have the following structure:\n\nRequest Headers\n\n\n```\nContent-Type: text/xml; charset=utf-8\nSOAPAction: \"\n```\n\nRequest Body\n\n\n```xml\n\n\n  \n    \n  \n  \n    \n      \n      value\n      value\n    \n  \n\n```",
    "parentName": "converters",
    "path": "converters/wsdl-to-bruno"
  },
  "get-started/bruno-basics/create-a-collection": {
    "name": "create-a-collection",
    "content": "import { Callout } from \"nextra/components\";\n\nCreating a Collection\n\n\nA collection in Bruno is a structured group of API requests, tests, and related resources that helps you organize and manage your API testing workflow.\n\n\n  If you have an existing collection inside of another tool that you would like to import, please see [Importing Collections â†—](\n\n\nHow to Create a Collection\n\n\n1. Open Bruno and navigate to the **home screen**\n2. Click on the `Â·Â·Â·` button and select `Create Collection` from dropdown.\n\n![create collection dialog](/screenshots/get-started/bruno-basics/create-collection/bruno_collection-1.webp)\n\n3. Enter a name for your collection\n4. Choose a location on your filesystem to store the collection\n\n![create collection dialog](/screenshots/get-started/bruno-basics/create-collection/bruno_collection-2.webp)\n\n5. Click **Create**\n\nCongratulations! You have successfully created your first collection.\n\nCustom Collection Names\n\n\n\n  Starting with [Bruno v1.40.0 â†—]( you can\n  now use special characters in collection names and customize how they appear in\n  the filesystem.\n\n\nYou can use any characters in your collection names, including special characters like `/`, `[`, `]`, `*`, etc. Bruno automatically handles filesystem compatibility by replacing unsupported characters with `-` in the filenames while preserving your original collection name.\n\n[Add a request â†—]( to your collection as a next step!\n\n\n  If you're looking to collaborate and share with your team, please see [Collaboration in Bruno â†—](\n\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-collection"
  },
  "get-started/bruno-basics/create-a-folder": {
    "name": "create-a-folder",
    "content": "import { Callout } from \"nextra/components\";\n\nCreate a Folder\n\n\nBruno helps you organize your API requests efficiently by grouping them into folders. You can create a structured hierarchy that matches your API's organization, making it easier to manage and navigate your collections.\n\nCreating a New Folder\n\n\n1. Select your Collection from the sidebar.\n2. Click on the `Â·Â·Â·` button.\n3. Select `New Folder` from the dropdown menu.\n\n![create folder](/screenshots/get-started/bruno-basics/create-folder/1-create-new-folder.webp)\n\n4. Enter a name for your folder.\n5. Click `Create` to finish.\n\n![new folder dialog](/screenshots/get-started/bruno-basics/create-folder/2-create-sample-folder.webp)\n\nYour new folder is now ready to organize your requests!\n\nCustom Folder Names\n\n\n\n  Starting with [Bruno v1.40.0 â†—]( you can\n  now use special characters in folder names and customize how they appear in\n  the filesystem.\n\n\nYou can use any characters in your folder names, including special characters like `/`, `[`, `]`, `*`, etc. Bruno automatically handles filesystem compatibility by replacing unsupported characters with `-` in the filenames while preserving your original folder name.\n\nHow to View or Customize Filesystem Names\n\n\n1. Select **Show Filesystem Name.**\n\n![show filesystem name](/screenshots/get-started/bruno-basics/create-folder/3-show-file-system-name.webp)\n\n2. You can now see how your folder name is stored on the filesystem.\n\n![filesystem name view](/screenshots/get-started/bruno-basics/create-folder/4-file-system-name.webp)\n\n3. (Optional) Click the edit icon to customize the filesystem name while keeping your display name intact.\n\nThis feature allows you to:\n\n- Create more descriptive folder organization.\n- Use special characters freely.\n- Maintain filesystem compatibility automatically.\n- Keep your collection structure clean and organized.\n\nExample\n\n\nYou could name a folder \"API [v2.0] / Authentication\" and Bruno will automatically handle the filesystem compatibility while preserving your desired display name.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-folder"
  },
  "get-started/bruno-basics/create-a-request": {
    "name": "create-a-request",
    "content": "import { Callout } from 'nextra/components'\n \nCreating a Request\n\n\nBruno makes it easy to work with various API protocols - whether you're building RESTful services with HTTP, designing GraphQL APIs, or converting cURL commands into reusable requests. With support for all standard HTTP methods (GET, POST, PUT, DELETE, etc.), you can create, test, and manage your API requests efficiently.\n\nLet's walk through how to create your first request:\n\nCreate a New Request in Bruno\n\n\n1. Go to your Collection, and click on the `Â·Â·Â·` button.\n2. Select `New Request` in the dropdown menu.\n\n![create request dialog](/screenshots/get-started/bruno-basics/create_request/1-create-new-request.webp)\n\n3. In the dialog that appears, choose:\n   - Request Type (HTTP, GraphQL, or from cURL)\n   - Request Name\n   - HTTP Method (GET, POST, PUT, etc.)\n   - URL\n\n![create-new-request](/screenshots/get-started/bruno-basics/create_request/2-create-request.webp)\n\n4. Click `Create` to finish.\n\nYou have successfully created your first request in Bruno! Feel free to add headers, query parameters, and a request body to your request, or play around with the other options available.\n\nCustom Request Filenames\n\n\n\n  Starting with [Bruno v1.40.0 â†—]( you can\n  now use special characters in request names and customize how they appear in\n  the filesystem.\n\n\nYou can use any characters in your request names, including special characters like `/`, `[`, `]`, `*`, etc. Bruno automatically handles filesystem compatibility by replacing unsupported characters with `-` in the filenames while preserving your original request name.\n\nTo view or customize the filesystem name\n\n\n1. Select **Show Filesystem Name.**\n\n![file-system-name](/screenshots/get-started/bruno-basics/create_request/3-file-system-option.webp)\n\n2. You can now see how your request name is stored on the filesystem.\n\n![file-system-name](/screenshots/get-started/bruno-basics/create_request/4-file-name-special-char.webp)\n\n3. (Optional) Click the edit icon to customize the filename while keeping your display name intact.\n\nThis feature gives you complete freedom in naming your requests while ensuring filesystem compatibility.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-request"
  },
  "get-started/bruno-basics/create-a-test": {
    "name": "create-a-test",
    "content": "import { Callout } from \"nextra/components\";\n\nCreate a Test\n\n\n\n  Bruno uses the [Chai library â†—]( so you can follow the same syntax for writing\n  assertions in your tests.\n\n\nTo ensure your API is behaving as expected, create a test against it.\n\nBruno supports writing tests by through either:\n\n- Assertions to declaratively write tests\n- JavaScript\n\nAssertion\n\n\nTo get familiar with testing:\n1. open a Collection\n2. Select a request\n3. Click on the `Assertions` tab\n\nYou can then dictate an expression, operator, and value to test against.\n\n![bru assertions](/screenshots/get-started/bruno-basics/create_test/bru_test_assert.webp)\n\nTesting with JavaScript\n\n\nBruno also supports writing automation test scripts in JavaScript for more advanced API testing scenarios. By automating your tests, you can increase efficiency and coverage, and integrate testing into CI/CD pipelines.\n\nExample\n\n\n```js copy\ntest(\"should be able to login\", function () {\n  const data = res.getBody();\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should return json\", function () {\n  const data = res.getBody();\n  expect(res.getBody()).to.eql({\n    hello: \"Bruno\",\n  });\n});\n```\n\n![bru lang sample](/screenshots/test-script.webp)\n\nIn this example:\n\n1. The first test checks that the response status is 200 (indicating a successful login).\n2. The second test verifies that the response body is equal to the expected JSON object.\n\n\n  For more advanced testing scenarios and tips, view the\n  [Scripting â†—]( docs.\n\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-test"
  },
  "get-started/bruno-basics/download": {
    "name": "download",
    "content": "import { Tabs } from 'nextra/components'\n\nDownload Bruno\n\n\nBruno is an open-source, fast and lightweight API client for exploring and testing APIs. It's designed to be a modern alternative to traditional API clients with a focus on speed, simplicity, and collaboration.\n\nInstallation Options\n\n\nBruno can be installed via direct download or through package managers on supported platforms.\n\n\n  \n    ### Direct Download\n    \n    Download the latest macOS version from the [official downloads page â†—](\n    \n    ### Homebrew\n    \n    ```bash\n    brew install bruno\n    ```\n    \n  \n  \n    ### Direct Download\n    \n    Download the latest Windows installer from the [official downloads page â†—](\n    \n    ### Using Package Managers\n    \n    **Chocolatey**\n    ```bash\n    choco install bruno\n    ```\n    \n    **Winget**\n    ```bash\n    winget install Bruno.Bruno\n    ```\n    \n    **Scoop**\n    ```bash\n    scoop install bruno\n    ```\n    \n  \n  \n    ### Direct Download\n    \n    Download the latest Linux package from the [official downloads page â†—](\n    \n    ### Using Package Managers\n    \n    **APT (Debian/Ubuntu)**\n    ```bash\n    # Create keyrings directory\n    sudo mkdir -p /etc/apt/keyrings\n    \n    # Update and install GPG and curl\n    sudo apt update && sudo apt install gpg curl\n    \n    # List existing keys (optional)\n    sudo gpg --list-keys\n    \n    # Add the Bruno repository key\n    curl -fsSL \" | gpg --dearmor | sudo tee /etc/apt/keyrings/bruno.gpg > /dev/null\n    \n    # Set permissions for the GPG key file\n    sudo chmod 644 /etc/apt/keyrings/bruno.gpg\n    \n    # Add the Bruno repository\n    echo \"deb [arch=amd64 signed-by=/etc/apt/keyrings/bruno.gpg]  bruno stable\" | sudo tee /etc/apt/sources.list.d/bruno.list\n    \n    # Update and install Bruno\n    sudo apt update && sudo apt install bruno\n    ```\n    **Flatpak**\n    ```bash\n    flatpak install flathub com.usebruno.Bruno\n    ```\n    \n    **Snap**\n    ```bash\n    sudo snap install bruno\n    ```\n  \n\n\n\nRelease Information\n\n\nBruno follows semantic versioning. You can check the [GitHub Releases â†—]( page for:\n- Latest version information\n- Release notes\n- Bug fixes\n- New features included in each release\n\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/download"
  },
  "get-started/bruno-basics/run-a-collection": {
    "name": "run-a-collection",
    "content": "Run a Collection\n\n\nRunning your Bruno Collection allows you to interact with, and test, an API. We allow you to run your Collections a few different ways:\n\nCollection Runner\n\n\nWe have a built-in Collection Runner that allows for **unlimited** runs.\n\nRun your Collection by either clicking the `...` button next to your Collection in the sidebar then select `Run`\n\n![Click Run](/screenshots/get-started/bruno-basics/run_collection/run_collection.webp)\n\nor click the Collection Runner icon in the top bar of the application.\n\n![Collection Runner](/screenshots/get-started/bruno-basics/run_collection/runnericon.webp)\n\nYou'll now have access to run the collection, add parameters, or set a delay between requests.\n\n> _Data-driven testing by using a .CSV file is available in our Golden and Ultimate Edition_\n\n![Collection Runner](/screenshots/get-started/bruno-basics/run_collection/runner.webp)\n\nAutomating Runs in CI/CD\n\n\nBruno offers a command-line utility to run Collections. This allows you to integrate your tests into a CI and build process.\n\nFor more information, head to the page for [Bruno CLI â†—](\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/run-a-collection"
  },
  "get-started/configure/proxy-config": {
    "name": "proxy-config",
    "content": "Configuring Proxy Settings in Bruno\n\n\nA proxy is an intermediary server that sits between a client application (like Bruno) and the destination server that the client is communicating with (like an API). The proxy server acts as a security barrier, making requests on your behalf to websites and other internet resources, and preventing others from accessing your internal network.\n\nIf your machine sits behind a corporate network or firewall, you may need to configure the proxy settings in Bruno in order for requests to be made. By default, Proxy is set to off.\n\nBelow are steps for configuring your proxy settings at different levels within Bruno.\n\n1. Accessing Proxy Settings\n\n\n1. Open Bruno.\n2. Click on the **Preferences** section.\n\n![preferences](/screenshots/get-started/config/proxy/1-preferences.webp)\n\n3. Navigate to the **Proxy** tab in the sidebar.\n\n![proxy-settings](/screenshots/get-started/config/proxy/2-global-proxy.webp)\n\n2. Configuring Proxy Mode\n\n\nBruno provides three options for proxy mode:\n\n- **Off**: Disables proxy usage.\n- **On**: Enables proxy and routes requests through the configured proxy.\n- **System Proxy**: Uses the system-wide proxy settings.\n\nSelect **On** if you want to configure a custom proxy.\n\n3. Selecting Proxy Protocol\n\n\nBruno supports different proxy protocols. Choose one of the following:\n\n- **HTTP**\n- **HTTPS**\n- **SOCKS4**\n- **SOCKS5**\n\n4. Entering Proxy Details\n\n\nFill in the required fields:\n\n- **Hostname**: The proxy server's domain or IP address (e.g., `example.com`).\n- **Port**: The port number for the proxy connection (e.g., `3000`).\n\n5. Enabling Authentication (Optional)\n\n\nIf your proxy requires authentication:\n\n1. Check the **Auth** checkbox.\n2. Enter the **Username**.\n3. Enter the **Password** (Click the eye icon to reveal the password if needed).\n\n6. Configuring Proxy at Collection Level\n\n\nThere may be instances in which your collection needs to use a different proxy than what you have configured globally. Configuring proxy settings at the collection level will override any configuration you've made in the preferences section.\n\nBelow are instructions on proxy settings at the collection level:\n\n1. Open the collection settings.\n2. Navigate to the **Proxy** tab.\n\n![collection-proxy](/screenshots/get-started/config/proxy/3-collection-proxy.webp)\n\n**Choose the Configuration Mode:**\n\n\n- **Global**: Uses the main proxy settings from Preferences.\n- **Enabled**: Enables a custom proxy for this collection.\n- **Disabled**: Disables the proxy for this collection.\n\n3. Choose **global, enabled, or disabled**.\n4. Enter the **Hostname, Port, Protocol, Username, and Password** if needed.\n5. Click **Save** to apply the settings.\n\n7. Saving Proxy Configuration\n\n\nAfter entering the proxy details, click the **Save** button to apply the changes.\n\n---\n\nYour proxy settings are now configured in Bruno.\n",
    "parentName": "get-started",
    "path": "get-started/configure/proxy-config"
  },
  "get-started/configure/settings": {
    "name": "settings",
    "content": "Settings\n\n\nYou can customize Bruno settings according to your preferences. Bruno offers a variety of settings that can be tailored to suit your needs. Key settings include:\n\n- [General](#general)\n- [Display](#display)\n- [Proxy](#proxy)\n- [License](#license)\n- [Keybindings](#keybindings)\n- [Secrets](#secrets)\n- [Support](#support)\n- [About](#about)\n\nThese are the core settings that you can adjust to optimize your Bruno experience.\n\nGeneral\n\n\nThe General settings include options for SSL/TLS, Custom CA certificates, and Cookies. You can customize how cookies are handled by choosing to store and send them automatically, or simply uncheck the box if you prefer not to store cookies.\n\n![general-settings](/screenshots/get-started/config/settings/general-settings.webp)\n\nDisplay\n\n\nIn the Display section, you can control the appearance of the Bruno, choosing between Dark, Light, or System mode, based on your preference. Additionally, you can customize the code editor font to suit your style.\n\n![display-settings](/screenshots/get-started/config/settings/display-settings.webp)\n\nProxy\n\n\nYou can customize the Proxy settings by selecting On, Off, or System, depending on your needs. For more details, you can refer to the [Proxy guide here](./proxy-config.mdx) to learn more. By default, the Proxy setting is Off in Bruno.\n\n![proxy-settings](/screenshots/get-started/config/settings/proxy-settings.webp)\n\nLicense\n\n\nBruno offers Ultimate and Pro plans for premium users. You can refer to the [Licensing guide](/license-management/overview.mdx) to learn more about the features and benefits of each plan.\n\n![license-settings](/screenshots/get-started/config/settings/license-settings.webp)\n\nKeybindings\n\n\nThe Keybindings section provides details about Bruno's keyboard shortcuts.\n\n![keybindings](/screenshots/get-started/config/settings/key-settings.webp)\n\nSecrets\n\n\nThere are three primary ways to manage secrets in Bruno, which you can learn about in the [Secret Management Overview](/secrets-management/overview).\n\nThis setting controls the integration with a Vault for secret management, which is available in Bruno **Ultimate Edition**.\n\n![vault-secrets](/screenshots/get-started/config/settings/vault-server.webp)\n\nSupport\n\n\nIf you encounter issues or need assistance, you can access a range of troubleshooting resources to help resolve your problem quickly.\n\n![support](/screenshots/get-started/config/settings/support.webp)\n\nAbout\n\n\nView application details and enable the auto-update feature to keep your app up to date automatically.\n\n![about](/screenshots/get-started/config/settings/about.webp)\n",
    "parentName": "get-started",
    "path": "get-started/configure/settings"
  },
  "get-started/history": {
    "name": "history",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nRequest History \n\n\nThe History feature in Bruno allows you to view a detailed log of all the requests you've executed and worked with within your collections. This feature helps you track and revisit past actions, making it easier to manage and troubleshoot your workflow.\n\nHow It Works\n\n\nThe History feature automatically tracks the actions and requests made within your collections. Each time you run a request or make changes, it is logged in the history, providing you with a comprehensive timeline of your interactions.\n\nView History Logs\n\n\nTo view your history follow the below steps:\n\n1. Navigate or create a request in Bruno.\n2. Click on the **History** feature icon (top right corner).\n\n![navigate history](/screenshots/get-started/history/navigate-history.webp)\n\n3. You will have access to the complete request activity log.\n\n![navigate history](/screenshots/get-started/history/history_log.webp)\n",
    "parentName": "get-started",
    "path": "get-started/history"
  },
  "get-started/import-export-data/export-collections": {
    "name": "export-collections",
    "content": "import { Callout } from \"nextra/components\";\n\nExporting Collections\n\n\nIf your whole team isn't using Bruno (yet), no fear! You can export Bruno collections to other formats.\n\nOur preferred recommendation for sharing collections is using native Git versioning, but we realize there are other scenarios where exporting makes sense.\n\nBruno allows you to export as:\n\n- Bruno Collection\n- Postman Collection\n- OpenAPI Specification\n\n\n  Exporting as an OpenAPI Specification is only available in our Golden and Ultimate Editions\n\n\nTo export:\n1. Simply hover on the Collection you'd like to export\n2. Click the `...` menu and select `Share`\n\n![ExportDialog](/screenshots/get-started/import-export/export_collection/1-share-export.webp)\n\n3. You can then chose the format you'd like to export to and then designate a location for the file to be saved.\n\n![ExportModal](/screenshots/get-started/import-export/export_collection/2-export-options.webp)\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/export-collections"
  },
  "get-started/import-export-data/import-collections": {
    "name": "import-collections",
    "content": "import { Callout } from \"nextra/components\";\n\nImporting Collections\n\n\nBruno supports importing collections from multiple tools and formats, making it easy to transition from other API clients or work with API specifications. This guide provides step-by-step instructions for each import format.\n\nHow to Access Import Collection\n\n\nYou can import collections in two ways:\n\n**Option 1: From Home Screen**\n\n![Import from home screen](/screenshots/send-request/home-screen.webp)\n\nClick **Import Collection** on the Bruno home screen.\n\n**Option 2: From Context Menu**\n\n![Import from options menu](/screenshots/get-started/import-export/import_collection/import_collection_main_menu.webp)\n\nClick the ellipsis (three dots) in the top-left corner and select **Import Collection**.\n\n**Import Options Dialog**\n\n![Import options](/screenshots/get-started/import-export/import_collection/import-modal.webp)\n\nOnce the import dialog opens, you'll see all available import formats. Select the one that matches your source.\n\n---\n\nImport Formats\n\n\n1. Bruno Collection\n\n\n**Use this when:** A colleague shares their Bruno collection with you or you're restoring a backup.\n\n**Steps:**\n1. Open Bruno\n2. Click the context menu (three dots) â†’ **Import Collection**\n3. Browse and select your Bruno collection folder\n4. Click **Import**\n\nYour collection with all requests, folders, and configurations will be imported.\n\n---\n\n2. Postman Collection\n\n\n**Use this when:** You're migrating from Postman or importing collections shared by Postman users.\n\n**Steps:**\n1. **Export from Postman:**\n   - Open Postman\n   - Click on your collection â†’ **Export**\n   - Choose **Collection** format\n   - Save the `.json` file\n\n2. **Import to Bruno:**\n   - Open Bruno\n   - Click the context menu (three dots) â†’ **Import Collection**\n   - Drag and drop your exported `.json` file, or click to browse\n   - Click **Import**\n\n**Learn more:** [Postman Migration](/get-started/import-export-data/postman-migration)\n\n---\n\n3. Postman Data Export\n\n\n\n  **Postman Data Export** is available in our **Ultimate Edition**. This allows you to import your entire Postman workspace including collections, environments, and globals in one go.\n\n\n**Use this when:** You want to migrate your entire Postman workspace to Bruno.\n\n**Steps:**\n1. **Export from Postman:**\n   - Open Postman\n   - Go to **Settings** â†’ **Data**\n   - Click **Export Data**\n   - Choose what to include (collections, environments, globals)\n   - Download the export file\n\n2. **Import to Bruno:**\n   - Open Bruno\n   - Click the context menu (three dots) â†’ **Import Collection**\n   - Select your exported data file\n   - Click **Import**\n\n**Complete guide:** [Postman Migration Guide](/get-started/import-export-data/postman-migration)\n\n---\n\n4. Insomnia Collection\n\n\n**Use this when:** You're migrating from Insomnia or importing collections from Insomnia users.\n\n**Steps:**\n1. **Export from Insomnia:**\n   - Open Insomnia\n   - Click on your workspace/collection\n   - Go to **Application** menu â†’ **Preferences** â†’ **Data**\n   - Click **Export Data**\n   - Choose **Export Collections** or **Export Workspace**\n   - Save the `.json` file\n\n2. **Import to Bruno:**\n   - Open Bruno\n   - Click the context menu (three dots) â†’ **Import Collection**\n   - Drag and drop your exported `.json` file, or click to browse\n   - Click **Import**\n\n---\n\n5. Cloning a Git Repository\n\n\n\n  **Git Integration** is available in our **Pro** and **Ultimate** Editions.\n\n\n**Use this when:** Your team stores Bruno collections in a Git repository for version control and collaboration.\n\n**Prerequisites:**\n- Make sure the Git repository contains a valid Bruno collection\n- Ensure you have access credentials for the repository\n\n**Steps:**\n1. Open Bruno\n2. Click the context menu (three dots) â†’ **Import Collection**\n3. Select **Clone from Git Repository**\n4. Enter the Git repository URL\n5. Choose the local destination folder\n6. Click **Clone**\n\n![Clone Git Repository](/screenshots/get-started/import-export/import_collection/import-git-repo-modal.webp)\n\nThe collection will be cloned and you can start using it immediately. Any changes you make can be committed back to the repository.\n\n**Complete guide:** [Git Integration Overview](/git-integration/overview)\n\n---\n\n6. OpenAPI Specification\n\n\n**Use this when:** You have an OpenAPI (Swagger) specification file and want to generate API requests from it.\n\nImport from OpenAPI File\n\n\n**Steps:**\n1. **Obtain your OpenAPI file:**\n   - Get your OpenAPI specification file (`.json` or `.yaml` format)\n   - Ensure it's OpenAPI v3.x format\n\n2. **Import to Bruno:**\n   - Open Bruno\n   - Click the context menu (three dots) â†’ **Import Collection**\n   - Drag and drop your OpenAPI file (`.json` or `.yaml`), or click to browse\n   - Click **Import**\n\nImport from OpenAPI URL\n\n\n**Steps:**\n1. Open Bruno\n2. Click the context menu (three dots) â†’ **Import Collection**\n3. Enter the OpenAPI specification URL (e.g., `\n4. Click **Import**\n\n![Import OpenAPI URL](/screenshots/get-started/import-export/import_collection/import-openapi-url-modal.webp)\n\nBruno will automatically generate requests for all API endpoints defined in the specification.\n\n**Learn more:** [OpenAPI Guide](/open-api/importOAS.mdx)\n\n---\n\n7. WSDL (Web Services Description Language)\n\n\n**Use this when:** You're working with SOAP-based web services and have a WSDL file.\n\nImport from WSDL File\n\n\n**Steps:**\n1. **Obtain your WSDL file:**\n   - Get the `.wsdl` file from your SOAP service provider\n   - Or download it from the service endpoint (usually available at `?wsdl`)\n\n2. **Import to Bruno:**\n   - Open Bruno\n   - Click the context menu (three dots) â†’ **Import Collection**\n   - Drag and drop your `.wsdl` file, or click to browse\n   - Click **Import**\n\n**Complete guide:** [SOAP Requests](/converters/wsdl-to-bruno) \n\n---\n\nAfter Import\n\n\nOnce your collection is imported:\n\n1. **Review the requests** - Check that all requests imported correctly\n2. **Configure environments** - Set up variables for different environments (dev, staging, production)\n3. **Test the requests** - Execute a few requests to ensure they work as expected\n4. **Organize** - Create folders and organize requests if needed\n5. **Set up authentication** - Configure authentication methods if required\n\nNeed Help?\n\n\nIf you encounter issues during import:\n\n- Check the format of your export file\n- Ensure you're using the latest version of Bruno\n- Visit our [GitHub Discussions]( for community support\n- Report bugs on [GitHub Issues](\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/import-collections"
  },
  "get-started/import-export-data/postman-migration": {
    "name": "postman-migration",
    "content": "import Image from \"next/image\";\nimport { Callout } from \"nextra/components\";\n\nMigrating from Postman\n\n\nBruno makes migrating from Postman easy. All you need to do is export your collections and environments and import them to Bruno.\n\nCollection Export\n\n\nOpen Postman and select the collection you want to migrate. Click on the `Â·Â·Â·` followed by `View more actions` to open the dropdown menu and scroll down until you find `Export`, then click on it.\n\n\n  \n  \n\n\nA popup dialog will appear, select either `Collection v2` or `Collection v2.1` format and click on the `Export` button.\n\n\n\nThe collection will be downloaded as a JSON file.\n\nNow simply follow the instructions for [Importing Collections](/get-started/import-export-data/import-collections) and you're done!\n\nExport Data Dump\n\n\n\n  Bulk Import from Postman is included in Bruno Ultimate Edition\n\n\nYou can export a data dump of all your collections and environments in Postman. You can then import the data into any Bruno.\n\n**To [export a data dump â†—]( do the following in Postman:**\n\n- Select the settings icon in the header, then select `Settings`.\n\n- Select the Data tab, then select `Request Data Export`.\n\n- Select `Export Data`, then select the data types you want to export. You can export collections, environments, or both.\n\n- Select `Request Data Export`.\n\n**To import your Data Dump to Bruno:**\n\n- Open the import menu and select `Postman Data Export`\n\n- Select the zip file where the export was saved\n\n- You will now see a list of all collections available for import. By default, all collections will be selected. You can chose to omit any from the import that you'd like.\n\n- Designate a location for the collections and press `import`\n\n\n  Although we have a translator for Postman scripts, it's always good practice to review the collections after import, especially if you are using deprecated Postman syntax in your scripts.\n\n\nEnvironment Import and Export\n\n\nEnvironments in API clients are sets of variables that allow you to run requests against different server configurations (development, staging, production) without changing your request URLs.\n\nExporting Environment from Postman\n\n\n1. Open Postman and locate the **Environments** section in the sidebar\n2. Find the environment you want to export\n3. Click on the three dots (**...**) next to the environment name\n4. Select **Export** from the dropdown menu\n\n\n\n5. Choose a location to save the JSON file and click **Save**\n\nImporting Environment into Bruno\n\n\nImporting Your First Environment\n\n\n1. Open Bruno\n2. Click on the **Environments** icon in the top-right corner\n3. Click on **Configure environments**\n4. You'll see options to **Create environment** and **Import environment**\n\n![Import Environment New](/screenshots/get-started/import-export/import-postman-environment/import-environment-new.webp)\n\n5. Click on **Import environment**\n\n![Import Postman Environment](/screenshots/get-started/import-export/import-postman-environment/import-environment.webp)\n\n6. Select the Postman environment JSON file you exported\n7. The environment will be imported with all its variables\n\nAdding to Existing Environments\n\n\n1. Open Bruno\n2. Click on the **Environments** icon in the top-right corner\n3. Click on **Configure environments** \n4. Look for the **Import** button at the bottom-left corner\n\n![Bruno Environment](/screenshots/get-started/import-export/import-postman-environment/import-postman-environment-bottom.webp)\n\n5. Click on **Import environment**\n6. Select the Postman environment JSON file you exported\n7. The environment will be added to your existing environments\n\nWith environments properly configured, your API requests will work seamlessly across different deployment environments without manual changes.\n\n\n  Note - Bruno environment names and variables must only contain alphanumeric characters, \"-\", \"_\", \".\" and cannot start with a digit. Non-conforming characters (such as \"/\") will be converted to \"-\". \n\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/postman-migration"
  },
  "get-started/import-export-data/script-translator": {
    "name": "script-translator",
    "content": "import { Translator } from '../../../components/translator/translator'\nimport { AVAILABLE_THEMES } from '../../../components/translator/themes'\n\nScripts Translator\n\n\nWelcome to the **Postman** to **Bruno** scripts translator. \nThis is the same function that runs behind the **Import Postman Collection** feature in Bruno.\n\n      ",
    "parentName": "get-started",
    "path": "get-started/import-export-data/script-translator"
  },
  "get-started/javascript-sandbox": {
    "name": "javascript-sandbox",
    "content": "import { Callout } from \"nextra/components\";\n\nJavaScript Sandbox\n\n\nBruno provides two modes for executing JavaScript code in your collections: \n1. Safe Mode\n2. Developer Mode\n\n![Javascript Sandbox](/screenshots/javascript-sandbox.webp)\n\nSafe Mode\n\n\nJavaScript code is executed in a secure sandbox and cannot access your filesystem or execute system commands. We recommend Safe Mode for most users.\n\n\n  When in doubt, leave the Collection in Safe Mode. You can always switch to Developer Mode later.\n\n\nDeveloper Mode\n\n\nJavaScript code has access to the filesystem, can execute system commands and access sensitive information.\n\nWhen to use Developer Mode\n\n\n- You trust the collection source/authors (Ex: Collection maintained by you/your team) and Safe Mode is not enough for your use case.\n- You need to use external npm packages in your scripts\n- Your collection needs access to filesystem / system commands\n\nWhen to avoid Developer Mode\n\n\n- You are running a collection that you do not trust (Ex: Downloaded from the internet)\n\n\n  Developer Mode can be dangerous and should only be used when you fully understand the implications.\n\n",
    "parentName": "get-started",
    "path": "get-started/javascript-sandbox"
  },
  "git-integration/bitbucket": {
    "name": "bitbucket",
    "content": "Collaboration via Bitbucket\n\n\nBitbucket is a Git hosting web-based platform created by Atlassian. It's a popular choice for teams and organizations for collaborating and maintaining software projects. It's easy to integrate with Jira, Wiki, and other Atlassian products to manage everything in one place.\n\nBruno's Git functionality allows you to work with Bitbucket to manage, collaborate, and maintain your API development workflow.\n\nConfigure Bitbucket\n\n\nYou need to set up an SSH key with Bitbucket. While you can also set up app passwords (HTTPS), this requires you to enter your password on every operation. SSH is a more convenient and secure way to work with Bitbucket.\n\nCreate Repository on Bitbucket\n\n\nTo get started, you have to create a project/repository on Bitbucket. Follow these steps:\n\n1. Log into your Bitbucket account (create one if you don't have one)\n2. Click on the **Create** button and select **Repository** from the dropdown list\n3. Fill in all required fields and click **Create Repository**\n\n![bitbucket-create-repository](/screenshots/git-integration/bitbucket-gitlab/bit-create-project.webp)\n\nOnce you create a repository, click on the **Clone** button and copy the URL, which looks similar to:\n\n![bitbucket-clone-repository](/screenshots/git-integration/bitbucket-gitlab/bit-clone-repo.webp)\n\n```bash\ngit@bitbucket.org:/.git\n```\n\nConfigure SSH Key\n\n\nFollow these steps to configure an SSH key on your local system:\n\n1. Generate SSH Key\n\n\nOpen your terminal and execute:\n\n```bash\nssh-keygen -t ed25519 -C \"your_email@example.com\" -f ~/.ssh/id_ed25519_bitbucket\n```\n\n2. Add SSH Key to SSH Agent\n\n\nAdd the SSH key to your SSH agent so it can be used for authentication:\n\n```bash\nssh-add ~/.ssh/id_ed25519_bitbucket\n```\n\n3. Add the SSH Key to Your Bitbucket Account\n\n\n1. Go to **Bitbucket** > **Personal Settings** > **SSH Keys**\n2. Click **Add Key**\n3. Paste your `id_ed25519_bitbucket.pub` content\n\n![bitbucket-add-ssh-key](/screenshots/git-integration/bitbucket-gitlab/bit-add-ssh.webp)\n\nUse Bitbucket with Bruno\n\n\n1. Create a Collection inside Bruno (if you haven't already)\n2. Click on the **Git** icon (next to Safe Mode) and select **Initialize repo**\n3. Click on **main** and select **Remotes** from the dropdown\n4. Add **origin** as the name of the remote and paste your repository URL (copied previously)\n\nNow you can perform push, pull, and other Git operations directly from Bruno.\n\n![bruno-git-operations](/screenshots/git-integration/bitbucket-gitlab/bruno-git-operations.webp) \n\nFor more detailed information about Git operations in Bruno, check out the [Collaboration via GUI documentation](/git-integration/using-gui/intro). ",
    "parentName": "git-integration",
    "path": "git-integration/bitbucket"
  },
  "git-integration/embed-bruno-collection": {
    "name": "embed-bruno-collection",
    "content": "import { Callout } from \"nextra/components\";\nimport { useEffect } from \"react\";\nimport BrunoButton from '../../components/BrunoButton';\n\n\nFetch in Bruno Button\n\n\nBruno allows you to share your Git-synchronized collection via an embedded \"Fetch in Bruno\" (FiB) button turning the import/cloning process into a single click!\n\nThis button can be placed in websites, articles, and documentation, with support for both HTML and Markdown formats.\n\nImport collections from Git\n\n\nThis feature helps you to share your collections in an easy and flexible way - meeting the user wherever they are. Once imported, the user now has a Git-synced collection and can seamlessly pull down new changes as updates are made.\n\n\n\n  Make sure you have [Bruno version **1.40.0** â†—]( or above installed on your system\n  to use this feature.\n\n\n\nThings You Need\n\n\n1. Bruno installed on your system.\n2. A collection that has been initialized as a Git repository [either through the UI]( or from [the CLI](\n\nHow to Share Your Collection\n\n\n1. Open Bruno.\n2. Either go to the collection Overview tab or click on the `...` and select `Share`.\n\n![collection-settings](/screenshots/git-integration/share-collection/1-share-collection-overview.webp)\n\n3. Copy the generated link (HTML or Markdown).\n\n![share-option](/screenshots/git-integration/share-collection/2-share-link-html.webp)\n\n4. Embed the link into your website, article, or documentation(e.g. GitHub Readme).\n\n\n\n\nManual Embedding Options\n\n\nHTML Format\n\n```html\n\n\n```\n\nMarkdown Format\n\n```\n[]( \"target=_blank rel=noopener noreferrer\")\n```\n\nHow to Open Your Shared Collection\n\n\n1. Click on any Fetch in Bruno button.\n2. A popup will appear. Click on **Open In Bruno**.\n\n![open-in-bruno](/screenshots/git-integration/share-collection/4-fetch-in-bruno.webp)\n\n3. Choose the location where you'd like to store your collection.\n\n![collection-location](/screenshots/git-integration/share-collection/5-save-location.webp)\n\n4. You will see a list of available Bruno collections in the repository.\n\n![clone-collection](/screenshots/git-integration/share-collection/6-cloning-collection.webp)\n\nOnce the collection is loaded in Bruno, you'll be able to see the folder, requests, and all associated parameters.\n\nCustomizations \n\n\nYou can replace the Fetch in Bruno title and logo with your preferred logo and name. Simply follow the changes below in the markdown link:\n\n```bash \n[\n  Make sure you have Bruno version **2.3.0** â†— or above installed on your system\n  to use these features.\n\n\nHow to Use\n\n\n1. Choose your preferred embedding format:\n\nHTML Format\n\n```html\n\n\n```\n\nMarkdown Format\n\n```\n[]( \"target=_blank rel=noopener noreferrer\")\n```\n\n2. Replace ` with your OpenAPI specification URL.\n3. Embed this code in your website, documentation, or any HTML page.\n\nWhen users click the button, Bruno will automatically:\n- Fetch the OpenAPI specification from the provided URL\n- Convert it into a Bruno collection\n- Open it in the Bruno app and prompt the user to choose a location to save the collection\n\n",
    "parentName": "git-integration",
    "path": "git-integration/embed-bruno-collection"
  },
  "git-integration/gitlab": {
    "name": "gitlab",
    "content": "Collaboration via GitLab\n\n\nGitLab is widely recognized as a leading all-in-one platform for teams and organizations to efficiently manage and collaborate on software development projects. Offering a comprehensive suite of DevOps tools, GitLab streamlines the entire software lifecycle from planning and coding to testing, deployment, and monitoringâ€”enabling seamless collaboration and faster delivery.\n\nBruno's Git functionality allows you to work with GitLab to manage, collaborate, and maintain your API development workflow.\n\nConfigure GitLab\n\n\nYou need to set up an SSH key with GitLab. While you can also set up personal access tokens (HTTPS), this requires you to enter your token on every operation. SSH is a more convenient and secure way to work with GitLab.\n\nCreate Repository on GitLab\n\n\nTo get started, you have to create a project/repository on GitLab. Follow these steps:\n\n1. Log into your GitLab account (create one if you don't have one)\n2. Click on the **New Project** button\n3. Choose **Create blank project** or **Create from template**\n4. Fill in all required fields (Project name, Description, Visibility level)\n5. Click **Create project**\n\n![gitlab-create-project](/screenshots/git-integration/bitbucket-gitlab/gitlab-blank-project.webp)\n\nOnce you create a repository, click on the **Clone** button and copy the SSH URL, which looks similar to:\n\n![gitlab-clone-url](/screenshots/git-integration/bitbucket-gitlab/gitlab-clone-url.webp)\n\n```bash\ngit@gitlab.com:/.git\n```\n\nConfigure SSH Key\n\n\nFollow these steps to configure an SSH key on your local system:\n\n1. Generate SSH Key\n\n\nOpen your terminal and execute:\n\n```bash\nssh-keygen -t ed25519 -C \"your_email@example.com\" -f ~/.ssh/id_ed25519_gitlab\n```\n\n2. Add SSH Key to SSH Agent\n\n\nAdd the SSH key to your SSH agent so it can be used for authentication:\n\n```bash\nssh-add ~/.ssh/id_ed25519_gitlab\n```\n\n3. Add the SSH Key to Your GitLab Account\n\n\n1. Go to **GitLab** > **User Settings** (click your avatar) > **SSH Keys**\n2. Click **Add new key**\n3. Paste your `id_ed25519_gitlab.pub` content\n4. Give your key a title (e.g., \"Bruno Development\")\n5. Click **Add key**\n\n![gitlab-add-ssh-key](/screenshots/git-integration/bitbucket-gitlab/gitlab-add-ssh-key.webp)\n\nUse GitLab with Bruno\n\n\n1. Create a Collection inside Bruno (if you haven't already)\n2. Click on the **Git** icon (next to Safe Mode) and select **Initialize repo**\n3. Click on **main** and select **Remotes** from the dropdown\n4. Add **origin** as the name of the remote and paste your repository URL (copied previously)\n\nNow you can perform push, pull, and other Git operations directly from Bruno. \n\n![bruno-git-operations](/screenshots/git-integration/bitbucket-gitlab/bruno-git-operations.webp)\n\nFor more detailed information about Git operations in Bruno, check out the [Collaboration via GUI documentation](/git-integration/using-gui/intro). ",
    "parentName": "git-integration",
    "path": "git-integration/gitlab"
  },
  "git-integration/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\n\nCollaboration in Bruno\n\n\nBruno's superpower is the ability to collaborate natively using version control systems like [Git â†—]( [CVS â†—]( etc, and platforms like GitHub, Gitlab, Bitbucket, etc. This gives you and your teammates confidence that a collection is current, and provides benefits of co-location if you choose to store collections directly alongside your source code.\n\nThe process of collaborating on a Bruno collection is more or less the same in all of the above-mentioned platforms. For beginners, you can take a look at this tutorial on version control [here â†—](\n\nThere are two ways to collaborate via native Git in Bruno:\n\n1. Using the terminal or command line to execute Git commands\n2. Using the Bruno's GUI-based Git functionality.\n\n\n  GUI-based Git functionality is available within Pro and Ultimate Editions of Bruno.\n\n\nThese approaches are documented separately for ease of access. So let's dive into the next section.\n\n- [Collaboration via CLI](/git-integration/using-cli)\n- [Collaboration via GUI](/git-integration/using-gui)\n",
    "parentName": "git-integration",
    "path": "git-integration/overview"
  },
  "git-integration/using-cli": {
    "name": "using-cli",
    "content": "Collaboration via CLI\n\n\nIn the open-source version of Bruno,  Git operations are performed manually using the terminal or tools like VSCode's Git features. \n\nThis includes:\n\n- [Initializing a Git repository](#initializing-git-in-bruno-collection)\n- [Adding and committing changes](#adding-and-committing-changes)\n- [Pushing and pulling updates](#pushing-and-pulling-changes)\n\nBelow is a step-by-step guide on how to use Git with Bruno in the open-source version.\n\nInitializing Git in a Collection\n\n\nTo add your collection to version control, you need to initialize a Git repository in the directory where your .bru files are stored using the following steps:\n\n1. **Navigate to the Bruno Collection Location:**\n\n   - Navigate to the location on your PC where you created the Bruno collection, and copy the path. [^1]\n\n2. **Change directory in Terminal:**\n\n   - Run the following command in the terminal:\n\n     ```bash\n     cd path/to/your/bruno/collection\n     ```\n\n3. **Initialize Git:**\n   - Run the following command to initialize Git in the Bruno collection directory:\n\n     ```bash\n     git init\n     ```\n\nAdding and Committing Changes\n\n\nAfter initializing the Git repository, you can add and commit changes to your collection.\n\n1. **Creating a New HTTP Request in Bruno App**\n\n    - Hover over the collection name in the Bruno app.\n    - Click on the three dots, then click on \"New Request.\"\n    - Type in the name of the request and populate the URL field with `\n    - After populating the fields with appropriate values, click on the \"Create\" button, or you can press ENTER/RETURN on your keyboard to create the request. This will create a new `.bru` file with the name that you just specified.\n\n2. **Adding and committing the changes**\n   - Stage all the changes made inside the collection:\n\n     ```bash\n     git add .\n     ```\n   - Commit the changes:\n\n     ```bash\n     git commit -m \"Created my first Bruno request ðŸ¶\"\n     ```\n\nPushing and Pulling Changes\n\n\nTo share your changes with others, you can push and pull your commits to/from a remote repository.\n\n1. **Pushing changes**\n\n   ```bash\n   git push -u origin main\n   ```\n\n2. **Pulling changes**\n\n   ```bash\n   git pull origin main\n   ```\n",
    "parentName": "git-integration",
    "path": "git-integration/using-cli"
  },
  "git-integration/using-gui/consumer": {
    "name": "consumer",
    "content": "import { Callout } from \"nextra/components\";\n\nCloning Collections from GitHub \n\n\nTo clone a collection from GitHub into **Bruno**, you need to have an existing collection repository hosted on GitHub.\n\n\n  You must have an existing collection repository hosted on GitHub.\n\n\nFor example, you can use this [Bruno repository â†—]( and follow the steps below.\n\n1. Launch **Bruno** and click on the **Main Menu** in the top-left corner.\n2. Click on **Import Collection** from the dropdown menu.\n\n![Import Option](/screenshots/git-integration/git-gui/consumer/1-import-option.webp)\n\n3. Select **Clone Git Repository** from the available options.\n\n![Clone Repository](/screenshots/git-integration/git-gui/consumer/2-click-clone-repo.webp)\n\n4. Enter the above **GitHub Repository URL** and specify the **Location** where you want to save the cloned collection.\n\n![Enter Repository URL](/screenshots/git-integration/git-gui/consumer/3-enter-repo-url.webp)\n\n5. Click the **Clone** button to begin cloning the repository.\n6. After the cloning process completes, select the **Collection** you want to open and click **Open**.\n\n![Collection Open](/screenshots/git-integration/git-gui/consumer/4-collection-open.webp)\n\nYou'll see your collection will be open in **Bruno**.\n\n\n**Pulling Changes**\n\n\nPull the latest changes from the remote repository to stay synchronized with your team.\n\n1. Go to **Git UI**.\n2. Toggle **Check for Updates** button.\n3. Select **Pull from** and confirm the **Remote Server** configurations.\n4. Click on **Pull** button.\n\n![Pull Changes](/screenshots/git-integration/git-gui/10-pull-changes.webp)\n\nNow you can see all your remote changes pulled in your collection.\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/consumer"
  },
  "git-integration/using-gui/intro": {
    "name": "intro",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nCollaboration via GUI \n\n\nBruno offers an intuitive **GUI-based Git collaboration** feature, available in the [Pro â†—]( and [Ultimate Editions â†—]( This feature makes it easier for both engineering and non-engineering teams to collaborate seamlessly on collections.\n\n\n  Git must be\n  [installed â†—]( on\n  your machine to use this feature.\n\n\nThis feature includes following actions:\n\n- [Initializing Git in a Collection](../using-gui/provider#initializing-git)\n- [Adding and Committing Changes](../using-gui/provider#adding-and-committing-changes)\n- [Pushing and Pulling Changes](../using-gui/provider#pushing-and-pulling-changes)\n- [Branch Creation and Checkout](../using-gui/provider#branch-creation-and-checkout)\n- [Cloning a Repository](./consumer#cloning-collections-from-github)\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/intro"
  },
  "git-integration/using-gui/provider": {
    "name": "provider",
    "content": "import Video from \"@/components/Video\";\n\nInitializing Git\n\n\nInitializing Git in Bruno is the first step towards managing your API collections with version control. It's easy and quick to set up. Follow the steps below to initialize Git.\n\n1. Launch the **Bruno app**.\n2. Navigate to the collection you want to initialize with Git.\n3. Click on the **Git Icon** in the top-right corner of the navbar.\n\n![Initialize Git](/screenshots/git-integration/git-gui/1-init-git.webp)\n\n4. Click the **Initialize** button to set up your collection with Git.\n\n![Click Init Button](/screenshots/git-integration/git-gui/2-click-init-button.webp)\n\nThis allows you to perform other Git operations such as adding, committing, pushing, pulling changes, and more.\n\nConnecting to Remote Repository\n\n\nOnce you have initialized your collection, the next step is to connect it to a remote Git repository.\nYou can directly connect to remote repository from Bruno using Git GUI feature.\n\nTo connect Bruno to GitHub, you need to set up either an SSH key or a Personal Access Token (PAT) on GitHub. Follow this [official GitHub guide â†—]( to set it up.\n\n1. Create empty Git repository on your GitHub.\n2. Open **Git initialized** Bruno collection.\n3. Click on **Quick Links** (bottom-left corner).\n4. Select **Remotes** from the dropdown.\n\n![Add Remote Option](/screenshots/git-integration/git-gui/5-add-remote-option.webp)\n\n5. Click on **Add Remote** button.\n6. Enter **Remote Name** and **URL** (Https or SSH) and click on save.\n\n\n![Add Remote Dialog Box](/screenshots/git-integration/git-gui/6-add-remote-dialogbox.webp)\n\n\n\n\nAfter completing the above steps, your collection will be connected to GitHub. We have to **add and commit** (see below) some changes to pushed collection to GitHub.\n\n\nOnce your collection is connected to the remote repository, you can manage it directly from the Bruno app.\n\nAdding and Committing Changes\n\n\nOnce you've made changes to your collection in Bruno, you can easily commit those changes using the Git UI. This allows you to track changes and collaborate with your team efficiently.\n\nFollow these steps to add and commit changes:\n\n1. Go to **Git UI**. \n2. Click on **Add Icon** to stage your changes.\n\n![Stage Changes](/screenshots/git-integration/git-gui/3-stage-changes.webp)\n\n4. Click on **Commit Changes** button.\n5. Write a Commit Message and click **Commit**.\n\n![Commit Changes](/screenshots/git-integration/git-gui/4-commit-changes.webp)\n\n> You can commit all changes in a single click by pressing the **Add All Changes** button.\n\nBy following these steps, your changes are now committed and tracked in Git, ready to be pushed or shared with others.\n\nPushing and Pulling Changes\n\n\nThe GUI-based Git integration in Bruno allows both engineering and non-engineering teams to work together in a fast, efficient, and accurate manner. This integration ensures that your collections remain consistently up-to-date across all team members.\n\n> Before you can push or pull changes, ensure that the **remote repository** is linked to your project.\n\nPushing Changes\n\n\nPush your local changes to the remote repository with just a few clicks.\n\n1. Click on **Git UI** and toggle **Check for Updates** button.\n2. Select **Push to** and confirm the **Remote Server** configurations.\n3. Click on **Push** button.\n\n![Push Pull](/screenshots/git-integration/git-gui/8-push-pull.webp)\n\nNow you can see all your local changes pushed to the remote repository.\n\n> Follow Consumer guide to learn about pulling changes feature.\n\nBranch Creation and Checkout\n\n\nWith branches in **Bruno**, you can manage your code effectively by isolating different features or tasks.\n\nCreating Branches\n\n\nFollow the below steps to create branches in Bruno.\n\n1. Go to **Git UI**.\n2. Click on **main** and select **Create Branch** from dropdown.\n3. Enter **Branch Name**.\n4. Click on **Save** button.\n\n![Create Branch](/screenshots/git-integration/git-gui/7-create-branch.webp)\n\nOnce the branch is created, you can start making changes to the branch.\n\nBranch Checkout\n\n\n1. Click on **main**.\n2. Select the branch you want to switch.\n\n![Create Branch](/screenshots/git-integration/git-gui/9-branch-checkout.webp)\n\n3. Now you're switched to your selected branch.\n\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/provider"
  },
  "index": {
    "name": "index",
    "content": "import { Callout } from \"nextra/components\";\n\nWhat is Bruno? \n\n\nBruno is a Git-friendly and offline-first open-source API client aimed at revolutionizing the status quo represented by tools like Postman and Insomnia. \n\n![homepage](/screenshots/homepage.webp)\n\nWe aim to solve two core issues: \n\n**Collaboration**\n\n\nBruno's superpower is collaboration through a live connection to your version control system, such as Git. \n\nWith Bruno, collections are stored directly in a folder on the filesystem. A plain text markup language, Bru, is used to save information about API requests. \n\n\n  Go to documentation for [Collaboration via Git â†—](/git-integration/overview)\n\n\n**Data Privacy and Security**\n\n\nLegacy API clients have moved towards capturing every piece of data they can, from your PII (name, email), to the actual contents of your API requests and responses (keys, tokens, etc).\n\nBruno is an offline tool. There's no concept of a login or account, and there is no cloud connection or syncing of the work you do in Bruno. \n\n\n  If you or your organization purchases a Golden Edition license, your email is required simply for the issuance of a license key.\n\n\n\n  If your organization purchases an Ultimate Edition license, your email can be held in a self-hosted licensing server which you manage.\n\n",
    "parentName": null,
    "path": "index"
  },
  "introduction/feedback-community": {
    "name": "feedback-community",
    "content": "Feedback & Community\n\n\nBruno is building a community of API practitioners who want to challenge the state of tooling available. Our roadmap and releases are driven by your feedback and, as an open-source project, sometimes directly from your PRs.\n\nHelp us continue building the most powerful, logical, and dev-friendly API tool available today!\n\nHow to Engage\n\n\n- Raise a [GitHub Issue â†—](\n- Star us on [Github â†—](\n- Join our [Discord â†—](\n- Email our [Support Team](mailto:support@usebruno.com)\n",
    "parentName": "introduction",
    "path": "introduction/feedback-community"
  },
  "introduction/manifesto": {
    "name": "manifesto",
    "content": "Manifesto\n\n\nIt's time for a revolution in API client technology! \n\nWe refuse to be shoehorned into a proprietary version control system for collaborating on API collections and we don't want the details of our APIs, API requests, or API responses synced to the cloud and potentially be made public. \n\nWe are an opensource project, rising up against the monopoly of bloated and closed systems. We believe that API collections should be co-located within your source code repository, serving as a living set of examples on how to use the API.\n\nWith Bruno, collections become first-class citizens, co-located with related information and easily version controlled. We say goodbye to bloated workspaces and global environments, and embrace the benefits of co-location.\n\nWe dream of a world where developers can clone a code repo, get it up and running, use Bruno to browse the examples on how to use the API and start playing with it. No more horror stories of *\"Tim had the collections for the payment-api service, but he left the company last month.\"*\n\nJoin us in our mission to create a better API client for developers. Say goodbye to bloatware and hello to simplicity, efficiency and freedom. Try Bruno today and experience the difference for yourself.\n",
    "parentName": "introduction",
    "path": "introduction/manifesto"
  },
  "introduction/what-is-bruno": {
    "name": "what-is-bruno",
    "content": "import { Callout } from \"nextra/components\";\n\nWhat is Bruno? \n\n\nBruno is a Git-friendly and offline-first open-source API client aimed at revolutionizing the status quo represented by tools like Postman and Insomnia. \n\n![homepage](/screenshots/homepage.webp)\n\nWe aim to solve two core issues: \n\n**Collaboration**\n\n\nBruno's superpower is collaboration through a live connection to your version control system, such as Git. \n\nWith Bruno, collections are stored directly in a folder on the filesystem. A plain text markup language, Bru, is used to save information about API requests. \n\n\n  Go to documentation for [Collaboration via Git â†—](/git-integration/overview)\n\n\n**Data Privacy and Security**\n\n\nLegacy API clients have moved towards capturing every piece of data they can, from your PII (name, email), to the actual contents of your API requests and responses (keys, tokens, etc).\n\nBruno is an offline tool. There's no concept of a login or account, and there is no cloud connection or syncing of the work you do in Bruno. \n\n\n  If you or your organization purchases a Golden Edition license, your email is required simply for the issuance of a license key.\n\n\n\n  If your organization purchases an Ultimate Edition license, your email can be held in a self-hosted licensing server which you manage.\n\n",
    "parentName": "introduction",
    "path": "introduction/what-is-bruno"
  },
  "license-administrators/license-portal": {
    "name": "license-portal",
    "content": "import Image from 'next/image'\n\nLicense Management Portal\n\n\nBruno provides a licensing management portal for the purposes of:\n\n- Provisioning and deprovisioning licenses\n- Managing License Administrators associated with your account\n- Viewing details related to your Bruno subscription\n\nAccessing the Portal\n\n\nIf you've been designated as a License Administrator, either through purchasing on our website or through assignment by another admin:\n\n- Navigate to  \n\n\n\n- Enter your email address and press `continue`\n- Retrieve and enter the OTP (one time password) that was sent to your email\n\n\n\n- You have now accessed the portal! \n\nAssigning licenses\n\n\nAdding a single user\n\n\n- Select `Add User`\n- Enter the name and email of the user you'd like to add\n- Click `Create`\n\n\n\n- The user will automatically receive an email with their license key\n\nAdding users in bulk\n\n\n> Ultimate licenses come with the ability to add users via a CSV upload\n\n- Click ellipsis next to `Add User`\n- Select `Import Users`\n- *optionally download the sample CSV to view the format for user upload*\n- Click `Upload`and select your file\n- Click `Add Users`\n\n\n\n- Users will automatically receive an email with their respective license key\n\nRemoving licenses \n\n\nRemoving a Single User\n\n\n- Click on the trash can icon in the user's row\n- Select `Delete`\n\nRemove Users in bulk\n\n- Click ellipsis next to `Add User`\n- Select `Delete Users`\n- *optionally download the sample CSV to view the format for user deletion*\n- Click `Upload`and select your file\n- Click `Delete Users`\n\n\n\nAdding License Administrators\n\n\nThe number of License Administrators you can have associated with your account is based on your [plan type â†—]( \n\n- Navigate to `Settings`\n- Click on `Admins` page\n\n\n\n- Select `Add Admin`\n\n\n\n- Enter their name and email\n- Select `Add`\n\nView Plan Details\n\n\nYou can view the type of plan, number of licenses, and subscription dates by:\n\n- Navigate to `Settings`\n- Select `Billing`\n\n\n",
    "parentName": "license-administrators",
    "path": "license-administrators/license-portal"
  },
  "license-administrators/saml-sso/configure-saml-sso-with-entra-id": {
    "name": "configure-saml-sso-with-entra-id",
    "content": "import { Callout } from \"nextra/components\";\nimport Image from 'next/image';\n\nConfigure SAML SSO with Microsoft Entra ID\n\n\nThis guide walks you through configuring SAML Single Sign-On for Bruno using Microsoft Entra ID (formerly Azure Active Directory) as your identity provider.\n\n\nBefore you begin, make sure you have completed the [prerequisites](./overview#prerequisites) and have admin access to both Microsoft Entra ID and the Bruno License Portal.\n\n\nConfigure SSO in Bruno\n\n\nBefore configuring a SAML application in Microsoft Entra ID, first configure SSO in Bruno.\n\n1. Log in to the [Bruno License Portal](\n2. Navigate to **Settings** â†’ **SSO** in the left sidebar\n\n\n\n3. Toggle the **Enable SSO** switch on\n\n4. Note the following values (you'll need these when configuring Entra ID):\n   - **SAML ACS URL**: Copy this URL exactly as shown in Bruno\n   - **SP Issuer ID / Entity ID**: Set your own unique identifier (e.g., `bruno-sso`, `bruno-entra`, `your-company-bruno`, etc.)\n\n\n\n\nKeep this page open in a separate tab - you'll return here after configuring Entra ID to complete the Bruno SSO setup.\n\n\nConfigure SSO with Microsoft Entra ID\n\n\nStep 1: Create a New Enterprise Application\n\n\n1. Log in to the [Microsoft Entra admin center](\n2. On the left sidebar, navigate to **Enterprise apps** â†’ **+ New application**\n3. Click **Create your own application**\n4. Enter the application name: Set your own unique identifier (e.g., `Bruno`, `Bruno-SAML-App`, etc.)\n5. Select **Integrate any other application you don't find in the gallery (Non-gallery)**\n6. Click **Create**\n\n\n\nStep 2: Select SAML as Single Sign-On Method\n\n\n1. In the created Enterprise Application, navigate to **Manage** â†’ **Single sign-on** in the left sidebar\n2. Select **SAML** as the single sign-on method\n\n\n\nStep 3: Configure Basic SAML Configuration\n\n\n1. Under **Single sign-on** section in the **Basic SAML Configuration** section, click **Edit**\n2. Copy the values from the Bruno SSO settings page and paste them into your SAML configuration in Microsoft Entra ID:\n   - **Identifier (Entity ID)**: Paste the **SP Issuer ID / Entity ID** value from the Bruno License Portal\n   - **Reply URL (Assertion Consumer Service URL)**: Copy and paste the **SAML ACS URL** from the Bruno License Portal\n3. Click **Save**\n\n\n\n\n**Critical**: The Entity ID in Entra ID must match EXACTLY what you configured in Bruno's **SP Issuer ID / Entity ID** field. A mismatch will cause authentication failures.\n\n\nStep 4: Configure Attributes & Claims\n\n\nBruno requires three specific SAML attributes to be configured in Entra ID:\n- `Unique User Identifier (Name ID)`, `roles`, and `fullName`\n\nThese attributes map user information from Entra ID to your Bruno subscription, ensuring users get the correct access levels.\n\n**How Attribute Mapping Works:**\n- **User Identification**: Bruno uses the email address (NameID) to match the SSO user with existing Bruno users in your subscription\n- **Role Assignment**: The `roles` attribute determines whether the user gets admin or standard access in Bruno\n- **Profile Information**: The `fullName` attribute populates the user's display name in Bruno\n\nRequired Claims\n\n\nIn the **Attributes & Claims** section:\n\n1. Click **Edit**\n\n\n\n2. Delete any existing claims that are not on this list\n3. You will now update the claims to match the following:\n\n| Claim Name | Source Attribute | Notes |\n|------------|------------------|-------|\n| **Unique User Identifier (Name ID)** | `user.mail` | Required for user identification. |\n| **roles** | Static value, user attribute, or transformation - e.g., `user.assignedroles`, `user.department`, `user.jobtitle`, etc. | Any role value from Entra ID. Can be mapped to existing user attributes or group membership. |\n| **fullName** | Transformation: `user.givenname + \" \" + user.surname` or equivalent attribute | Represents the combined user's first and last name. |\n\nConfiguring the `Unique User Identifier (Name ID)` claim\n\n\nThis claim is required for user identification. It will be mapped to the user's email address in Entra ID.\n\n2. Click the `Unique User Identifier` claim\n3. Select the **Source Attribute** option\n4. Choose `user.mail` as the attribute\n5. Click **Save**\n\n\n\nConfiguring the `roles` claim\n\n\nThe `roles` claim will represent the user's roles in Bruno. This role value will be mapped to Bruno access levels for the License Portal and for License Activation. These roles could be hardcoded, mapped to existing user attributes, originate from [App Roles]( etc.\n\nOn the **Attributes & Claims** page:\n\n1. Click **Add new claim**\n2. Enter `roles` as the name\n3. Configure the claim as follows:\n\n   - **Map to existing user attribute**:\n     - Under **Source**, select **Attribute**\n     - Choose an existing user attribute like `user.assignedroles`, `user.department`, `user.jobtitle`, or custom attributes\n4. Click **Save**\n\n\n\n\n**Important**: The role value sent by Entra ID will be mapped to Bruno access levels in the License Portal's SSO Settings. You'll configure which role values correspond to admin or user access in Bruno (see Step 2 in the Bruno configuration section below).\n\n**Example Scenarios:**\n- If you set a static value of `Engineering`, you'll add the value `Engineering` in the Bruno License Portal to the corresponding Admin or User role field\n- If you map to `user.department` and a user's department is `IT`, you'll add `IT` to the appropriate role field in the Bruno License Portal\n\n\nConfiguring the `fullName` claim \n\n\nThe `fullName` claim represents the user's full name. This may already be available in your Entra ID user profile as a single field (e.g., `user.displayname`). If so, you can map the `fullName` attribute directly to that field.\n\nIf a full name field is not available, you can concatenate the first and last name fields using a transformation as follows:\n\nOn the **Attributes & Claims** page:\n\n1. Click **Add new claim**\n2. Enter `fullName` as the name\n3. Under **Source**, select **Transformation**\n4. In **Manage Transformation**, configure the transformation:\n   - **Transformation**: `Join()`\n   - **Parameter 1**: `user.givenname`\n   - **Separator**: ` ` (space)\n   - **Parameter 2**: `user.surname`\n6. Click **Save**\n\n\n\nFinalized Attributes & Claims Configuration\n\n\nReturn to the **Attributes & Claims** page and verify the following:\n\n1. Any other claims that are not shown below have been deleted\n2. The `Unique User Identifier (Name ID)`, `roles`, and `fullName` claims are configured as shown above\n\n\n\n\n**Important**: Both `roles` and `fullName` attributes are required for Bruno SAML SSO to function correctly. The attribute names are case-sensitive and must match the appropriate values configured in Entra ID.\n\n\n{/* TODO: Add screenshot - entra-attributes-claims.png\n     Shows the Attributes & Claims configuration\n     Alt text: \"Configure attributes and claims in Entra ID\" */}\n\nFinish SSO Configuration in Bruno\n\n\nStep 1: Add SSO URL to Bruno License Portal\n\n\n**IdP Login URL / SSO URL**\n\n1. Return to the Enterprise Application page and navigate to **Manage** â†’ **Single sign-on** in the left sidebar\n2. In the **Set up 'AppName'** section 4, copy the following value:\n   - **Login URL**: Copy this URL\n\n\n\n3. Return to the [Bruno License Portal]( tab you opened [from the earlier configuration](#configure-sso-in-bruno)\n4. Navigate to **Settings** â†’ **SSO** (if not already there)\n5. Under **SAML Configuration** paste the **Login URL** from Entra ID into the **IdP Login URL / SSO URL** field\n\n\n\nStep 2: Add IdP Certificate to Bruno License Portal\n\n\n**Entra ID IdP Certificate**\n\n1. In the **SAML Certificates** section 3:\n   - **Certificate (Base64)**: Download the certificate\n\n\n\n2. Open the downloaded certificate file and copy the contents (include the `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` lines)\n3. Return to the Bruno License Portal tab\n4. Under **SAML Configuration** paste the certificate contents into the **IdP Certificate** field\n\n\n\nStep 3: Map the role values from Entra ID to Bruno access levels\n\n\n1. Under the Bruno License Portal in the SSO Configuration page, scroll down to the **Role Mapping** section\n2. **Admin Roles**: Enter the role values (comma-separated) that will have admin access to the Bruno License Portal\n   - Example: `admin,BrunoAdmin,IT-Administrators`\n   - These values must match what you configured in the `roles` attribute in Entra ID\n   - Users with these roles can access the admin panel and manage licenses\n\n3. **User Roles**: Enter the role values (comma-separated) that should have user access to Bruno\n   - Example: `user,Engineering,Developers,QA`\n   - These values must match what you configured in the `roles` attribute in Entra ID\n   - Users with these roles will be able to activate their Bruno licenses with SSO. **They will not have access to the admin panel.**\n\n\n\n\n\n**How Role Mapping Works:**\n\nThe role value you configured in Entra ID's `roles` claim will be sent in the SAML assertion. Bruno will check if this value matches any role in the \"Admin Roles\" or \"User Roles\" fields.\n\n**Example:**\n- In Entra ID, you set the `roles` claim to map to `user.department`\n- A user's department is `Engineering`\n- In Bruno Admin Roles, you enter: `admin,IT`\n- In Bruno User Roles, you enter: `user,Engineering,QA`\n- Result: Users from the Engineering department get standard access (matches \"Engineering\" in User Roles)\n\n\n\n**Important**: Role values are case-sensitive. Ensure the values in Entra ID's `roles` claim match exactly with the values you enter in Bruno's Admin Roles or User Roles fields.\n\n\nStep 5: Configure Session Settings\n\n\n1. Scroll down to the **Session Timeout** section:\n   - Set the session timeout in seconds (default: 3600 = 1 hour)\n2. Click **Save Configuration** to apply your SAML SSO configuration\n\n{/* TODO: Add screenshot - bruno-session-config-entra.png\n     Shows the session configuration in Bruno\n     Alt text: \"Configure session timeout in Bruno License Portal\" */}\n\nTest Your SAML Configuration\n\n\nAssign Users or Groups\n\n\n1. In your Entra ID Enterprise Application, navigate to **Manage** â†’ **Users and groups** in the left sidebar\n2. Click **Add user/group**\n\n\n\n3. Select the users or groups that should have access to Bruno, if using [App Roles]( they can be assigned here\n4. Click **Assign**\n\n\nTest SSO Login\n\n\n1. Navigate to the Bruno License Portal (\n2. Enter the email address of a user assigned to the Bruno app in Entra ID\n3. Click **Login with SSO**\n4. You should be redirected to Entra ID to authenticate\n\n\n\n5. If your user is an admin in Bruno and contains the correct role mapping, you should be redirected back to the Bruno License Portal\n\n\nNext Steps\n\n\nAfter setting up SSO with Microsoft Entra ID, you can:\n\n- [Configure SCIM Provisioning](../scim-provisioning/overview) to automate user provisioning and deprovisioning\n- [Manage your Bruno licenses](../license-portal) in the License Portal\n\nRelated Resources\n\n\nFor more information about configuring SAML SSO and managing roles in Microsoft Entra ID, refer to these Microsoft documentation resources:\n\n- [SAML authentication with Microsoft Entra ID]( - Overview of SAML protocol and authentication flow\n- [Enable SAML single sign-on for an enterprise application]( - Step-by-step guide for SAML SSO setup\n- [Customize SAML token claims]( - Configure custom attributes and claims for SAML applications\n- [Using App Roles for role-based access control]( - Configure and use App Roles for fine-grained access control\n- [Manage federation certificates for federated single sign-on]( - Manage and renew SAML certificates\n- [Plan a single sign-on deployment]( - Best practices and planning guide for SSO deployment\n",
    "parentName": "license-administrators",
    "path": "license-administrators/saml-sso/configure-saml-sso-with-entra-id"
  },
  "license-administrators/saml-sso/configure-saml-sso-with-okta": {
    "name": "configure-saml-sso-with-okta",
    "content": "import { Callout } from \"nextra/components\";\nimport Image from 'next/image';\n\nConfigure SAML SSO with Okta\n\n\nThis guide walks you through configuring SAML Single Sign-On for Bruno using Okta as your identity provider.\n\n\nBefore you begin, make sure you have completed the [prerequisites](./overview#prerequisites) and have admin access to both Okta and the Bruno License Portal.\n\n\nConfigure SSO in Bruno\n\n\nBefore configuring a SAML application in Okta, first configure SSO in Bruno.\n\n1. Log in to the [Bruno License Portal](\n2. Navigate to **Settings** â†’ **SSO** in the left sidebar\n\n\n\n3. Toggle the **Enable SSO** switch on\n\n4. Note the following values (you'll need these when configuring Okta):\n   - **SAML ACS URL**: Copy this URL exactly as shown in Bruno \n   - **SP Issuer ID / Entity ID**: Set your own unique identifier (e.g., `bruno-sso`, `bruno-okta`, `your-company-bruno`, etc.)\n\n\n\n\nKeep this page open in a separate tab - you'll return here after configuring Okta to complete the Bruno SSO setup.\n\n\nConfigure SSO with Okta\n\n\nStep 1: Create a New SAML Application\n\n\n1. Log in to your Okta Admin Console\n2. Navigate to **Applications** â†’ **Applications** in the left sidebar\n3. Click **Create App Integration**\n\n\n\n4. Select **SAML 2.0** as the sign-in method\n5. Click **Next**\n\n\n\nStep 2: Configure General Settings\n\n\n1. Enter the following information:\n   - **App name**: Set your own unique identifier (e.g., `Bruno`, `Bruno-SAML-App`, etc.)\n   - **App logo**: (Optional) Upload Bruno logo\n   - **App visibility**: Configure based on your organization's preferences\n2. Click **Next**\n\n\n\nStep 3: Configure SAML Settings\n\n\nCopy the values from the Bruno SSO settings page and paste them into your SAML configuration in Okta.\n\n**Single Sign-On URL:**\n\n1. In the **Single sign-on URL** field, copy and paste the **SAML ACS URL** from Bruno\n\n2. Check **Use this for Recipient URL and Destination URL**\n\n{/* TODO: Add screenshot - okta-sso-url.png\n     Shows the Single sign-on URL field filled in\n     Alt text: \"Configure Single sign-on URL in Okta\" */}\n\n**Audience URI (SP Entity ID):**\n\n1. In the **Audience URI (SP Entity ID)** field, paste the **SP Issuer ID / Entity ID** value from the Bruno License Portal\n   - **Important**: This value must match EXACTLY what you configured in the Bruno SSO Configuration page\n\n**Name ID Format:**\n\n1. Select **EmailAddress** from the **Name ID format** dropdown\n\n**Application Username:**\n\n1. Select **Email** from the **Application username** dropdown\n\n\n\nStep 4: Configure Attribute Statements\n\n\nBruno requires two specific SAML attributes to be configured. Add the following attribute statements:\n\n| Name | Name Format | Value | Notes |\n|------|-------------|-------|-------|\n| **roles** | Unspecified | Any role value from Okta | Can be a static value (e.g., `\"admin\"`) or mapped to existing Okta user attributes/groups |\n| **fullName** | Unspecified | `user.firstName+\" \"+user.lastName` | Concatenates first and last name. Can also use a single name field if available. |\n\n\n**Configuring the roles attribute:**\n\nThe `roles` attribute can be configured in several ways:\n\n1. **Static value for testing**: Set a hardcoded value like `\"admin\"` for all users assigned to this app\n   - Example: Value = `\"admin\"`\n\n2. **Map to existing or created Okta user attribute**: If your Okta users already have a role attribute or you create a specific attribute for Bruno roles\n   - Example: Value = `user.userType` or `user.role` or `user.brunoRole`\n\n{/* 3. **Map to Okta group membership**: Use an Okta expression to map group names\n   - Example: Value = `appuser.groups` (requires group attribute statement configuration) */}\n\n**Important**: The role value sent by Okta will be mapped to Bruno access levels in the License Portal's SSO Settings. You'll configure which role values correspond to admin or user access in Bruno (see Step 2 in the Bruno configuration section below).\n\n**Example Scenarios:**\n- If you set Value = `\"Engineering\"`, you'll add `Engineering` to either \"Admin Roles\" or \"User Roles\" in Bruno\n- If you set Value = `user.department`, and a user's department is `IT`, you'll add `IT` to the appropriate role field in Bruno\n\n\n\n**Configuring the fullName attribute:**\n\nThe `fullName` attribute can be configured by:\n- Concatenating first and last name: `user.firstName+\" \"+user.lastName`\n- Using a single field if your Okta user profile has a combined name field\n- Mapping to any existing user property that contains the full name\n\n\n\n\n\n**Important**: Both `roles` and `fullName` attributes are required for Bruno SAML SSO to function correctly. The attribute names are case-sensitive and must match exactly as shown.\n\n\n**Preview the SAML Assertion**\n\n1. Scroll down to the **Preview the SAML assertion generated from the information above** section\n2. Click **Preview the SAML Assertion**\n3. Verify the generated XML contains the configured attributes: `NameID Format`,`roles`, `fullName`\n4. Click **Next**\n\n\nStep 5: Complete Okta App Setup\n\n\n1. On the **Feedback** page:\n   - Select **I'm an Okta customer adding an internal app**\n   - Check **This is an internal app that we have created**\n2. Click **Finish**\n\n\n\n\nFinish SSO Configuration in Bruno\n\n\nStep 1: Add SSO URL to Bruno License Portal\n\n\n**IdP Login URL / SSO URL**\n\n1. In your configure Okta application, navigate to the **Sign On** tab\n2. Scroll down to the **SAML 2.0** section, expand the **Hide details** section\n3. Copy the following values (you'll need these for Bruno configuration):\n   - **Sign on URL**: Copy this URL\n\n\n\n4. Return to the Bruno License Portal tab you opened [from the earlier configuration](#configure-sso-in-bruno)\n5. Navigate to **Settings** â†’ **SSO** (if not already there)\n6. Under **SAML Configuration** paste the **Sign on URL** from Okta into the **IdP Login URL / SSO URL** field\n\n\n\nStep 2: Add IdP Certificate to Bruno License Portal\n\n\n**Okta IdP Certificate**\n\n1. Scroll down the **Sign On** tab to **SAML Signing Certificates**\n2. Click **Generate new certificate**\n3. For the newly generated certificate, click the **Actions** dropdown and select **Download Certificate**\n\n\n\n4. Open the downloaded certificate file and copy the contents (include the `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` lines)\n5. Return to the Bruno License Portal tab you opened [from the earlier configuration](#configure-sso-in-bruno)\n6. Under **SAML Configuration** paste the certificate contents into the **IdP Certificate** field\n\n\n\n\nStep 3: Map the role values from Okta to Bruno access levels\n\n\n1. Under the Bruno License Portal in the SSO Configuration page, scroll down to the **Role Mapping** section\n2. **Admin Roles**: Enter the role values (comma-separated) that should have admin access to Bruno\n   - Example: `admin,BrunoAdmin,IT-Administrators`\n   - These values must match what you configured in the `roles` attribute in Okta\n   - Users with these roles can access the admin panel and manage licenses\n\n3. **User Roles**: Enter the role values (comma-separated) that should have user access to Bruno\n   - Example: `user,Engineering,Developers,QA`\n   - These values must match what you configured in the `roles` attribute in Okta\n   - Users with these roles will be able to activate their Bruno licenses with SSO. **They will not have access to the admin panel.**\n\n\n\n\n**How Role Mapping Works:**\n\nThe role value you configured in Okta's `roles` attribute statement will be sent in the SAML assertion. Bruno will check if this value matches any role in the \"Admin Roles\" or \"User Roles\" fields.\n\n**Example:**\n- In Okta, you set the `roles` attribute to `\"Engineering\"`\n- In Bruno Admin Roles, you enter: `admin,BrunoAdmin`\n- In Bruno User Roles, you enter: `user,Engineering,QA`\n- Result: Users with the `Engineering` role are able to activate their Bruno licenses with SSO (matches \"Engineering\" in User Roles)\n\n\n\n**Important**: Role values are case-sensitive. Ensure the values in Okta's `roles` attribute match exactly with the values you enter in Bruno's Admin Roles or User Roles fields.\n\n\nStep 4: Configure Session Settings\n\n\n1. Scroll down to the **Session Timeout** section:\n   - Set the session timeout in seconds (default: 3600 = 1 hour)\n2. Click **Save Configuration** to apply your SAML SSO configuration\n\n\n\n{/* TODO: Add screenshot - bruno-role-mapping.png\n     Shows the role mapping configuration in Bruno\n     Alt text: \"Configure role mapping in Bruno License Portal\" */}\n\nTest Your SAML Configuration\n\n\nAssign Users or Groups\n\n\n1. In your Okta Bruno application, navigate to the **Assignments** tab\n2. Click **Assign** â†’ **Assign to People** or **Assign to Groups**\n   - **Note**: Users assigned must already exist in your subscription under the Bruno License Portal in order to login with SSO\n3. Select the users or groups that should have access to Bruno\n4. Click **Assign** and **Done**\n\n\n\nTest SSO Login\n\n\n1. Navigate to the Bruno License Portal (\n2. Enter the email address of a user assigned to the Bruno app in Okta\n3. Click **Login with SSO**\n4. You should be redirected to Okta to authenticate\n\n\n\n5. If your user is an admin in Bruno and contains the correct role mapping, you should be redirected back to the Bruno License Portal\n\n\nNext Steps\n\n\nAfter setting up SSO with Okta, you can:\n\n- [Configure SCIM Provisioning](../scim-provisioning/overview) to automate user provisioning and deprovisioning\n- [Manage your Bruno licenses](../license-portal) in the License Portal\n\nRelated Resources\n\n\nFor more information about configuring SAML SSO and managing attributes in Okta, refer to these Okta documentation resources:\n\n- [SAML app integrations]( - Overview of SAML protocol and Okta SAML applications\n- [Create SAML app integrations]( - Step-by-step guide for creating SAML applications in Okta\n- [Define attribute statements]( - Configure SAML attribute statements for user attributes and roles\n- [Define group attribute statements]( - Map Okta groups to SAML attributes for role-based access control\n- [Application Integration Wizard SAML field reference]( - Reference guide for SAML configuration fields\n- [Build a Single Sign-On (SSO) integration]( - Developer guide for building SAML SSO integrations\n",
    "parentName": "license-administrators",
    "path": "license-administrators/saml-sso/configure-saml-sso-with-okta"
  },
  "license-administrators/saml-sso/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\nimport Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\n\nSAML Single Sign-On (SSO) Overview \n\n\n\nSAML SSO is available for Ultimate Edition customers behind a feature flag. Please contact your Bruno Account Manager to enable this feature.\n\n\nWhat is SAML SSO?\n\n\nSAML (Security Assertion Markup Language) Single Sign-On allows your organization to use your existing identity provider (IdP) to authenticate users accessing Bruno. With SAML SSO, users can sign in to Bruno using their corporate credentials without needing a separate Bruno password.\n\nBenefits of SAML SSO with Bruno\n\n\nCentralized Authentication\n\n- **Single set of credentials**: Admins and users access Bruno with the same credentials they use for other corporate applications\n- **Streamlined access**: One-click access to Bruno through your identity provider's portal\n\nEnhanced Security\n\n- **Centralized access control**: Manage Bruno access through your existing identity management system\n- **Multi-factor authentication**: Leverage your IdP's MFA capabilities for Bruno access\n- **Audit trail**: Track all authentication activities in your identity provider\n- **Automatic session management**: Control session timeouts and security policies centrally\n\nOperational Efficiency\n\n- **Simplified onboarding**: New employees automatically receive Bruno Ultimate access as part of their standard onboarding\n- **Simplified offboarding**: Departing employees automatically lose Bruno Ultimate access when removed from your IdP\n- **Reduced administrative overhead**: IT teams spend less time on manual user management\n\nSupported Identity Providers\n\n\nBruno supports SAML 2.0 SSO with the following identity providers:\n\n- **Okta** - [Configuration Guide](./configure-saml-sso-with-okta)\n- **Microsoft Entra ID (Azure AD)** - [Configuration Guide](./configure-saml-sso-with-entra-id)\n- **Generic SAML 2.0 providers** - Any SAML 2.0 compliant identity provider\n\nPrerequisites\n\n\nBefore configuring SAML SSO, ensure you have:\n\n- **Ultimate Edition subscription** with SAML SSO feature enabled\n- **Admin access** to the Bruno License Portal (`\n- **Admin access** to your identity provider (Okta, Entra ID, etc.)\n\nGeneral Setup Flow\n\n\nSetting up SAML SSO involves configuration in both your identity provider and Bruno:\n\n1. Configure Your Identity Provider\n\n\nIn your identity provider (Okta, Entra ID, etc.):\n- Create a new SAML application for Bruno\n- Configure the SAML settings using Bruno's ACS URL and Entity ID\n- Set up attribute mappings for user information\n- Configure role mappings for admin and user access\n- Assign users or groups to the Bruno application\n\n2. Configure Bruno\n\n\nIn the Bruno License Portal:\n- Navigate to Settings â†’ SSO\n- Toggle **Enable SSO** to on\n- Enter your IdP's SAML metadata (Entity IDLogin URL, Certificate)\n- Configure **Role Mapping** to match your IdP's role attributes\n- Set session timeout preferences\n- Save Configuration\n\n3. Test and Verify\n\n\n- Test SSO login with a test user account\n- Verify user attributes are correctly mapped\n- Confirm role assignments work as expected\n- Test session timeout behavior\n\nSAML Configuration Values\n\n\nWhen configuring your identity provider, you'll need these Bruno-specific values:\n\n| Field | Value | Notes |\n|-------|-------|-------|\n| **ACS URL** | Specific to your Bruno subscription | Copy the exact SAML ACS URL from your Bruno SSO settings page. Format: ` |\n| **SP Issuer ID / Entity ID** | Enter a unique value | Can be any unique identifier (e.g., `bruno`, `bruno-demo`). Must match exactly between Bruno and your IdP |\n\n\n**Important**: Always copy the ACS URL and SP Issuer ID / Entity ID directly from your Bruno SSO settings page. The Entity ID can be any unique value you choose, but it must match exactly between Bruno and your identity provider.\n\n\n{/* TODO: Add screenshot of Bruno SAML settings page showing where to find domain-id */}\n\nRequired SAML Attributes\n\n\nBruno requires the following SAML attributes to be configured in your identity provider. These attributes are sent in the SAML assertion and used to provision and manage user access:\n\nUser Attributes\n\n\n| Attribute Name | Description | Example Value |\n|----------------|-------------|---------------|\n| **NameID** | User's email address (unique identifier) | `user.mail` or `user.email` - Must be in email format |\n| **roles** | User role(s) for access control | Any role value from your IdP (e.g., `BrunoAdmin`, `Engineering`, `admin`, `user`) |\n| **fullName** | User's full name | `user.firstName+\" \"+user.lastName` or equivalent |\n\n\n**Attribute Configuration Details:**\n\n- **NameID**: Bruno uses the NameID as the unique user identifier and email address. Configure your IdP to send the user's email address as the NameID with format `urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress`. This is critical for user identification and license activation.\n\n- **roles**: This attribute contains the role value(s) from your identity provider. The value can be:\n  - Any existing role or group attribute from your IdP (e.g., `Engineering`, `BrunoAdmin`, `IT-Team`)\n  - A hardcoded value for testing purposes (e.g., `admin`, `user`)\n  - Mapped from existing user attributes or group memberships in your IdP\n\n  **Important**: The role values sent in the SAML assertion must be mapped to either \"Admin Roles\" or \"User Roles\" in the Bruno License Portal's SSO Settings (see [Role Mapping](#role-mapping) section below).\n\n- **fullName**: This attribute should contain the user's complete name. It can be mapped to:\n  - A single field if your IdP has a combined name field\n  - A concatenation of first and last name fields (e.g., `user.firstName+\" \"+user.lastName`)\n  - Any existing user property in your IdP that contains the full name\n\n\nExample SAML Assertion\n\n\nHere's an example of how these attributes appear in a SAML assertion:\n\n```xml\n\n  \n    admin\n  \n  \n    user.firstName+\" \"+user.lastName\n  \n\n```\n\n\n**Important**: Both attributes must be configured in your identity provider for SAML SSO to work correctly. The attribute names are case-sensitive and must match exactly as shown above.\n\n\nRole Mapping\n\n\nAfter configuring the `roles` attribute in your identity provider, you need to map those role values to Bruno access levels in the License Portal.\n\nConfiguring Role Mapping in Bruno\n\n\nIn the Bruno License Portal's SSO Settings, you'll find two fields under \"Role Mapping\":\n\n1. **Admin Roles**: Comma-separated list of role values that should have admin access\n   - Example: `admin,BrunoAdmin,IT-Administrators`\n   - Users with these roles can access the admin panel and manage licenses\n\n2. **User Roles**: Comma-separated list of role values that should have user access\n   - Example: `user,Engineering,Developers`\n   - Users with these roles have standard access to Bruno\n\n\n\n\n**How Role Mapping Works:**\n\n1. Your IdP sends the `roles` attribute value in the SAML assertion (e.g., `Engineering`)\n2. Bruno checks if this value matches any role in the \"Admin Roles\" or \"User Roles\" fields\n3. If it matches \"Admin Roles\", the user will be able to access the license portal and manage licenses\n4. If it matches \"User Roles\", the user will be able to activate their license with SSO but will not have license portal access\n5. If it doesn't match either, the user will be denied access\n\n**Example Configuration:**\n- IdP sends: `roles=\"Engineering\"`\n- Bruno Admin Roles: `admin,BrunoAdmin`\n- Bruno User Roles: `user,Engineering,QA`\n- Result: User gets standard access (matches \"Engineering\" in User Roles)\n\n**Important Implementation Details:**\n- Role matching is **case-sensitive** - `admin` â‰  `Admin`\n- A user can have multiple roles in the IdP; Bruno checks if **any** of them match the configured roles\n- If a user matches \"Admin Roles\", they get admin access (even if they also match \"User Roles\")\n- When a user is removed from the IdP, they lose access on their next login attempt\n\n\n\n**Important**: The role values are case-sensitive. Ensure the values in your IdP's `roles` attribute match exactly with the values you configure in Bruno's Admin Roles or User Roles fields.\n\n\nLicense Activation and Access Control\n\n\nLicense Activation Flow\n\n\n**For User Role Users:**\n- Users can activate their Bruno license using SSO\n- They receive a license key via email on first login\n- They can use this key to activate Bruno on their local machine\n- They do NOT have access to the License Portal\n\n**For Admin Role Users:**\n- Admins can access the License Portal to manage licenses and users\n- Admins can view all users in their subscription\n- Admins can manage role mappings and SSO configuration\n- Admins can view subscription details and usage\n\nSession Management\n\n\n- **Session timeout**: Configured in Bruno SSO settings (default: 1 hour / 3600 seconds)\n- **Minimum timeout**: 60 seconds\n- **Session cookies**: Secure, HTTP-only cookies are used for session management\n- **Logout**: Users are logged out when the session expires or when they manually log out\n\n\n**Coordination with IdP Sessions**: Bruno's session timeout is independent of your IdP's session timeout. The shorter timeout will take precedence. For example, if your IdP session expires after 30 minutes but Bruno is set to 1 hour, users will be logged out after 30 minutes.\n\n\nNext Steps\n\n\nReady to configure SAML SSO? Choose your identity provider:\n\n- [Configure SAML SSO with Okta](./configure-saml-sso-with-okta) - Complete setup guide for Okta\n- [Configure SAML SSO with Entra ID](./configure-saml-sso-with-entra-id) - Complete setup guide for Microsoft Entra ID\n\nNeed help? See our [Troubleshooting Guide](./troubleshooting) for common issues and solutions.\n\n",
    "parentName": "license-administrators",
    "path": "license-administrators/saml-sso/overview"
  },
  "license-administrators/saml-sso/troubleshooting": {
    "name": "troubleshooting",
    "content": "import { Callout } from \"nextra/components\";\n\nSAML SSO Troubleshooting\n\n\nThis guide helps you diagnose and resolve common issues when configuring or using SAML Single Sign-On with Bruno.\n\nQuick Pre-Flight Checks\n\n\nBefore diving into technical troubleshooting, verify these basic prerequisites. Most SSO login failures are due to one of these issues:\n\n1. Is SSO Enabled in Bruno?\n\n\n**Check this first:**\n- Go to Bruno License Portal (`\n- Navigate to **Settings** â†’ **SSO**\n- Verify the **\"Enable SSO\"** toggle is **ON**\n- If it's OFF, toggle it ON and click **Save Configuration**\n\n**Why this matters**: If SSO is disabled, all SSO login attempts will fail with a 500 error.\n\n\n**Important**: SSO must be enabled in the License Portal before users can log in via SSO. This is the first and most common cause of SSO login failures.\n\n\n2. Is the User Already an Admin in Bruno License Portal?\n\n\nAccessing the license portal requires admin access. Users will not need to be added as admins if they only need to activate their license via SSO.\n\n**Check this next:**\n- Go to Bruno License Portal â†’ **Settings** â†’ **Admins**\n- Look for the user's email address in the Admins list\n- If the user is NOT in the list, they must be added first before they can use SSO\n\n**Why this matters**: Users must be configured as admins in Bruno BEFORE they can log in via SSO. SSO only authenticates users who are already admins in the system.\n\n**If the user is not listed:**\n1. Click the **\"Add Admin\"** button\n2. Enter the user's email address\n3. Click **Add**\n4. The user will now be able to log in via SSO\n\n**After the user is added as an admin, verify role mapping:**\n- Go to Bruno License Portal â†’ **Settings** â†’ **SSO**\n- Look at the **\"Admin Roles\"** field\n- The user's role (from their IdP) must match one of the values in this field\n- **Example**: If Admin Roles is set to `admin,BrunoAdmin`, the user's role must be exactly `admin` or `BrunoAdmin`\n\n**How to verify the user's role:**\n1. In your IdP, check what role value is assigned to the user\n2. In Bruno License Portal â†’ Settings â†’ SSO, check the \"Admin Roles\" field\n3. Ensure they match exactly (case-sensitive)\n\n\n**Two-Step Process**:\n1. First, add the user as an admin in Bruno License Portal (Settings â†’ Admins)\n2. Then, ensure their IdP role matches the \"Admin Roles\" field in SSO settings\n\nBoth steps are required for SSO login to work.\n\n\n\n**Role Matching is Case-Sensitive**: `admin` â‰  `Admin`. The role value from your IdP must match exactly what's in the Admin Roles field.\n\n\n3. Is SSO Configuration Complete?\n\n\n**Verify all required fields are filled:**\n- Go to Bruno License Portal â†’ **Settings** â†’ **SSO**\n- Check that these fields are NOT empty:\n  - **SP Issuer ID / Entity ID**\n  - **IdP Login URL**\n  - **IdP Entity ID**\n  - **IdP Certificate**\n  - **Admin Roles** (at least one role value)\n\n**Why this matters**: If any required field is missing, Bruno cannot generate a SAML request and will return a 500 error.\n\n\n**Tip**: If you're not sure what values to use, refer to the [SAML SSO Overview](./overview) page for detailed explanations of each field.\n\n\n---\n\nCommon Error Messages\n\n\n\"500 Internal Server Error\" When Clicking \"Login with SSO\"\n\n\n**First, complete the pre-flight checks above** (Is SSO enabled? Is the user an admin? Is configuration complete?)\n\n**Possible Causes:**\n- SSO is not enabled in Bruno (see Pre-Flight Check #1)\n- User is not a License Manager Admin (see Pre-Flight Check #2)\n- SSO configuration is incomplete (see Pre-Flight Check #3)\n- Entity ID mismatch between Bruno and your IdP\n- Invalid or malformed certificate in Bruno configuration\n- IdP Login URL is missing or incorrect\n\n**What This Error Means:**\nThis error occurs when Bruno tries to generate a SAML authentication request but the SSO configuration is incomplete or invalid. The backend checks that all required fields are present before proceeding.\n\n**Solutions:**\n\n1. **Complete the pre-flight checks first**:\n   - Verify SSO is enabled\n   - Verify the user is a License Manager Admin (role matches Admin Roles)\n   - Verify all required configuration fields are filled\n\n2. **Verify Entity ID matches exactly**:\n   - The \"SP Issuer ID / Entity ID\" in Bruno must match the \"Identifier (Entity ID)\" in your IdP configuration\n   - Example: If Bruno has `bruno-demo`, your IdP must also have `bruno-demo`\n   - The value can be anything, but it must be identical in both places\n\n3. **Check certificate format**:\n   - Open the certificate file you downloaded from your IdP\n   - Copy the entire contents including `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` lines\n   - Paste into Bruno's IdP Certificate field\n   - Ensure there are no extra spaces or line breaks at the beginning or end\n\n4. **Verify IdP Login URL is correct**:\n   - The IdP Login URL should be the SAML entry point from your IdP\n   - Example: `\n   - This is typically found in your IdP's SAML metadata\n\n5. **Save the configuration**: Click \"Save Configuration\" button after making changes\n\n6. **Check browser console**: Open Developer Tools (F12) â†’ Console tab to see detailed error messages\n\n7. **Try disabling and re-enabling SSO**: Toggle the \"Enable SSO\" switch off, save, then toggle it back on and save again\n\n\n**Backend Validation**: Bruno validates that SSO is enabled and all required configuration fields are present before generating the SAML request. If any field is missing or SSO is disabled, you'll see a 500 error. Check the browser console for the specific error message.\n\n\nIdP Test Login Shows Error or Redirects to Bruno Login Page\n\n\n**Possible Causes:**\n- Reply URL (ACS URL) is configured incorrectly in your IdP\n- Certificate or metadata mismatch\n- SSO not fully enabled in Bruno\n\n**Solutions:**\n1. **Verify Reply URL (ACS URL)**: In your IdP's SAML application configuration:\n   - Should be: `\n   - This is where your IdP sends the SAML response after authentication\n   - The subscription ID is shown in the Bruno License Portal SSO settings page\n   - This URL must match EXACTLY what's configured in Bruno\n   - Copy this URL exactly from the Bruno SSO settings page\n3. **Ensure SSO is enabled in Bruno**:\n   - IdP test login will fail if SSO is not fully configured and enabled in Bruno\n   - Complete the Bruno SSO configuration first, then test from your IdP\n4. **Check the full error message**: The error message may be truncated. Try:\n   - Opening the test in a new incognito/private browser window\n   - Checking the browser console for the full error message\n   - Looking at the Network tab in Developer Tools for the failed request\n5. **Common error patterns**:\n   - Reply URL mismatch: Check ACS URL configuration\n   - Authentication method mismatch: Verify SAML 2.0 is configured\n   - User not assigned: Ensure user is assigned to the Bruno application\n   - Application not found: Verify application is properly configured\n\n\n**Microsoft Entra ID Specific**: If you see `AADSTS` error codes:\n- `AADSTS50011`: Reply URL mismatch - verify the ACS URL in Basic SAML Configuration\n- `AADSTS75011`: Authentication method mismatch - ensure SAML 2.0 is selected\n- `AADSTS50105`: User not assigned - assign user/group to the Bruno application in Enterprise Applications\n- `AADSTS700016`: Application not found - verify the application exists and is properly configured\n- `AADSTS50020`: User account from identity provider does not exist - ensure the user is assigned to the Bruno application in Entra ID\n\n\n\n**Okta Specific**: Common Okta-specific issues:\n- **\"Invalid SAML Response\"**: Check that the Okta application's SAML settings match Bruno's requirements exactly\n- **\"User not assigned\"**: In Okta Admin â†’ Applications â†’ Bruno app â†’ Assignments, ensure users/groups are assigned\n- **\"Invalid audience\"**: Verify the Audience URI in Okta matches Bruno's SP Issuer ID exactly\n- **\"Invalid destination\"**: Ensure the Single Sign On URL in Okta matches Bruno's ACS URL\n- **Preview SAML assertion**: Use Okta's \"Preview SAML assertion\" feature to verify attribute values before testing\n\n\n\n**Testing Order**: Always complete the Bruno SSO configuration first before testing from your IdP. The recommended testing flow is:\n1. Configure SSO in Bruno and save\n2. Test login by clicking \"Login with SSO\" from Bruno's login page (SP-initiated)\n3. Once that works, test login from your IdP portal (IdP-initiated)\n\n\n\"SAML Response Validation Failed\"\n\n\n**Possible Causes:**\n- Certificate mismatch between IdP and Bruno configuration\n- Expired or invalid SAML certificate\n- Clock skew between IdP and Bruno servers\n\n**Solutions:**\n1. Verify the certificate in Bruno matches the certificate from your IdP\n2. Ensure you've copied the entire certificate including `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` lines\n3. Check that your IdP's certificate hasn't expired\n4. Verify your server's system clock is synchronized (NTP)\n\n\n**Entra ID Specific**: Entra ID certificates auto-rotate. If you see certificate validation errors:\n- Check if Entra ID has issued a new certificate (Enterprise Applications â†’ Bruno app â†’ Single sign-on â†’ SAML Certificates)\n- Download the new certificate and update it in Bruno's SSO configuration\n- Entra ID typically notifies admins 30 days before certificate expiration\n\n\n\"Invalid ACS URL\" or \"Redirect URI Mismatch\"\n\n\n**Possible Causes:**\n- Incorrect ACS URL configured in your IdP\n- Missing or incorrect domain ID in the ACS URL\n- ACS URL format doesn't match what Bruno expects\n\n**Solutions:**\n1. **Use the exact ACS URL shown in Bruno**: Copy the SAML ACS URL directly from the Bruno SSO settings page\n   - The URL format may vary depending on your Bruno version\n   - Common formats:\n     - `\n     - `\n2. Check that you've replaced `{your-domain-id}` with your actual domain ID from Bruno\n3. Ensure there are no trailing slashes or extra spaces in the URL\n4. **Important**: The ACS URL in your IdP must match EXACTLY what Bruno shows in the SSO settings page\n\n\nAlways copy the ACS URL directly from the Bruno SSO settings page rather than using the documentation examples, as the URL format may vary between Bruno versions.\n\n\n\"403 Forbidden\" Error After Successful IdP Authentication\n\n\n**Symptoms:**\n- User successfully authenticates with their IdP\n- User is redirected back to Bruno\n- Bruno shows a 403 Forbidden error or \"Access Denied\" message\n- Login does not complete\n\n**What This Error Means:**\nBruno received a valid SAML response from your IdP, but the user's roles don't match any configured role in Bruno's \"Admin Roles\" or \"User Roles\" fields. This is a **role mapping issue** - the role value sent by your IdP doesn't match what's configured in Bruno.\n\n**How Role Matching Works (Backend Logic):**\n1. Bruno extracts the `roles` attribute from the SAML response\n2. Bruno checks if ANY of the user's roles match the \"Admin Roles\" field\n3. If not, Bruno checks if ANY of the user's roles match the \"User Roles\" field\n4. If neither match, Bruno returns a 403 Forbidden error\n5. **Important**: Role matching is case-sensitive and exact (`admin` â‰  `Admin`)\n\n**Debugging Steps:**\n1. **Check the SAML response** to see what role value is being sent:\n   - Open browser dev tools (F12) â†’ Network tab\n   - Attempt SSO login again\n   - Look for the POST request to `/api/v2/auth/sso/saml/acs/`\n   - In the request payload, find the `roles` attribute value\n   - Example: `admin`\n   - Note: Users can have multiple roles; Bruno checks if ANY match\n\n2. **Verify role mapping in Bruno**:\n   - Go to Bruno License Portal â†’ Settings â†’ SSO\n   - Check the \"Admin Roles\" and \"User Roles\" fields\n   - Ensure the exact role value from the SAML response is listed in one of these fields\n   - **Important**: Role matching is case-sensitive (`admin` â‰  `Admin`)\n\n**Example Fix:**\n- If SAML response shows: `admin`\n- In Bruno Admin Roles field, add: `admin`\n- Or in Bruno User Roles field, add: `admin`\n- Click Save and test again\n\n**Other Possible Causes:**\n- Missing `roles` attribute in SAML response (not configured in IdP)\n- User not assigned to the Bruno application in IdP\n- Quotes in role values (e.g., `\"admin\"` vs `admin`)\n- Role value is empty or whitespace\n\n**Additional Checks:**\n1. **User Assignment**: Verify the user is assigned to the Bruno application in your IdP\n2. **Role Attribute Present**: Confirm the `roles` attribute is being sent in the SAML response (check Network tab)\n3. **Quote Issues**: Remove quotes from role values in your IdP configuration\n   - âŒ Bad: `\"admin\"` (with quotes)\n   - âœ… Good: `admin` (no quotes)\n4. **Empty Roles**: Ensure the role value is not empty or just whitespace\n\n\n**Okta Specific**: For 403 errors in Okta:\n- Check the **Group Assignments** tab in your Okta Bruno application - users must be assigned either directly or through groups\n- Verify **Application Visibility** settings - if \"Hide application for users\" is enabled, users may not be able to access it\n- Check **Sign On Policy** - ensure there are no conditional access rules blocking the user\n- Use Okta's **System Log** (Reports â†’ System Log) to see detailed authentication attempts and failures\n\n\n\n**Entra ID Specific**: For 403 errors in Entra ID:\n- Check **Users and groups** assignment in Enterprise Applications â†’ Bruno app\n- Verify **Conditional Access policies** aren't blocking the user (Azure AD â†’ Security â†’ Conditional Access)\n- Check **User Risk Policy** and **Sign-in Risk Policy** if Identity Protection is enabled\n- Review **Sign-in logs** (Azure AD â†’ Monitoring â†’ Sign-ins) for detailed error information\n- Ensure the user's account is not disabled or requires password reset\n\n\n\n**Quick Test**: If you're unsure about role mapping, temporarily add a wildcard or common value like `user` to both Admin Roles and User Roles fields in Bruno, then check what role value your IdP is actually sending in the SAML response.\n\n\n\"User Not Found\" or \"Access Denied\" After Role Mapping\n\n\n**Symptoms:**\n- User's role matches Bruno's role mapping (403 error is gone)\n- But user still cannot access Bruno\n- Error message indicates user not found or access denied\n\n**What This Error Means:**\nThe user's role matched Bruno's configuration, but there's an issue with the user's email or account status. Bruno uses the NameID (email) from the SAML response to identify users.\n\n**How User Identification Works (Backend Logic):**\n1. Bruno extracts the NameID from the SAML response (this should be the user's email)\n2. Bruno converts the email to lowercase for consistency\n3. Bruno looks up the user in the database using this email\n4. If the user doesn't exist, Bruno creates a new user account automatically\n5. If the user exists but is inactive, Bruno reactivates them\n\n**Debugging Steps:**\n1. **Verify the NameID is an email address**:\n   - Open browser dev tools (F12) â†’ Network tab\n   - Attempt SSO login again\n   - Look for the POST request to `/api/v2/auth/sso/saml/acs/`\n   - In the SAML response, find the NameID value\n   - Example: `user@example.com`\n   - Ensure it's a valid email address\n\n2. **Check email consistency**:\n   - The NameID email should match the user's email in your IdP\n   - Bruno uses this email to identify and create user accounts\n   - If the email changes between logins, Bruno will create a new account\n\n3. **Verify user assignment in IdP**:\n   - Ensure the user is assigned to the Bruno application\n   - Check that the user's email is correctly configured in the IdP\n\n**Solutions:**\n1. Verify the user is assigned to the Bruno application in your IdP\n2. Ensure the NameID in your IdP is configured to send the user's email address\n3. Check that the user's email in the IdP is valid and consistent\n4. Verify the email attribute is correctly mapped in your IdP (should be NameID, not a separate attribute)\n\n\"Invalid Role\" or \"Insufficient Permissions\"\n\n\n**Possible Causes:**\n- `roles` attribute not configured correctly in IdP\n- `roles` attribute value doesn't match any role in Bruno's Admin Roles or User Roles fields\n- `roles` attribute is missing from the SAML assertion\n- Role mapping not configured in Bruno License Portal\n\n**Solutions:**\n1. Verify the `roles` attribute is configured in your IdP's SAML attribute statements\n2. Ensure the attribute name is exactly `roles` (case-sensitive)\n3. Check the SAML response to confirm the `roles` attribute is being sent and note its value\n4. In Bruno License Portal â†’ Settings â†’ SSO, verify that the role value from the SAML assertion is listed in either:\n   - **Admin Roles** field (for admin access), or\n   - **User Roles** field (for standard access)\n5. Ensure role values are case-sensitive matches (e.g., `Engineering` â‰  `engineering`)\n6. For your IdP: Verify the attribute/claim name is `roles` and the value matches what you configured in Bruno's role mapping\n\n\n**Okta Role Debugging**: Use Okta's **Preview SAML assertion** feature:\n1. Go to Okta Admin â†’ Applications â†’ Bruno app â†’ General tab\n2. Click **Preview SAML assertion**\n3. Select a test user to see exactly what role values will be sent\n4. Verify the `roles` attribute appears with the expected value\n5. Copy this exact value to Bruno's Admin Roles or User Roles field\n\n\n\n**Entra ID Role Debugging**: Use the **Test single sign-on** feature:\n1. Go to Enterprise Applications â†’ Bruno app â†’ Single sign-on\n2. Click **Test single sign-on with Bruno**\n3. In the test results, expand **View SAML response** to see the actual claims being sent\n4. Look for the `roles` claim and note its value\n5. Ensure this exact value is configured in Bruno's role mapping fields\n\n\n\"Missing User Information\" or \"Name Not Displayed\"\n\n\n**Possible Causes:**\n- `fullName` attribute not configured correctly in IdP\n- `fullName` attribute is missing from the SAML assertion\n- Name fields in IdP are empty\n- `firstName` and `lastName` attributes are not configured as fallback\n\n**What This Error Means:**\nBruno tries to extract the user's full name from the SAML response. If the `fullName` attribute is missing, Bruno attempts to construct it from `firstName` and `lastName` attributes. If all are missing, Bruno uses the email address as the name.\n\n**How Name Extraction Works (Backend Logic):**\n1. Bruno first looks for a `fullName` attribute in the SAML response\n2. If `fullName` is not found, Bruno looks for `firstName` and `lastName` attributes\n3. If found, Bruno combines them: `firstName + \" \" + lastName`\n4. If none of these are found, Bruno uses the email address (NameID) as the name\n5. The name is stored in the user's profile\n\n**Debugging Steps:**\n1. **Check what name attributes are being sent**:\n   - Open browser dev tools (F12) â†’ Network tab\n   - Attempt SSO login again\n   - Look for the POST request to `/api/v2/auth/sso/saml/acs/`\n   - In the SAML response, look for these attributes:\n     - `fullName` (preferred)\n     - `firstName` and `lastName` (fallback)\n   - Example: `John Doe`\n\n2. **Verify attribute names are case-insensitive**:\n   - Bruno looks for attributes case-insensitively (e.g., `fullName`, `FullName`, `FULLNAME` all work)\n   - But the attribute values are case-sensitive\n\n3. **Check user profile after login**:\n   - After a successful SSO login, check the user's profile in Bruno\n   - If the name is just an email address, the name attributes weren't found\n\n**Solutions:**\n1. **Configure `fullName` attribute** (recommended):\n   - Verify the `fullName` attribute is configured in your IdP's SAML attribute statements\n   - Configure the attribute to combine first and last name (e.g., concatenation of first name + space + last name)\n   - Check that user profiles in your IdP have first name and last name populated\n\n2. **Or configure `firstName` and `lastName` attributes** (fallback):\n   - If you can't use `fullName`, configure both `firstName` and `lastName` attributes\n   - Bruno will automatically combine them with a space\n\n3. **Verify attributes are being sent**:\n   - Check the SAML response to confirm the name attributes are being sent\n   - Use your IdP's preview/test feature to verify attribute values\n\n\n**Okta fullName Configuration**: In Okta attribute statements:\n- **Name**: `fullName`\n- **Name format**: Unspecified\n- **Value**: `user.firstName+\" \"+user.lastName`\n- Alternative: `user.displayName` if your Okta users have display names configured\n\n\n\n**Entra ID fullName Configuration**: In Entra ID claims configuration:\n- **Claim name**: `fullName`\n- **Source**: Transformation\n- **Transformation**: `Join()`\n- **Parameter 1**: `user.givenname`\n- **Separator**: ` ` (space)\n- **Parameter 2**: `user.surname`\n- Alternative: Use `user.displayname` if available and properly formatted\n\n\nConfiguration Verification Checklist\n\n\nUse this checklist to verify your SAML SSO configuration:\n\nIdentity Provider Configuration\n\n\n- [ ] SAML application created for Bruno\n- [ ] ACS URL configured correctly (copy from Bruno SSO settings page)\n- [ ] Entity ID configured to match Bruno's SP Issuer ID / Entity ID\n- [ ] Name ID format set to EmailAddress\n- [ ] **Required attribute: `roles`** configured to send user role values from your IdP (e.g., `Engineering`, `BrunoAdmin`, `IT-Team`, etc.)\n- [ ] **Required attribute: `fullName`** configured (e.g., concatenation of first and last name)\n- [ ] Users or groups assigned to the Bruno application\n- [ ] SAML certificate is valid and not expired\n\nBruno Configuration\n\n\n- [ ] SAML SSO enabled in Bruno License Portal\n- [ ] SP Issuer ID / Entity ID configured (must match IdP Entity ID exactly)\n- [ ] IdP Login URL entered correctly\n- [ ] IdP Entity ID entered correctly\n- [ ] IdP Certificate pasted correctly (including BEGIN/END lines)\n- [ ] **Admin Roles** configured with role values that should have admin access\n- [ ] **User Roles** configured with role values that should have user access\n- [ ] Role values match exactly (case-sensitive) with the values sent in the `roles` attribute from IdP\n- [ ] Session timeout configured appropriately\n\nTesting and Debugging\n\n\nTest SSO Connection\n\n\n1. In Bruno License Portal, navigate to **Settings** â†’ **SAML SSO**\n2. Click **Test SSO Connection**\n3. You should be redirected to your IdP\n4. Authenticate with your IdP credentials\n5. You should be redirected back to Bruno\n6. Verify your user information and roles are displayed correctly\n\nCheck SAML Response\n\n\nIf SSO login fails, you can inspect the SAML response to diagnose issues:\n\n1. Open your browser's developer tools (F12)\n2. Go to the **Network** tab\n3. Attempt to log in via SSO\n4. Look for the POST request to `/saml/acs/`\n5. Inspect the SAML response payload for errors\n\n\nThe SAML response contains assertions about the user's identity and attributes. Look for missing or incorrect attribute values.\n\n\nVerify Attribute Mapping\n\n\nTo verify that user attributes are being sent correctly:\n\n1. Complete a successful SSO login\n2. In Bruno, check the user's profile information\n3. Verify that the `fullName` attribute is populated correctly\n4. If attributes are missing, check your IdP's attribute mapping configuration\n5. Inspect the SAML response (see \"Check SAML Response\" section) to verify both `roles` and `fullName` attributes are present\n\nVerify Role Assignment\n\n\nTo verify that roles are being assigned correctly:\n\n1. Complete a successful SSO login\n2. Check if the user has the expected access level (admin vs. user)\n3. If roles are incorrect:\n   - Check the SAML response to see what value is being sent in the `roles` attribute\n   - Verify the `roles` attribute is configured in your IdP\n   - In Bruno License Portal â†’ Settings â†’ SSO, check the \"Admin Roles\" and \"User Roles\" fields\n   - Ensure the role value from the SAML response matches one of the values in either field (case-sensitive)\n   - Example: If SAML sends `roles=\"Engineering\"`, make sure `Engineering` is listed in either Admin Roles or User Roles in Bruno\n\nCertificate Management\n\n\nCertificate Expiration\n\n\nSAML certificates typically expire after 1-3 years. When a certificate expires:\n\n1. Generate a new certificate in your IdP\n2. Update the certificate in Bruno SAML SSO settings\n3. Test the SSO connection to verify it works\n\n\nSet a reminder to renew your SAML certificate before it expires to avoid service disruption.\n\n\nCertificate Format Issues\n\n\nIf you encounter certificate errors:\n\n1. Ensure the certificate is in PEM format (Base64 encoded)\n2. Include the `-----BEGIN CERTIFICATE-----` header\n3. Include the `-----END CERTIFICATE-----` footer\n4. Remove any extra whitespace or line breaks within the certificate body\n5. Do not include the private key (only the public certificate)\n\nSession and Timeout Issues\n\n\nUsers Being Logged Out Unexpectedly\n\n\n**Possible Causes:**\n- Session timeout set too low\n- IdP session timeout shorter than Bruno session timeout\n- Browser cookie issues\n\n**Solutions:**\n1. Increase the session timeout in Bruno SAML SSO settings\n2. Check your IdP's session timeout settings\n3. Clear browser cookies and cache\n4. Ensure cookies are enabled in the browser\n\n\n**Okta Session Management**: Check these Okta settings:\n- **Global Session Policy** (Security â†’ Authentication â†’ Global Session Policy)\n- **Application Sign On Policy** (Applications â†’ Bruno app â†’ Sign On tab â†’ Sign On Policy)\n- **Okta session lifetime** vs **Bruno session timeout** - the shorter one will take precedence\n\n\n\n**Entra ID Session Management**: Check these Entra ID settings:\n- **Conditional Access policies** with session controls (Azure AD â†’ Security â†’ Conditional Access)\n- **Token lifetime policies** (Azure AD â†’ Security â†’ Token lifetime policies)\n- **User sign-in frequency** settings in Conditional Access\n- **Persistent browser session** settings\n\n\nSession Not Ending When Expected\n\n\n**Possible Causes:**\n- Session timeout set too high\n- Browser keeping session alive\n\n**Solutions:**\n1. Decrease the session timeout in Bruno SAML SSO settings\n2. Implement IdP-initiated logout if available\n3. Educate users to log out manually when finished\n\nAttribute Configuration Troubleshooting\n\n\nSAML Attribute Configuration\n\n\n**Issue**: Users not getting correct roles or missing name information\n\n**Solutions:**\n1. **Verify the `roles` attribute is configured in your IdP**:\n   - Attribute/Claim name: `roles`\n   - Value: Can be any value (e.g., `\"admin\"`, `\"Engineering\"`, department name, group name, etc.)\n   - Ensure the attribute is included in the SAML assertion\n2. **Verify the `fullName` attribute is configured in your IdP**:\n   - Attribute/Claim name: `fullName`\n   - Value: Combination of first and last name (e.g., \"John Doe\")\n   - Common configurations:\n     - Static concatenation: `firstName + \" \" + lastName`\n     - Transformation/expression to join name fields\n     - Direct mapping from a single name field\n3. **Check attribute preview/test in your IdP** to see what values will be sent\n4. **Ensure attribute names are case-sensitive and match exactly**\n5. **Verify role mapping in Bruno**: In Bruno License Portal â†’ Settings â†’ SSO:\n   - Check that the role value from your IdP is listed in either \"Admin Roles\" or \"User Roles\"\n   - Example: If your IdP sends `roles=\"Engineering\"`, ensure `Engineering` is in one of the role fields in Bruno\n\nTesting Roles with Hardcoded Values\n\n\n**When to use this**: If you're having trouble getting role values to work correctly, you can temporarily configure a hardcoded role value in your IdP. This applies the same role to all users logging in via SSO and helps you isolate whether the issue is with role mapping or attribute configuration.\n\n**Important**: This is for testing only. Once you verify SSO is working, configure proper role values based on your user directory.\n\n**Steps to test with hardcoded roles:**\n\n1. **In your IdP, configure the `roles` attribute with a static/hardcoded value**:\n   - **Okta**: In the SAML app â†’ General â†’ SAML Attribute Statements, set:\n     - Name: `roles`\n     - Value: `admin` (or any test value)\n     - This will send `roles=\"admin\"` for all users\n\n   - **Entra ID**: In Enterprise Applications â†’ Single sign-on â†’ Attributes & Claims, add a new claim:\n     - Name: `roles`\n     - Source: Attribute\n     - Source attribute: Select any attribute (or use a static value if available)\n     - Or use Transformation with a static value like `\"admin\"`\n\n2. **In Bruno License Portal, add this test value to Admin Roles**:\n   - Go to Settings â†’ SSO\n   - In the \"Admin Roles\" field, add the value you used (e.g., `admin`)\n   - Click Save Configuration\n\n3. **Test SSO login**:\n   - Try logging in via SSO\n   - If it works, the issue is with your role attribute configuration in the IdP\n   - If it still fails, the issue is elsewhere (certificate, ACS URL, etc.)\n\n4. **Once testing is complete**:\n   - Remove the hardcoded value from your IdP\n   - Configure proper role values based on your user directory (departments, groups, etc.)\n   - Update Bruno's Admin Roles and User Roles fields with the actual role values\n\n\n**Important**: Hardcoded role values apply to ALL users logging in via SSO. Only use this for testing. Once you've verified SSO is working, configure role values that map to your actual user attributes or groups.\n\n\nCommon IdP-Specific Configurations\n\n\n**For Okta:**\n- Attribute statements with Name format: Unspecified\n- `roles` value examples: `\"admin\"`, `user.department`, static values\n- `fullName` value: `user.firstName+\" \"+user.lastName`\n\n**For Microsoft Entra ID:**\n- Claims configuration with source: Attribute or Transformation\n- `roles` value examples: static `admin`, `user.department`, group mappings\n- `fullName` transformation: Join() with `user.givenname`, space separator, and `user.surname`\n\n**For other SAML 2.0 providers:**\n- Configure SAML attribute statements or claims\n- Ensure attribute names match exactly: `roles` and `fullName`\n- Use appropriate value mappings for your user directory\n\n\n**Okta Troubleshooting Tools**: Leverage these Okta-specific debugging features:\n- **System Log** (Reports â†’ System Log): Search for authentication events and errors\n- **Preview SAML assertion**: Test attribute values before going live\n- **Application dashboard**: Monitor sign-in attempts and failures\n- **SAML Tracer browser extension**: Capture and analyze SAML requests/responses\n- **Okta Expression Language**: Use for complex attribute transformations\n\n\n\n**Entra ID Troubleshooting Tools**: Use these Entra ID-specific debugging features:\n- **Sign-in logs** (Azure AD â†’ Monitoring â†’ Sign-ins): Detailed authentication logs with error codes\n- **Audit logs** (Azure AD â†’ Monitoring â†’ Audit logs): Track configuration changes\n- **Test single sign-on**: Built-in testing tool with SAML response viewer\n- **Conditional Access insights**: See which policies are affecting sign-ins\n- **Identity Protection**: Monitor for risky sign-ins that might block SSO\n- **Enterprise Applications insights**: Application-specific usage and error analytics\n\n\nGetting Additional Help\n\n\nIf you've tried the troubleshooting steps above and still encounter issues:\n\n1. **Review Documentation**: Re-read the configuration guides for your specific IdP:\n   - [Configure SAML SSO with Okta](./configure-saml-sso-with-okta)\n   - [Configure SAML SSO with Entra ID](./configure-saml-sso-with-entra-id)\n2. **Contact [Support]( Reach out to Bruno support with the following information:\n   - Your Bruno subscription ID \n   - Identity provider (Okta, Entra ID, or other SAML 2.0 provider)\n   - Error messages you're seeing\n   - Steps you've already tried\n   - Screenshots of your configuration (redact sensitive information)\n\nRelated Resources\n\n\n- [SAML SSO Overview](./overview)\n- [Configure SAML SSO with Okta](./configure-saml-sso-with-okta)\n- [Configure SAML SSO with Entra ID](./configure-saml-sso-with-entra-id)\n- [SCIM Provisioning](../scim-provisioning/overview)",
    "parentName": "license-administrators",
    "path": "license-administrators/saml-sso/troubleshooting"
  },
  "license-administrators/scim-provisioning/bruno-scim-api": {
    "name": "bruno-scim-api",
    "content": "import { Callout } from \"nextra/components\";\n\nBruno SCIM API\n\n\nThe Bruno SCIM API provides a direct way to manage users and groups programmatically without requiring integration through identity provider applications like Okta or Microsoft Entra. This is ideal for organizations that want to build custom integrations.\n\n\n**Prerequisites**: Before using the Bruno SCIM API, you must first enable SCIM provisioning in Bruno and generate an API key. Follow the [Enabling SCIM Provisioning](./overview#enabling-scim-provisioning) section in the overview page to complete this setup and save your API key for use in the steps below.\n\n\nWho Should Use the SCIM API?\n\n\nThe Bruno SCIM API is designed for:\n\n- **Organizations with custom identity providers** that do not want to leverage a SCIM 2.0 configuration\n- **Development teams** building custom user management workflows\n- **System administrators** who need programmatic control over user provisioning\n\nAPI Collection\n\n\nBruno provides a complete API collection to help you get started quickly:\n\nðŸ“ **[Bruno SCIM API Collection](\n\n[](\n\n\n\nThis collection includes:\n- **User management** endpoints (create, read, update, delete)\n- **Group management** endpoints (create, read, update, delete)\n- **Service provider configuration** endpoints\n- **Pre-configured environments** for testing\n- **Example requests and responses** for all operations\n\nAuthentication\n\n\nAll SCIM API requests require authentication using a bearer token:\n\n```http\nAuthorization: Bearer YOUR_SCIM_API_TOKEN\n```\n\nThe bearer token is specific to your Bruno authentication domain and can be generated from the SCIM Provisioning settings in your license portal.\n\nSupported SCIM Operations\n\n\nBruno's SCIM implementation follows the SCIM 2.0 specification and supports the following operations:\n\nUser Operations\n\n\n| Operation | HTTP Method | Endpoint | Description |\n|-----------|-------------|----------|-------------|\n| Create User | `POST` | `/Users` | Provision a new user with Bruno license |\n| Get User | `GET` | `/Users/{id}` | Retrieve user information by ID |\n| Update User | `PUT` | `/Users/{id}` | Update user attributes |\n| Patch User | `PATCH` | `/Users/{id}` | Partial user updates |\n| Delete User | `DELETE` | `/Users/{id}` | Deprovision user and revoke license |\n| List Users | `GET` | `/Users` | Retrieve all users with pagination |\n| Filter Users | `GET` | `/Users?filter=...` | Search users by attributes |\n\nGroup Operations\n\n\n| Operation | HTTP Method | Endpoint | Description |\n|-----------|-------------|----------|-------------|\n| Create Group | `POST` | `/Groups` | Create a new user group |\n| Get Group | `GET` | `/Groups/{id}` | Retrieve group information by ID |\n| Update Group | `PUT` | `/Groups/{id}` | Update group attributes |\n| Patch Group | `PATCH` | `/Groups/{id}` | Partial group updates |\n| Delete Group | `DELETE` | `/Groups/{id}` | Remove group |\n| List Groups | `GET` | `/Groups` | Retrieve all groups with pagination |\n| Filter Groups | `GET` | `/Groups?filter=...` | Search groups by attributes |\n\nUser Schema\n\n\nBruno supports the following SCIM user attributes:\n\nRequired Fields\n\n- `userName` - User's email address (unique identifier)\n- `emails` - Array of email addresses (primary email required)\n- `active` - Boolean indicating if user should have access\n\nOptional Fields\n\n- `externalId` - External system identifier for the user\n- `name.givenName` - First name\n- `name.familyName` - Last name\n- `timezone` - User's timezone (IANA format, e.g., \"America/Los_Angeles\")\n- `groups` - Array of group memberships\n\nBruno-Specific Extensions\n\n- `urn:ietf:params:scim:schemas:extension:newrelic:2.0:User:nrUserType` - User type (Basic User, Core User, or Full User)\n\nGroup Schema\n\n\nBruno supports the following SCIM group attributes:\n\nRequired Fields\n\n- `displayName` - Name of the group (must be unique)\n\nOptional Fields\n\n- `members` - Array of users in the group\n- `externalId` - External system identifier for the group\n\nExample API Calls\n\n\nCreate a User\n\n\n```http\nPOST /Users\nAuthorization: Bearer YOUR_TOKEN\n\n{\n  \"schemas\": [\n    \"urn:ietf:params:scim:schemas:core:2.0:User\"\n  ],\n  \"externalId\": \"emp-12345\",\n  \"userName\": \"john.doe@company.com\",\n  \"name\": {\n    \"givenName\": \"John\",\n    \"familyName\": \"Doe\"\n  },\n  \"emails\": [{\n    \"value\": \"john.doe@company.com\",\n    \"primary\": true\n  }],\n  \"timezone\": \"America/New_York\",\n  \"active\": true,\n  \"groups\": []\n}\n```\n\nCreate a Group\n\n\n```http\nPOST /Groups\nAuthorization: Bearer YOUR_TOKEN\n\n{\n  \"schemas\": [\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\n  ],\n  \"displayName\": \"Engineering Team\",\n  \"members\": []\n}\n```\n\nUpdate User Group Membership\n\n\n```http\nPATCH /Users/{userId}\nAuthorization: Bearer YOUR_TOKEN\n\n{\n  \"schemas\": [\n    \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\n  ],\n  \"Operations\": [{\n    \"op\": \"Add\",\n    \"path\": \"groups\",\n    \"value\": [{\n      \"value\": \"{groupId}\",\n      \"display\": \"Engineering Team\"\n    }]\n  }]\n}\n```\n\nError Handling\n\n\nThe Bruno SCIM API returns standard HTTP status codes and SCIM-compliant error responses:\n\n- `200 OK` - Successful operation\n- `201 Created` - Resource created successfully\n- `204 No Content` - Successful operation with no response body\n- `400 Bad Request` - Invalid request format or missing required fields\n- `401 Unauthorized` - Invalid or missing authentication token\n- `404 Not Found` - Resource not found\n- `409 Conflict` - Resource already exists or conflict with current state\n- `500 Internal Server Error` - Server error\n\nRate Limiting\n\n\nThe Bruno SCIM API implements rate limiting to ensure service stability:\n\n- **Rate limit**: 100 requests per minute per authentication domain\n- **Burst limit**: 20 requests per 10-second window\n- **Headers**: Rate limit information is included in response headers\n\nBest Practices\n\n\nSecurity\n\n- **Secure token storage**: Store API tokens securely and rotate them regularly\n- **HTTPS only**: Always use HTTPS for API requests\n- **Minimal permissions**: Use dedicated service accounts with minimal required permissions\n\nPerformance\n\n- **Batch operations**: Use PATCH operations for bulk updates when possible\n- **Pagination**: Implement proper pagination for large result sets\n- **Caching**: Cache user and group data to reduce API calls\n\nError Handling\n\n- **Retry logic**: Implement exponential backoff for transient errors\n- **Logging**: Log all API interactions for debugging and audit purposes\n- **Validation**: Validate data before sending API requests\n\nGetting Started\n\n\n1. **Download the collection**: Clone or download the [Bruno SCIM API Collection](\n2. **Configure environment**: Set up your base URL and API token in the environment variables\n3. **Test connectivity**: Start with the Service Provider Config endpoint to verify your setup\n4. **Create test user**: Use the Create User endpoint to provision your first user\n5. **Explore operations**: Try different SCIM operations using the provided examples\n\nNext Steps\n\n\n- [Configure SCIM with Okta](./configure-scim-with-okta) - If you prefer using Okta's built-in integration\n- [SCIM Provisioning Overview](./overview) - Learn more about SCIM concepts and benefits\n",
    "parentName": "license-administrators",
    "path": "license-administrators/scim-provisioning/bruno-scim-api"
  },
  "license-administrators/scim-provisioning/configure-scim-with-entra-id": {
    "name": "configure-scim-with-entra-id",
    "content": "import Image from 'next/image'\nimport { Callout } from \"nextra/components\";\n\nMicrosoft Entra ID SCIM provisioning with Bruno\n\n\nThis guide will walk you through setting up SCIM (System for Cross-domain Identity Management) provisioning with Bruno using Microsoft Entra ID (formerly Azure Active Directory).\n\n\n**Prerequisites**: Before configuring Microsoft Entra ID, you must first enable SCIM provisioning in Bruno and generate an API key. Follow the [Enabling SCIM Provisioning](./overview#enabling-scim-provisioning) section in the overview page to complete this setup and save your API key for use in the steps below.\n\n\nCreate a custom application in Microsoft Entra ID\n\n\n\n**Already have an Enterprise Application for SSO?** If you previously set up a Bruno Enterprise Application for [SAML SSO](../saml-sso/configure-saml-sso-with-entra-id), you can reuse it for SCIM provisioning. Skip to the [Configure automatic provisioning](#configure-automatic-provisioning) section to add provisioning to your existing application.\n\n\nMicrosoft Entra ID queries the Bruno SCIM endpoint every 40 minutes for assigned users, and creates or modifies them according to the assignment details you configure.\n\n1. Sign in to the [Microsoft Entra admin center](\n\n2. On the left sidebar, navigate to **Enterprise apps** â†’ **+ New application**\n\n3. Click **Create your own application**\n\n4. In the **Create your own application** panel:\n   - Enter a name for your application (e.g., \"Bruno SCIM Integration\")\n   - Select **Integrate any other application you don't find in the gallery (Non-gallery)**\n   - Click **Create**\n\n\n\nConfigure automatic provisioning\n\n\n1. In your newly created (or existing) Enterprise Application, select **Provisioning** from the left navigation menu\n\n\n\n2. In the **Provisioning Mode** dropdown, select **Automatic**\n\n3. Under **Admin Credentials**, configure the following:\n   - **Tenant URL**: `\n   - **Secret Token**: Enter the SCIM API key you generated in the [prerequisites step](./overview#enabling-scim-provisioning)\n\n\n\n4. Click **Test Connection** to verify that Microsoft Entra ID can connect to Bruno's SCIM endpoint\n5. If the test is successful, click **Save** to save the admin credentials\n\nConfigure attribute mappings\n\n\nAttribute mappings control how user data from Microsoft Entra ID is mapped to Bruno user accounts.\n\nConfigure user attribute mappings\n\n\n1. Under the **Mappings** section, click **Provision Microsoft Entra ID Users**\n\n\n\n2. Under **Target Object Actions**, ensure the following are enabled:\n   - **Create**\n   - **Update**\n   - **Delete**\n\n\n\n3. Under **Attribute Mappings**, configure the following mappings. **You must remove any existing attribute mappings that are not on this list** to avoid conflicts:\n\n   | Bruno Attribute | Microsoft Entra ID Attribute | Mapping Type | Match objects using this attribute | Apply this mapping |\n   |-----------------|------------------------------|--------------|-----------------------------------|-------------------|\n   | `userName` | `userPrincipalName` | Direct | Yes (Matching precedence: 1) | Always |\n   | `active` | `Switch([IsSoftDeleted], , \"False\", \"True\", \"True\", \"False\")` | Expression | No | Always |\n   | `displayName` | `displayName` | Direct | No | Always |\n   | `emails[type eq \"work\"].value` | `userPrincipalName` | Direct | No | Always |\n   | `name.givenName` | `givenName` | Direct | No | Always |\n   | `name.familyName` | `surname` | Direct | No | Always |\n\n\n\n\n**Important**:\n- The `userName` attribute must map to the user's email address and is used as the unique identifier\n- Set **Matching precedence** to `1` for the `userName` mapping\n- The `emails[type eq \"work\"].value` attribute must also map to `userPrincipalName` to ensure email addresses are properly provisioned\n- Remove any attribute mappings not listed above to prevent provisioning errors\n\n\n4. Click **Save** to save the attribute mappings\n\nConfigure provisioning settings\n\n\n1. Under **Settings**, configure the **Scope**:\n   - Select **Sync only assigned users and groups** to provision only users and groups explicitly assigned to the Bruno application\n   - Or select **Sync all users and groups** to provision all users in your directory\n\n2. (Optional) Under **Notification Email**, enter an email address to receive provisioning error notifications\n\n3. Set **Provisioning Status** to **On**\n\n\n\n4. Click **Save**\n\nThe initial provisioning cycle will begin immediately. Microsoft Entra ID will continue to sync every 40 minutes.\n\nAssign users and groups to Bruno\n\n\n1. In your Enterprise Application, navigate to **Users and groups** from the left navigation menu\n\n2. Click **+ Add user/group**\n\n3. Select the users or groups you want to provision with Bruno licenses\n\n4. Click **Assign**\n\n5. Assigned users will receive an email with their **License Key** once the provisioning cycle completes\n\n\n\n\n**Note**: Microsoft Entra ID syncs changes every 40 minutes. For immediate provisioning of specific users, you can use the [on-demand provisioning feature]( in Microsoft Entra ID.\n\n\n\nDeprovision users from Bruno\n\n\n1. To remove a user's access to Bruno, navigate to **Users and groups** in your Bruno application\n\n2. Select the user(s) you want to remove and click **Remove**\n\n3. The user's license will be deactivated during the next provisioning cycle (within 40 minutes), and they will receive an email notification\n\n\n\n\n\n**Note**: Microsoft Entra ID syncs changes every 40 minutes. For immediate provisioning of specific users, you can use the [on-demand provisioning feature]( in Microsoft Entra ID.\n\n\nTroubleshooting\n\n\nMonitor provisioning activity\n\n\n1. To monitor provisioning activity, navigate to **Provisioning** in your Bruno application\n\n2. Click **View provisioning logs** to see detailed information about provisioning operations\n\n3. The provisioning logs show:\n   - Users and groups that were created, updated, or deleted\n   - Any errors that occurred during provisioning\n   - Timestamps for each operation\n\n\nCommon issues\n\n\n**Connection test fails**\n- Verify the SCIM Base URL is correct: `\n- Ensure your SCIM API key is valid and hasn't been revoked\n- Check that SCIM is enabled in your Bruno license portal\n\n**Users not provisioning**\n- Verify users are assigned to the Bruno application\n- Check the provisioning logs for specific error messages\n- Ensure attribute mappings are configured correctly\n- Confirm the provisioning status is set to **On**\n\n**Duplicate user errors**\n- Ensure the `userName` attribute mapping uses a unique identifier (email address)\n- Check that no users with the same email already exist in Bruno\n\nFor additional help, [contact Bruno Support]( or visit the [Bruno SCIM API documentation](./bruno-scim-api).\n\nRelated Resources\n\n\nFor more information about configuring SCIM provisioning with Microsoft Entra ID, refer to these Microsoft documentation resources:\n\n- [SCIM synchronization with Microsoft Entra ID]( - Overview of SCIM protocol and how Microsoft Entra ID uses SCIM for provisioning\n- [What is automated app user provisioning in Microsoft Entra ID]( - Introduction to automated provisioning and SCIM\n- [Understand how Application Provisioning in Microsoft Entra ID works]( - Detailed explanation of the provisioning process and lifecycle\n- [Tutorial - Develop a SCIM endpoint for user provisioning]( - Guide for implementing SCIM endpoints and attribute mappings\n- [On-demand provisioning in Microsoft Entra ID]( - Provision specific users immediately without waiting for the sync cycle\n- [Troubleshoot provisioning to a Microsoft Entra gallery app]( - Common provisioning issues and troubleshooting steps\n- [Known issues for provisioning in Microsoft Entra ID]( - Known issues and limitations with application provisioning\n\n",
    "parentName": "license-administrators",
    "path": "license-administrators/scim-provisioning/configure-scim-with-entra-id"
  },
  "license-administrators/scim-provisioning/configure-scim-with-okta": {
    "name": "configure-scim-with-okta",
    "content": "import Image from 'next/image'\nimport { Callout } from \"nextra/components\";\n\n\nOkta SCIM provisioning with Bruno\n\n\nThis guide will walk you through setting up SCIM (System for Cross-domain Identity Management) provisioning with Bruno using Okta SWA (Secure Web Authentication).\n\n\n**Prerequisites**: Before configuring Okta, you must first enable SCIM provisioning in Bruno and generate an API key. Follow the [Enabling SCIM Provisioning](./overview#enabling-scim-provisioning) section in the overview page to complete this setup and save your API key for use in the steps below.\n\n\nCreate your Okta App\n\n\n\n**Already have an Okta App for SSO?** If you previously set up a Bruno Okta application for [SAML SSO](../saml-sso/configure-saml-sso-with-okta), you can reuse it for SCIM provisioning. Skip to the [Configure your Okta App](#configure-your-okta-app) section to add provisioning to your existing application.\n\n\n1. As an Okta admin, navigate to **Applications** and click **Create App Integration**\n\n\n\n2. Select **SWA - Secure Web Authentication** and click **Next**\n\n\n\n3. On the **Create SWA Integration** page, add the following values and click **Finish**:\n   - **App name**: (Unique App Name - e.g. Bruno SCIM Integration)\n   - **App's login page URL**: `\n\n\n\nConfigure your Okta App\n\n\n1. On your newly created application page, select the **General** tab\n2. Under **App Settings**, select **Edit**, and check the **Provisioning** option **SCIM** and click **Save**\n\n\n\n3. Return to your Okta app, select the **Provisioning** tab, under **SCIM Connection** select **Edit** and configure the following values:\n   - **SCIM connector base URL**: `\n   - **Unique identifier field for users**: `email`\n   - **Supported provisioning actions**: Check the following options:\n     - `Import New Users and Profile Updates`\n     - `Push New Users`\n     - `Push Profile Updates`\n     - `Push Groups`\n   - **Authentication**: set to **HTTP Header**\n   - Under **HTTP Header**, for **token**: add the generated API Key value from the [prerequisites step](./overview#enabling-scim-provisioning)\n\n\n\n4. Click **Test Connector Configuration**. If successful, a **Connector configured successfully** message dialogue appears.\n\n\n\n5. Click **Save** to complete the Provisioning integration.\n\n6. Under the **Provisioning** tab, select the **To Apps** setting, edit and enable the following options and click **Save**:\n   - `Create Users`\n   - `Update User Attributes`\n   - `Deactivate Users`\n\n\n\nYour SCIM integration is now complete. You can now begin [assigning users to Bruno](#assign-people-and-groups-to-bruno-in-okta).\n\nAssign people and groups to Bruno in Okta\n\n\n1. Under your created Bruno Application, navigate to the **Assignments** tab\n\n2. Select **Assign** and either **Assign to People** or **Assign to Groups** to provision Bruno license keys\n\n\n\n\n\n3. Assigned Users will receive an email with their **License Key**\n\n\n\nDeprovision users from Bruno in Okta\n\n\n1. Under your created Bruno Application, navigate to the **Assignments** tab\n\n2. Remove the desired users or groups, their license key(s) will be deactivated and they will receive an email notification\n\n\nRelated Resources\n\n\nFor more information about configuring SCIM provisioning with Okta, refer to these Okta documentation resources:\n\n- [Add SCIM provisioning to app integrations]( - Step-by-step guide for adding SCIM provisioning to Okta applications\n- [SCIM 2.0 protocol overview]( - Reference for SCIM 2.0 messages and provisioning operations\n- [On-premises provisioning with SCIM]( - Architecture and setup for SCIM provisioning\n- [Test SCIM connectors]( - Guide for testing SCIM connectors and servers\n- [Okta provisioning documentation]( - Comprehensive provisioning documentation and best practices\n",
    "parentName": "license-administrators",
    "path": "license-administrators/scim-provisioning/configure-scim-with-okta"
  },
  "license-administrators/scim-provisioning/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport Image from 'next/image';\n\nSCIM Provisioning Overview \n\n\n\nSCIM Provisioning and the SCIM API is available for Ultimate Edition customers behind a feature flag. Please contact your Bruno Account Manager to enable this feature.\n\n\nWhat is SCIM?\n\n\nSCIM (System for Cross-domain Identity Management) is an open standard that allows for the automation of user provisioning and deprovisioning between identity providers and service providers. With SCIM, organizations can automatically manage user access to Bruno based on their identity provider configurations.\n\nBenefits of SCIM with Bruno\n\n\nAutomated User Management\n\n- **Automatic provisioning**: New users are automatically granted Bruno licenses when added to your identity provider\n- **Automatic deprovisioning**: Users lose access to Bruno when removed from your identity provider\n\nEnhanced Security\n\n- **Centralized access control**: Manage Bruno access through your existing identity management system\n- **Reduced manual errors**: Eliminate manual license assignment and removal processes\n- **Audit trail**: Track all provisioning and deprovisioning activities in your identity provider\n\nOperational Efficiency\n\n- **Streamlined onboarding**: New employees automatically receive Bruno access as part of their standard onboarding\n- **Simplified offboarding**: Departing employees automatically lose Bruno access\n- **Reduced administrative overhead**: IT teams spend less time on manual license management\n\nEnabling SCIM Provisioning\n\n\nPrerequisites\n\n\nYou must have Ultimate Edition with SCIM provisioning enabled before you can configure SCIM for your Bruno team.\n\nEnabling SCIM in Bruno\n\n\n1. Navigate to the Bruno license portal: \n2. Click **Settings** in the navigation menu\n3. Select **SCIM Provisioning** from the settings page\n4. Toggle **Enable SCIM** to turn it on\n\n\n\nGenerating SCIM API Key\n\n\n1. Under **SCIM Provisioning**, note the **SCIM Base URL**: `\n2. Click **Generate New API Key**\n3. Copy your new API key for later use when configuring your identity provider - this key will not be shown again\n\n\n\nYou can revisit this page to manage your SCIM API keys. The SCIM Base URL and API key will be needed when configuring your identity provider.\n\nNext Steps\n\n\nReady to configure SCIM? Choose your integration method:\n\n- [Configure SCIM with Okta](./configure-scim-with-okta) - Complete setup guide for Okta integration\n- [Configure SCIM with Microsoft Entra ID](./configure-scim-with-entra-id) - Complete setup guide for Microsoft Entra ID integration\n- [Bruno SCIM API](./bruno-scim-api) - Direct API integration for custom implementations\n",
    "parentName": "license-administrators",
    "path": "license-administrators/scim-provisioning/overview"
  },
  "license-end-users/activate-license": {
    "name": "activate-license",
    "content": "import { Callout } from \"nextra/components\";\n\nActivating Your License\n\n\n\nYou must be on Bruno v.1.35.0 or higher to activate a license after December 1, 2024\n\n\nIf you've been provisioned a license, you should have received a license key via email. If you have not received a key and already checked your spam folder, please reach out to your license administrator.\n\nStep 1: Click on the Settings or Key icon in Bruno\n\n\nBoth icons are located at the bottom left corner of the Bruno window. The Key icon will take you directly to the `License` section. If you choose to use the Settings icon, simply select `License` from the settings menu. \n\nStep 2: Enter License Details \n\n\nEnter your license key and associated email address\n\n![login](/screenshots/license-management/activatelicense.webp)\n\n\nIf your company uses a self-hosted licensing server, select `License Server` and enter the details provided to you by your License Administrator. \n\n\nStep 4: License Activated\n\n\nOnce the license is activated, you will see a success message.\n",
    "parentName": "license-end-users",
    "path": "license-end-users/activate-license"
  },
  "license-overview": {
    "name": "license-overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nOverview\n\n\nFor our open-source users, there is no concept of license management! Simply download, install, and go!\n\nOur commercial plans have different license management aspects. If you have any questions about what plan is best suited for you, please see our [pricing page â†—]( or [contact us â†—](mailto:sales@usebruno.com) to discuss.\n\nLicense Management \n\n\nFor License Administrators\n\n\n- [License Portal](./license-administrators/license-portal)\n- [SCIM Provisioning](./license-administrators/scim-provisioning/overview)\n\nFor Users\n\n\n- [Activate License](./license-end-users/activate-license)",
    "parentName": null,
    "path": "license-overview"
  },
  "open-api/createOAS": {
    "name": "createOAS",
    "content": "import { Callout } from \"nextra/components\";\nimport PremiumBadge from \"@/components/premium-badge\";\n\nCreate OpenAPI Specification (OAS)\n\n\nBruno provides a powerful interface for creating and managing OpenAPI Specifications (OAS). You can either design a new specification from scratch and view one as existing Open API spec.\n\nViewing Existing OAS Files\n\n\nYou can view and interact with existing OAS files in Bruno using a SwaggerUI-like interface:\n\n1. Open Bruno and Go to context menu (three dots)\n2. Select **Open API Spec** from dropdown\n\n![open-open-api](/screenshots/open-api/open-api-spec.webp)\n\n3. Browse and select your OAS file (`.yaml` or `.json`)\n4. The specification will open in a dedicated section of your Bruno sidebar\n\n![view-open-api](/screenshots/open-api/view-oas-file.webp)\n\nCreating New OAS Files\n\n\n1. Open Bruno and Go to context menu (three dots)\n2. Select **Create API Spec**  from dropdown\n\n![create-open-api](/screenshots/open-api/create-api-spec.webp)\n\n3. Choose a name and location for your specification\n\n![location-open-api](/screenshots/open-api/select-api-spec-location.webp)\n\n4. Click on **Create** to generate OAS file.\n\n\nEditing Your OAS File\n\n\nOnce created, you can edit your OAS file in Bruno's built-in editor:\n\n1. The editor provides syntax highlighting\n2. Use the sidebar to navigate through different sections of your API\n3. Add or modify endpoints, parameters, and responses\n4. Include examples and descriptions for better documentation\n\n![write-api-spec](/screenshots/open-api/write-api-spec.webp)",
    "parentName": "open-api",
    "path": "open-api/createOAS"
  },
  "open-api/exportOAS": {
    "name": "exportOAS",
    "content": "import { Callout } from \"nextra/components\";\n\nExport to OpenAPI Specification (OAS)\n\n\nBruno allows you to export your collections as OpenAPI Specification (OAS) files, enabling you to share your API definitions with other tools and team members. This feature helps maintain consistency across your API documentation and development workflow.\n\n\nBruno exports collections in OpenAPI Specification (OAS) V3 format, which is widely supported by API tools and platforms.\n\n\nPrerequisites\n\n\nBefore exporting a collection, ensure:\n- Your collection is properly organized with clear request structures\n- All endpoints have appropriate HTTP methods defined\n- Request parameters and headers are properly configured\n\nExporting to a File\n\n\n1. Open Bruno and navigate to your collection\n2. Click on the context menu (three dots) in the collections panel\n3. Select **Share** from the dropdown menu\n\n![collection-settings](/screenshots/git-integration/share-collection/1-share-collection-overview.webp)\n\n4. Choose **OpenAPI Specification** option\n\n![ExportModal](/screenshots/get-started/import-export/export_collection/2-export-options.webp)\n\n5. Enter name of your file and location.\n6. Click **Create**\n\n\nExample Exported Structure\n\n\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: Example API\n  version: 1.0.0\n  description: API documentation exported from Bruno\npaths:\n  /users:\n    get:\n      summary: Get all users\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Successful response\n```",
    "parentName": "open-api",
    "path": "open-api/exportOAS"
  },
  "open-api/importOAS": {
    "name": "importOAS",
    "content": "import { Callout } from \"nextra/components\";\n\nImport OpenAPI Specification (OAS)\n\n\nBruno provides seamless integration with OpenAPI Specification (OAS), allowing you to import API definitions through both files and URLs. This feature enables you to quickly create collections in Bruno by leveraging existing OpenAPI documentation.\n\n\nBruno supports importing OpenAPI Specification (OAS) V3 files only.\n\n\nPrerequisites\n\n\nBefore importing an OpenAPI specification, ensure you have:\n- A valid OpenAPI V3 specification file (YAML or JSON format)\n- Or a publicly accessible URL containing the OpenAPI specification\n\nImport Methods\n\n\nBruno offers two ways to import OpenAPI specifications:\n\n1. **File Import**: Import from a local OpenAPI specification file\n2. **URL Import**: Import directly from a publicly accessible OpenAPI specification URL\n3. **Bruno Converter**: Programmatically convert an OAS file to a Bruno collection [by using our converter â†—.](\n\nImporting from a File\n\n\n1. Open Bruno and navigate to your collection\n2. Click on the context menu (three dots) in the collections panel\n3. Select **Import** from the dropdown menu\n4. Choose **OpenAPI** option\n\n![select-openapi-file](/screenshots/get-started/import-export/import_collection/import-modal.webp)\n\n5. Browse and select your OpenAPI specification file (`.yaml` or `.json`)\n6. Configure the import settings (see [Import Settings](#import-settings) below)\n7. Click **Import** to create the collection\n\nImporting from a URL\n\n\n1. Select **OpenAPI** and choose the URL option\n2. Provide the public URL of the OpenAPI file you're trying to import\n\n![import-openapi-url](/screenshots/get-started/import-export/import_collection/import-openapi-url-modal.webp)\n\n3. Configure the import settings (see [Import Settings](#import-settings) below)\n4. Click **Import** to create the collection\n\nAfter importing the OAS file, the sample collection will look like this:\n\n![import-collection-oas](/screenshots/open-api/import-collection-oas.webp)\n\nImport Settings\n\n\nBruno provides flexible options for organizing your imported OpenAPI collection. You can choose how to group your API endpoints into folders during the import process.\n\nFolder Arrangement Options\n\n\nWhen importing an OpenAPI specification, you can choose between two folder grouping strategies:\n\nPath-Based Grouping\n\n\nPath-based grouping organizes endpoints into folders based on their URL path structure. This approach mirrors how APIs are typically organized and provides better compatibility with Postman imports.\n\n**Example:**\n```\n/api/v1/users          â†’ /api/v1/users/ folder\n/api/v1/users/{id}     â†’ /api/v1/users/ folder\n/api/v1/orders         â†’ /api/v1/orders/ folder\n/api/v1/orders/{id}    â†’ /api/v1/orders/ folder\n```\n\nTag-Based Grouping (default)\n\n\nTag-based grouping organizes endpoints into folders based on the `tags` defined in the OpenAPI specification. This approach groups endpoints by their functional purpose as defined by the API author.\n\n**Example:**\n```\nOpenAPI spec with tags\n\npaths:\n  /users:\n    get:\n      tags: [User Management]\n  /users/{id}:\n    get:\n      tags: [User Management]\n  /orders:\n    get:\n      tags: [Order Management]\n```\n\nConfiguring Import Settings\n\n\n1. **Select Import Method**: Choose either file or URL import\n2. **Choose Folder Arrangement**: Select your preferred grouping method from the dropdown:\n   - **Paths**: Group by URL path structure\n   - **Tags** (default): Group by OpenAPI tags\n3. **Import**: Click the import button to create your collection\n\n![OpenAPI Import Dialog](/screenshots/open-api/openapi-import.webp)\n\nExample OpenAPI Specifications\n\n\nYou can test the import functionality using these example OpenAPI specifications:\n\n1. **Petstore API**:\n   - URL: `\n   - Description: A sample API for a pet store",
    "parentName": "open-api",
    "path": "open-api/importOAS"
  },
  "open-api/overview": {
    "name": "overview",
    "content": "import Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nOpenAPI and Bruno\n\n\nOpenAPI Specification (OAS) is a standard format for reading and describing HTTP APIs. This allows people to understand how an API works, how a sequence of APIs work together, generate client code, create tests, apply design standards, and more. \n\nBruno allows you to work with OpenAPI Specification (OAS) files in a number of ways:\n\n- [Creating a collection from an OAS file import](./importOAS.mdx)\n- [Exporting a collection as an OAS file](./exportOAS.mdx) \n- [Viewing and Designing an OAS file](./createOAS.mdx) ",
    "parentName": "open-api",
    "path": "open-api/overview"
  },
  "secrets-management/dotenv-file": {
    "name": "dotenv-file",
    "content": "import { FileTree } from \"nextra/components\";\n\nSecrets Management\n\n\nDotEnv File\n\n\nEnvironment variables are used to store sensitive data such as API keys, tokens, and configuration settings outside the source code. This helps keep your code secure and makes it easier to manage different settings for various environments (e.g., local, staging, production).\nIn **Bruno**, environment variables can be managed through `.env` files.\n\nDotEnv File for Secret Management\n\n\nIn **Bruno**, you can store your secrets (e.g., API keys, JWT tokens) in a `.env` file located at the **root** of your collection folder. This approach is inspired by how developers typically manage secrets in their codebase.\n\nYou **cannot** create the `.env` file directly inside Bruno. You need to manually create the `.env` file at the **root** of your Bruno collection folder to store your secrets. Once created, you can access those variables within your Bruno collection.\n\nFolder Structure Example\n\n\nBelow is an example folder structure for your collection:\n\n\n  \n    \n    \n      \n    \n    \n  \n  \n  \n  \n  \n\n\nCreating and Using the `.env` File\n\n\n1. Create a `.env` file manually in the root of your collection folder. This file will store your sensitive environment variables.\n\n2. Define your secrets in the `.env` file. For example:\n\n```bash filename=\".env\" showLineNumbers\nJWT_TOKEN=your_jwt_token_value\nAPI_KEY=your_api_key_value\n```\n\nThese secrets will be accessible in your Bruno collection via the `process.env` object.\n\n![dot env vars](/screenshots/dot-env-vars.webp)\n\nBruno will automatically load the secrets from this file and make them available to your collection via `process.env.`.\n\nYour environment file at `environments/local.bru` would look like\n\n```bash filename=\"local.bru\"\nvars {\n  baseURL: \n  JWT_TOKEN: {{process.env.JWT_TOKEN}}\n  API_KEY: {{process.env.API_KEY}}\n}\n\n```\n\nIn this example, the `JWT_TOKEN` secret from the `.env` file is referenced using `process.env.JWT_TOKEN`. This will be replaced with the actual value of `JWT_TOKEN` when the collection is executed.\n\nManaging Secrets\n\n\n1. Always add the `.env` file to your `.gitignore` file to ensure secrets are not accidentally pushed to version control.\n\n2. If you need to share the structure of your environment variables with other developers, create a `.env.sample` file without actual secret values.\n\nHandling Variables with Dots\n\n\nWhen using environment variables that contain dots in their names, use square bracket notation:\n\n```bash\nIn .env file\n\nexample.test=mysecretvalue\n```\n\n```javascript\n// In your request\n// Won't work\n\"secret\": \"{{process.env.demo.example.test}}\"\n\n// Works correctly\n\"secret\": \"{{process.env['example.test']}}\"\n```\n\nThis happens because Bruno interprets dots as object path separators. Square brackets tell Bruno to treat the entire string as a single variable name.\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/dotenv-file"
  },
  "secrets-management/overview": {
    "name": "overview",
    "content": "Secret Management\n\n\nProblem Statement\n\n\nIn any collection, there are secrets that need to be managed. These secrets can be anything such as API keys, passwords, or tokens.\n\nA common practice is to store these secrets in environment variables.\n\nThere are two ways in which developers share bruno collections:\n* Check-in the collection folder to source control (like git)\n* Export the collection to a file and share it\n\nIn both these cases we want to ensure that the secrets are stripped out of the collection before it is shared.\n\nSolution\n\n\nBruno offers three (3) approaches to manage secrets in collections.\n\n- [Secret Variables](/secrets-management/secret-variables)\n- [DotEnv File](/secrets-management/dotenv-file)\n- [Integration with a Secret Manager](/secrets-management/secret-managers)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/overview"
  },
  "secrets-management/secret-managers/aws-secrets-manager/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nAdding AWS Secrets Manager \n\n\nOverview\n\n\nAWS Secrets Manager can be integrated with Bruno to securely manage and retrieve secrets for your collections. This guide walks you through the process of adding AWS Secrets Manager as a secret provider in Bruno.\n\nConfiguration Steps \n\n\n1. **Access Secrets Manager Settings**\n   - Navigate to the application settings at the bottom of the left sidebar.\n   - Go to the **Secrets Manager** section.\n\n   ![Open Secrets Manager](/screenshots/secret-variables/aws-secret-manager/1-aws-secret-manager-dialog.webp)\n\n2. **Add a New Secret Provider**\n   - Click the `+ Add Secret Provider` button.\n   - Select **AWS Secrets Manager** as the provider type.\n\n   ![AWS Secret Manager Dialog](/screenshots/secret-variables/aws-secret-manager/2-secret-manager-option.webp)\n\n3. **Enter AWS Credentials**\n   - Fill in the required fields:\n     - **Access Key ID**\n     - **Secret Access Key**\n     - **Session Token** (if applicable)\n     - **Region**\n\n      ![Configure AWS Secrets](/screenshots/secret-variables/aws-secret-manager/3-config-aws-secrets.webp)\n\n4. **Test the Provider**\n   - Use the `Test Provider` feature to verify your connection and credentials.\n\n5. **Save the Configuration**\n   - Click `Add` to save your AWS Secrets Manager provider configuration.\n\nOnce the test is successful, click `Add` to save the secret provider configuration.\n\n---\n\nNext Steps\n\n\nOnce you have successfully added AWS Secrets Manager as a secret provider, you can:\n\n- [Configure and fetch secrets](./configuring-and-fetching-secrets) - Learn how to set up secret mappings and retrieve secrets from AWS\n- [Using secrets in Bruno](./using-secrets) - Learn how to use fetched secrets in your API requests\n\n\n\n\n\n\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/aws-secrets-manager/adding-a-secret-provider"
  },
  "secrets-management/secret-managers/aws-secrets-manager/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nConfiguring and Fetching Secrets\n\n\nOverview\n\n\nThis guide walks you through the process of configuring and fetching secrets from AWS Secrets Manager in Bruno. You'll learn how to set up secret mappings and retrieve them securely for use in your API requests.\n\n\n  Secrets in Bruno are environment-specific, so ensure you have a collection environment selected before proceeding.\n\n\nPrerequisites\n\n\n- AWS Secrets Manager provider already configured in Bruno\n- Collection environment selected\n- Appropriate AWS permissions to access secrets\n\nConfiguration Steps\n\n\nStep 1: Access Collection Secrets\n\n\n1. Open your collection in Bruno\n2. Navigate to **Collection Settings** \n3. Go to the **Secrets** section\n\nStep 2: Select AWS Secrets Manager Provider\n\n\n1. In the Secrets section, click on **Select Provider**\n2. Choose **AWS Secrets Manager** from the dropdown menu\n\n![Select AWS Secrets Manager Provider](/screenshots/secret-variables/aws-secret-manager/4-select-aws-secrets.webp)\n\nStep 3: Add Secret Mappings\n\n\n1. Click the **+ Add Secret** button to create a new secret mapping\n2. In the configuration dialog:\n   - **Name**: Enter a friendly name for the secret (this will be used in Bruno)\n   - **AWS Secret Name/ARN**: Specify the exact AWS secret name or ARN\n\n![AWS Secret Configuration Dialog](/screenshots/secret-variables/aws-secret-manager/5-aws-secret-dialog-box.webp)\n\nStep 4: Fetch Secrets from AWS\n\n\n1. Click the **Fetch Secrets** button in the top-right corner\n2. Select the appropriate AWS account from the dropdown\n3. Click **Fetch** to retrieve the secrets from AWS Secrets Manager\n\n![Fetch Secrets from AWS](/screenshots/secret-variables/aws-secret-manager/6-aws-fetch-secrets.webp)\n\nAfter successful fetching, you should see the secret values populated in the Secrets section and available for use in your requests.\n\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/aws-secrets-manager/configuring-and-fetching-secrets"
  },
  "secrets-management/secret-managers/aws-secrets-manager/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\n\nAWS Secret Manager\n\n\nAWS Secrets Manager is a secure and scalable service designed to store and retrieve sensitive information such as API keys, database credentials, and other secrets. \n\nBruno allows you to easily integrate with AWS Secrets Manager and securely access secrets during test execution without exposing them in test scripts or environment variables. \n\nThis guide provides detailed steps to configure and utilize AWS Secrets Manager in Bruno.\n\n- [Adding a secret provider](/secrets-management/aws-secrets-manager/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/aws-secrets-manager/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/aws-secrets-manager/overview"
  },
  "secrets-management/secret-managers/aws-secrets-manager/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from 'nextra/components'\n\nUsing secrets\n\n\n\nUsing Secrets in Request Fields\n\n\nSecrets are accessed in the same way as collection and environment variables. The secrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\nSecrets need to be prefixed with `$secrets` followed by the `secret name` and then the `key name`, all separated by periods.\n\n\nPattern: `$secrets`.``.``.\n\n\n\n  If you have a secret named dbCredentials with a key username, you can reference it as: `$secrets.dbCredentials.username`\n\n\nUsing Secrets in Scripts\n\n\nYou can also access secrets from within Pre-request and Post-request scripts using the `bru.getSecretVar()` function.\n\n```javascript\nconst secretValue = bru.getSecretVar('.');\nconsole.log(secretValue); // This will log the value of your secret\n\n// Example: Using AWS Secrets Manager secrets in authentication\nconst apiKey = bru.getSecretVar('aws-secrets.api-key');\nreq.setHeader('Authorization', 'Bearer ' + apiKey);\n\n```\n\nThis approach keeps your sensitive data secure while allowing you to leverage AWS Secrets Manager secrets in your API automation scripts.\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/aws-secrets-manager/using-secrets"
  },
  "secrets-management/secret-managers/azure-key-vault/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nSetting Up Azure Key Vault as a Secret Provider\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo configure Azure Key Vault as a secret provider in Bruno:\n\nAuthentication Methods\n\n\nBruno supports two authentication methods for Azure Key Vault:\n\nManual Authentication\n\n1. Navigate to the application settings, located at the bottom of the left sidebar, and go to the Secrets Manager section.\n2. Click on the `+ Add Secret Provider` button.\n3. Choose **Azure Key Vault** as the provider type.\n4. Select the **Account** tab for manual authentication.\n5. Provide the required credentials, including `Tenant ID`, `Client ID` and `Client Secret`\n6. Use the `Test Provider` feature to verify your connection.\n7. Click `Add` to save the secret provider configuration.\n\n\non Azure CLI authentication, see the [Azure CLI Authentication](/secrets-management/secret-managers/azure-key-vault/cli-authentication) guide.\n\n\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/azure-key-vault/adding-a-secret-provider"
  },
  "secrets-management/secret-managers/azure-key-vault/cli-authentication": {
    "name": "cli-authentication",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nAzure CLI Authentication\n\n\nAzure CLI authentication feature allows you to authenticate with Azure Key Vault using your existing Azure CLI session, without requiring manual entry of Tenant ID, Client ID, or Client Secret in Bruno.\n\nPrerequisites\n\n\n1. **Azure CLI Installation**: Ensure Azure CLI is installed on your system\n2. **Azure CLI Authentication**: Log in to Azure CLI using `az login`\n3. **Key Vault Access**: Ensure your Azure account has access to the target Key Vault\n\nSetup Instructions\n\n\nStep 1: Install and Configure Azure CLI\n\n\n1. Install Azure CLI from [Microsoft's official website](\n2. Open terminal/command prompt and run:\n   ```bash\n   az login\n   ```\n3. Follow the browser-based authentication process\n\n\nStep 2: Configure Secrets\n\n\n1. Navigate to the **Secrets** tab in your collection\n2. Click on **Select Provider** and select **Azure Key Vault** from dropdown.\n\n![Select Azure Key Vault Provider](/screenshots/secret-variables/azure-key-vault/1-select-azure-vault.webp)\n\n3. In the **EDIT PROVIDER** dialog:\n   - Click **+ Add Secret**\n   - Enter the **Name** for your secret\n   - Enter the **Vault Name** (your Azure Key Vault name)\n\n![Azure Key Vault Dialog Box](/screenshots/secret-variables/azure-key-vault/2-azure-dialog-box.webp)\n\n4. Click on **Save** button.\n\nStep 3: Fetch Secrets\n\n\n1. Click **Fetch Secrets** to retrieve secrets from Azure Key Vault\n2. In the **FETCH AZURE SECRETS** dialog:\n   - Select the **CLI** tab\n   - Click **Test CLI** to verify authentication\n   - Click **Fetch** to retrieve secrets\n\n![Test CLI Authentication](/screenshots/secret-variables/azure-key-vault/3-test-cli.webp)\n\n3. If successful, you'll see secrets fetched in the **Secrets** tab.\n\nBruno Azure CLI authentication for Azure Key Vault integration, eliminating the need to store credentials locally and providing a more secure authentication method.",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/azure-key-vault/cli-authentication"
  },
  "secrets-management/secret-managers/azure-key-vault/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nConfiguring and Fetching secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n  Secrets in Bruno are environment-specific, so ensure you have a collection environment selected before proceeding.\n\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n2. Select `Azure vault` as the provider.\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n5. Provide a name for the secret and specify the Vault name.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the accounts, and click on the `Fetch` button.\n\n7. The fetched secrets will be displayed in the table along with their names.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/azure-key-vault/configuring-and-fetching-secrets"
  },
  "secrets-management/secret-managers/azure-key-vault/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\n\nAzure Key Vault\n\n\nAzure Key Vault is a secure and scalable service designed to store and retrieve sensitive information such as API keys, database credentials, and other secrets. \n\nBruno allows you to easily integrate with Azure Key Vault and securely access secrets during test execution without exposing them in test scripts or environment variables. \n\nThis guide provides detailed steps to configure and utilize Azure Key Vault in Bruno.\n\n- [Adding a secret provider](/secrets-management/secret-managers/azure-key-vault/adding-a-secret-provider)\n- [Azure CLI Authentication](/secrets-management/secret-managers/azure-key-vault/cli-authentication)\n- [Configuring and fetching secrets](/secrets-management/secret-managers/azure-key-vault/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)\n\n\nBruno requires two specific permissions to be able to work with Azure Key Vault:\n- Microsoft.KeyVault/vaults/secrets/read **to read secret values**\n- Microsoft.KeyVault/vaults/secrets/readMetadata/action **to list available secrets**\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/azure-key-vault/overview"
  },
  "secrets-management/secret-managers/azure-key-vault/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from 'nextra/components'\n\nUsing secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\nUsing Secrets in Request Fields\n\n\nSecrets are accessed in the same way as collection and environment variables. The secrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\nSecrets need to be prefixed with `$secrets` followed by the `secret name` and then the `key name`, all separated by periods.\n\n\nPattern: `{{$secrets`.``.`}}`.\n\n\n\n  If you have a secret named dbCredentials with a key username, you can reference it as: `{{$secrets.dbCredentials.username}}`\n\n\nUsing Secrets in Scripts\n\n\nYou can also access secrets from within Pre-request and Post-request scripts using the `bru.getSecretVar()` function.\n\n```javascript\nconst secretValue = bru.getSecretVar('.');\nconsole.log(secretValue); // This will log the value of your secret\n\n// Example: Using Azure Key Vault secrets in authentication\nconst apiKey = bru.getSecretVar('azure-secrets.api-key');\nreq.setHeader('Authorization', 'Bearer ' + apiKey);\n```\n\n\nMake sure your Azure Key Vault secret provider is properly configured and the secrets are fetched before using them in scripts. Verify that the secret names and key names match exactly with your Azure Key Vault configuration.\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/azure-key-vault/using-secrets"
  },
  "secrets-management/secret-managers/hashicorp-vault/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nYou have the option to integrate [HashiCorp Cloud Vault â†—]( [Vault Enterprise Server â†—]( or a [Local Vault server â†—]( as your secret provider.\n\nSetting Up Vault Server\n\n\nTo configure a **Vault server** secret provider, you can opt for either **Token** or **AppRole** authentication.\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n![vault-secrets](/screenshots/secret-variables/hashicorp-vault/adding-a-secret-provider/1-secrets-home-window.webp)\n\n3. Choose **Vault Server** as the provider type and select your preferred authentication method.\n\n![vault-secrets-window](/screenshots/secret-variables/hashicorp-vault/adding-a-secret-provider/2-local-vault-secrets.webp)\n\n4. Enter ` if using a local server, or the URL of the hosted server (e.g., `\n\n5. Provide the necessary [Token â†—]( or [AppRole â†—]( credentials.\n\n6. Click on **Add** to save the secret provider.\n\n![vault-added-screen](/screenshots/secret-variables/hashicorp-vault/adding-a-secret-provider/3-added-vault.webp)\n\n\nSetting up Vault Cloud\n\n\nTo set up a **Vault Cloud** secret provider, follow these steps:\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Select **Vault Cloud** as the provider type.\n\n![vault-secrets](/screenshots/secret-variables/hashicorp-vault/adding-a-secret-provider/4-vault-cloud-setup.webp)\n\n4. Maintain the default settings for `Token Endpoint` and `Secrets Endpoint`, or modify them if necessary.\n\n5. Provide the required [Client Credentials â†—](\n\n6. Add one or more Projects (Apps) to the secret provider.\n\n7. Click on **Add** to save the secret provider.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/hashicorp-vault/adding-a-secret-provider"
  },
  "secrets-management/secret-managers/hashicorp-vault/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nConfiguring and Fetching secrets\n\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n![select-provider](/screenshots/secret-variables/hashicorp-vault/config-and-fetching-secrets/1-select-provider.webp)\n\n\n2. Select `Vault` as the provider.\n\n![vault-selected](/screenshots/secret-variables/hashicorp-vault/config-and-fetching-secrets/2-vault-selected.webp)\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n![add-secret](/screenshots/secret-variables/hashicorp-vault/config-and-fetching-secrets/3-add-secret.webp)\n\n5. Provide a name for the secret and specify the relative path to where the secret is stored in Vault.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the secret providers, and click on the `Fetch` button.\n\n![fetch-secrets](/screenshots/secret-variables/hashicorp-vault/config-and-fetching-secrets/4-fetch-secrets.webp)\n\n7. The fetched secrets will be displayed in the table along with their names and paths.\n\n![fetched-secrets](/screenshots/secret-variables/hashicorp-vault/config-and-fetching-secrets/5-get-valut-values.webp)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/hashicorp-vault/configuring-and-fetching-secrets"
  },
  "secrets-management/secret-managers/hashicorp-vault/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHashiCorp Vault\n\n\nHashiCorp Vault is a tool for managing secrets and protecting sensitive data. It is designed to provide a secure, reliable, and scalable solution for managing secrets such as API keys, passwords, certificates, and other sensitive data. Vault provides a centralized platform for storing and accessing secrets, and includes features such as encryption, access control, auditing, and more.\n\nBruno allows you to easily integrate Hashicorp Vault and access your secrets securely. With Bruno, you can securely store your Vault credentials and access them without exposing sensitive information.\n\nIn this guide, we will show you how to set up HashiCorp Vault with Bruno.\n\n- [Adding a secret provider](/secrets-management/hashicorp-vault/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/hashicorp-vault/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/hashicorp-vault/overview"
  },
  "secrets-management/secret-managers/hashicorp-vault/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from 'nextra/components'\n\nUsing secrets\n\n\n![vault-selected](/screenshots/secret-variables/hashicorp-vault/using-secrets/1-using-secrets.webp)\n\nUsing Secrets in Request Fields\n\n\nSecrets are accessed in the same way as collection and environment variables. The secrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\nSecrets need to be prefixed with `$secrets` followed by the `secret name` and then the `key name`, all separated by periods.\n\n\nPattern: `$secrets`.``.``.\n\n\n\nIf you have a secret named dbCredentials with a key username, you can reference it as: `$secrets.dbCredentials.username`\n\n\nUsing Secrets in Scripts\n\n\nYou can also access secrets from within Pre-request and Post-request scripts using the `bru.getSecretVar()` function.\n\n```javascript\nconst secretValue = bru.getSecretVar('.');\nconsole.log(secretValue); // This will log the value of your secret\n\n// Example\nconst apiKey = bru.getSecretVar('payment-service.api-key');\nreq.setHeaders('x-api-key: ' + apiKey);\n```\n\nThis approach keeps your sensitive data secure while allowing you to leverage it in your API automation scripts.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/hashicorp-vault/using-secrets"
  },
  "secrets-management/secret-managers/hashicorp-vault/using-with-cli": {
    "name": "using-with-cli",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing with Bruno CLI\n\nPre-requisites\n\n\nAdd the vault connection configuration to the collection's **secrets.json** file (create one if it doesn't exist).\nYou can use environment variables in the configuration to avoid hardcoding sensitive information.\n\nThis is the only additional configuration required to use the vault secrets in the collection using the CLI.\n\n\nUsage\n\n\nThere are 3 different CLI configurations that can be used.\n\nVault server with token authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"token\",\n        \"token\": \"{{authToken}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var authToken=your-vault-token\n```\n\n\nVault server with appRole authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"app_role\",\n        \"appRole\": {\n          \"role\": \"bruno\",\n          \"roleId\": \"{{roleId}}\",\n          \"secretId\": \"{{secretId}}\"\n        }\n      }\n    }\n  }\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var roleId=your-role-id --env-var secretId=your-secret-id\n```\n\n\nVault cloud with client credentials authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-cloud\",\n    \"vaultCloudConfig\": {\n      \"auth\": {\n        \"method\": \"client-credentials\",\n        \"clientCredentials\": {\n          \"tokenEndpoint\": \"{{tokenEndpoint}}\",\n          \"secretsEndPoint\": \"{{secretsEndpoint}}\",\n          \"clientId\": \"{{clientId}}\",\n          \"clientSecret\": \"{{clientSecret}}\"\n        }\n      },\n      \"project\": {\n        \"name\": \"{{projectName}}\",\n        \"projectId\": \"{{projectId}}\",\n        \"organizationId\": \"{{organizationId}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var tokenEndpoint=your-token-endpoint --env-var secretsEndpoint=your-secrets-endpoint --env-var clientId=your-client-id --env-var clientSecret=your-client-secret --env-var projectName=your-project-name --env-var projectId=your-project-id --env-var organizationId=your-organization-id\n```\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/hashicorp-vault/using-with-cli"
  },
  "secrets-management/secret-managers/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nIntegration with Secret managers \n\n\nFor users of Bruno Ultimate, you can take your secret management one step further and perform an integration with a secret vault. \n\nCurrently, we support integrations with:\n\n- [HashiCorp vault](secret-managers/hashicorp-vault)\n- [AWS Secrets Manager](secret-managers/aws-secrets-manager)\n- [Azure Key Vault](secret-managers/azure-key-vault)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-managers/overview"
  },
  "secrets-management/secret-masking": {
    "name": "secret-masking",
    "content": "Bruno Secret Masking in Reports\n\n\nOverview\n\n\nBruno automatically masks sensitive information in reports to protect your secrets from being exposed. This documentation explains what gets masked.\n\nWhat gets masked?\n\n\n1. Sensitive Headers (Always Masked)\n\n\nBruno automatically masks these header names regardless of their values:\n\n| Header Name | Example | Masked Result |\n|-------------|---------|---------------|\n| `Authorization` | `Bearer eyJhbGciOiJIUzI1NiIs...` | `Bearer ********` |\n| `X-API-Key` | `sk-1234567890abcdef` | `********` |\n| `Cookie` | `session=abc123; auth=xyz789` | `********` |\n| `Set-Cookie` | `session=abc123; HttpOnly` | `********` |\n| `X-Auth-Token` | `token123456` | `********` |\n| `Client-Secret` | `secret_abc123` | `********` |\n\n**Complete list of sensitive headers:**\n- `authorization`, `proxy-authorization`\n- `x-api-key`, `x-auth-token`, `x-csrf-token`, `x-xsrf-token`\n- `cookie`, `set-cookie`\n- `api-key`, `x-access-token`\n- `session-token`, `x-session-token`, `x-refresh-token`\n- `x-id-token`, `x-jwt-assertion`\n- `client-secret`, `secret-key`\n- `x-wsse`, `www-authenticate`\n\n3. Secret Environment Variables\n\n\nBruno masks all values of environment variables marked as secret in the UI:\n\n![secret masking](/screenshots/secret-masking/secret-masking.png)\n\n\n- **`db_pass` variable**: Marked as secret (blue checkmark in Secret column), so its value is masked as `****` in the interface\n- **`db_user` variable**: Not marked as secret (unchecked Secret column), so the value will be displayed in plain text\n\n\n**Result:** Every instance where `db_pass` is referenced appears masked in the report.\n\n4. External Secrets\n\n\nBruno masks secrets fetched from external providers:\n\n- **HashiCorp Vault** secrets\n- **AWS Secrets Manager** values\n- **Azure Key Vault** secrets\n\nIn .env Files\n\n\nAll values in `.env` files are treated as secrets:\n\n```env\nAPI_KEY=sk-1234567890abcdef\nCLIENT_SECRET=secret_abc123\nDATABASE_URL=postgresql://user:pass@host:5432/db\n```\n\nWhere Masking Appears\n\n\nBruno masks secrets in:\n\n- **HTML reports**\n- **JSON reports**\n- **JUnit reports**\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-masking"
  },
  "secrets-management/secret-variables": {
    "name": "secret-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nSecrets Management\n\n\nSecret Variables\n\n\n\nBruno stores secrets on your local machine. The location depends on the OS.\nThe secrets are encrypted using OS level encryption when available or falls back to AES256 encryption.\n\n\nIn this approach, you can check the `secret` checkbox for any variable in your environment.\nBruno will manage your secrets internally and will not write them into the environment file.\n\n![secret variables](/screenshots/secret-variables.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  url: \n}\nvars:secret [\n  jwt-token\n]\n\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\n\nWhen you export your collection as a file, Bruno will not export the secret variables.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-variables"
  },
  "send-requests/REST/body-data": {
    "name": "body-data",
    "content": "Body Data\n\n\nThe **Body** tab in Bruno allows you to send specific data with your API requests. You can choose from various data formats, such as Form, Raw, and others, using the dropdown menu.\n\nSend Body Data with API Requests\n\n\nYou can select the data type based on your API request requirements. For example, if you're working with a request where you need to send specific details about a particular item, youâ€™ll likely choose JSON as the data type and include the data in the body of the request.\n\nForm-Data\n\n\n1. Multipart Form\n\n\nUsed for sending files along with form data, allowing multiple parts with different content types in a single request. In multipart form data, each part of the request is separated by a boundary.\n\n1. Navigate to the **Body** tab.\n2. Select **Multipart Form** from dropdown.\n3. Click on **Add File** and upload your file.\n4. (optional) You can also select **Add Param** for sending key-value pair data.\n5. Save and execute the request.\n\n![multipart-data](/screenshots/send-request/rest/multipart-data.webp)\n\n2. URL Encoded\n\n\nIt is commonly used for simple form submissions where data is sent as key-value pairs. Each key and value are separated by an equal sign (=), and multiple pairs are separated by an ampersand (&).\n\n1. Navigate to the **Body** tab.\n2. Select **Form URL Encoded** from dropdown.\n3. Click on **Add Param** and add key-value pair.\n4. Save and execute the request.\n\n![url-encoded](/screenshots/send-request/rest/url-encoded.webp)\n\nRaw Data\n\n\nRaw Data allows you to send data in its raw, unprocessed form in the body of an API request. It doesnâ€™t require a predefined structure like key-value pairs or multi-part boundaries. Instead, you can send data exactly as it is, which is useful when dealing with structured data formats such as **JSON, XML, Sparql or plain text**.\n\n1. Navigate to the **Body** tab.\n2. In the RAW section, select your preferred data format.\n3. Add appropriate data for your API request.\n4. Save and execute the request.\n\n![raw-data](/screenshots/send-request/rest/raw-data.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/body-data"
  },
  "send-requests/REST/code-generator": {
    "name": "code-generator",
    "content": "Code Generator\n\n\nBruno makes it easy to generate code snippets from your API requests, allowing you to quickly integrate and test your API in various programming languages. This feature supports multiple languages (35+) and can help you save time when writing client code for your API.\n\nHow Code Snippets Work in Bruno\n\n\nBrunoâ€™s Code Snippet feature automatically generates the necessary code to make the same API request in various programming languages, such as **Python, JavaScript, cURL,** and others. This makes it easy to share and implement API calls directly into your application.\n\nSteps to Generate Code Snippets in Bruno\n\n\n1. Create or Open an API request.\n2. Go to the **Generate Code** Section (next to the request).\n\n![generate-code-pop-up](/screenshots/send-request/rest/generate-code-pop-up.webp)\n\n3. Select your desired programming language from the dropdown to generate the code snippet.\n\n![generate-code-options](/screenshots/send-request/rest/generate-code-options.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/code-generator"
  },
  "send-requests/REST/overview": {
    "name": "overview",
    "content": "Overview\n\n\nA REST API (Representational State Transfer) is a popular architectural style for designing APIs and web services. It enables communication between client and server through standard HTTP methods such as GET, POST, PUT, DELETE, and PATCH to transfer data.\n\nREST APIs are stateless, meaning the server does not store any information about the client between requests. This stateless nature makes REST APIs easier to maintain and scale.\n\nHTTP Methods\n\n\n| HTTP Method          | Usage                                      |\n| -------------------- | ------------------------------------------ |\n| `GET /users`         | Retrieve a list of users.                  |\n| `POST /users`        | Create a new user.                         |\n| `PUT /users/{id}`    | Update the information of a specific user. |\n| `DELETE /users/{id}` | Delete a user.                             |\n\nHTTP Status Codes\n\n\nHTTP status codes are issued by a server in response to a client's request made to the server. They provide information about the outcome of the request. Here's a table of some common HTTP status codes and their descriptions:\n\n| **Status Code** | **Description** |\n| --------------- | --------------- |\n| 100             | Informational   |\n| 200             | Successful      |\n| 300             | Redirection     |\n| 400             | Client Error    |\n| 500             | Server Error    |\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/overview"
  },
  "send-requests/REST/parameters": {
    "name": "parameters",
    "content": "Parameters\n\n\nBruno enables you to send data with your HTTP requests. You can include both query and path parameters in the request and define their corresponding values.\n\n1. [Query Parameters](#query-parameters)\n2. [Path Parameters](#path-parameters)\n\nQuery Parameters\n\n\nQuery parameters are a way to pass additional information to a server via the URL when making an HTTP request. They are commonly used in GET requests to filter, sort, or specify the data you're asking for.\n\nHow Query Parameters Work\n\n\n1. Query parameters are appended to the end of the URL after a `?` symbol.\n2. Each parameter consists of a **key-value** pair.\n3. If there are multiple query parameters, they are separated by an `&` symbol.\n\nCreate Query Parameters in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Params** tab.\n3. Enter the **Name** of the parameter and its corresponding **Value**.\n\n![create-query-params](/screenshots/send-request/rest/query-params.webp)\n\nYouâ€™ll notice that the values are appended to the URL, starting with a `?`.\nYou can choose which parameters to include or exclude by clicking the checkbox next to each one.\n\nPath Parameters\n\n\nA path parameter is a dynamic value embedded directly in the URL path of an API request. It is used to specify particular resources or data points within an API endpoint.\n\nHow Path Parameters Work\n\n\n1. Path parameters are embedded directly in the URL path.\n2. They are represented as placeholders preceded by a colon (:).\n3. When making the request, the placeholder is replaced with a dynamic value, which is part of the URL.\n\n**Example**:\n\n```bash\n\n```\n\n`:id` is a path parameter.\n\nCreate Path Parameters in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Params** tab.\n3. Add the path parameter variable in the URL. e.g. `/users/:user`\n4. Enter the value in the **path parameter** section for the corresponding variable.\n5. Save and execute the request.\n\n![path-params](/screenshots/send-request/rest/path-param.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/parameters"
  },
  "send-requests/REST/req-header": {
    "name": "req-header",
    "content": "import { Callout } from 'nextra/components'\n \nRequest headers\n\n\nRequest headers are **key-value** pairs sent along with an HTTP request to provide additional information to the server about the request. The request headers give the server more information about how to process the incoming request.\n\n**Default Headers**: Default headers are predefined headers that are part of the HTTP specification.\n\n**Custom Headers**: Custom headers are headers that are **user-defined** and are not part of the official HTTP specification.\n\nCreate request headers in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Headers** tab.\n3. Enter the **Name** of the parameter and its corresponding **Value**.\n4. Save and execute the request.\n\n![req-headers](/screenshots/send-request/rest/req-headers.webp)\n\n\n  To view default headers, navigate to the **Headers** tab in your request. For\n  custom headers, check the **Timeline** tab.\n\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/req-header"
  },
  "send-requests/REST/request-settings": {
    "name": "request-settings",
    "content": "import { Callout } from \"nextra/components\";\n\nRequest Settings\n\n\nBruno provides advanced request execution options that can be configured on a per-request basis through the **Settings** tab in the request pane. These settings allow you to fine-tune how individual requests behave during execution, overriding global or default configurations.\n\nAccessing Request Settings\n\n\n1. **Open a request** in your collection\n2. **Click on the Settings tab** in the request pane (alongside existing tabs like Headers, Body, etc.)\n3. **Configure the desired options** for your request\n\n![Request Settings Tab](/screenshots/send-request/rest/request-settings-tab.webp)\n\n\nAvailable Settings\n\n\nAutomatically Follow Redirects\n\n\nControls whether HTTP redirects should be followed automatically during request execution.\n\n**Options:**\n- **Enabled (true)**: Automatically follow redirects (default behavior)\n- **Disabled (false)**: Do not follow redirects, return the redirect response\n\nMax Redirects\n\n\nLimits the maximum number of redirects that can be followed in a single request.\n\n**Configuration:**\n- **Type**: Numeric input\n- **Range**: 1 to 50 (validation enforced)\n- **Default**: 5 redirects\n\nRequest Timeout\n\n\nSets the timeout duration for the request in milliseconds.\n\n**Configuration:**\n- **Type**: Numeric input (milliseconds)\n- **Range**: 1000 to 300000 (1 second to 5 minutes)\n- **Default**: 30000 (30 seconds)\n\nURL Encoding\n\n\nControls whether URL parameters should be automatically encoded during request execution.\n\n**Options:**\n- **Enabled (true)**: Automatically encode URL parameters (default behavior)\n- **Disabled (false)**: Do not encode URL parameters, send raw values",
    "parentName": "send-requests",
    "path": "send-requests/REST/request-settings"
  },
  "send-requests/REST/rest-api": {
    "name": "rest-api",
    "content": "import BrunoButton from '../../../components/BrunoButton';\n\nREST API request\n\n\nBruno enables you to send API requests using both HTTP and GraphQL protocols. You can include various details in the request, such as parameters, body, headers, and more, based on the API specifications.\nYou can select multiple HTTP methods such as `GET` and `POST` while working with HTTP protocol.\n\nCreate new request\n\n\n1. Create new request inside collection.\n2. Select **HTTP** as request type.\n3. Provide **URL** and **Name** in the input box.\n4. Click on **Create** button.\n\n![create-request](/screenshots/send-request/rest/create-request.webp)\n\nOnce you create the new request, you can execute it by clicking the arrow button or pressing Cmd + Enter. After executing the request, the response from the server will be displayed in the Response tab.\n\n![create-new-request](/screenshots/send-request/rest/create-new-request.webp)\n\nSelect multiple request methods\n\n\nIn Bruno, the **GET** method is set as the default HTTP method for new requests. However, you can select other HTTP methods (such as **POST**, **PUT**, **DELETE**, etc.) based on your API requirements to send data.\n\n![various-http-method](/screenshots/send-request/rest/various-http-method.webp)\n\nCustom HTTP Methods\n\n\nBruno supports custom HTTP methods beyond the standard ones (GET, POST, PUT, DELETE, etc.). This is useful for APIs that use non-standard methods like Vault's LIST method or other custom protocols.\n\nAdding a Custom HTTP Method\n\n\n1. **Expand the HTTP method dropdown** in the request pane\n2. Click **\"Add Custom\"** from the dropdown options\n3. **Type your custom method name** in the input field (e.g., `LIST`, `PATCH`, `SEARCH`)\n\n![custom-http-method](/screenshots/send-request/rest/custom-http-methods.webp)\n\nRequest Settings\n\n\nBruno provides advanced request execution options through the **Settings** tab in the request pane. You can configure per-request settings for:\n\n- **Automatically Follow Redirects**: Control whether redirects should be followed automatically\n- **Max Redirects**: Limit the number of redirects (e.g., max_redirects: 3)\n- **Request Timeout**: Set request timeout in milliseconds (e.g., timeout: 10000)\n\nThese settings override global configurations and persist per request. For detailed information, see [Request Settings](/send-requests/REST/request-settings).\n\nGet Started with REST APIs\n\n\nExplore our sample GitHub REST API collection to see practical examples and test different HTTP methods:\n\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/rest-api"
  },
  "send-requests/graphql/graphql-api": {
    "name": "graphql-api",
    "content": "import BrunoButton from '../../../components/BrunoButton';\n\nGraphQL request\n\n\nBruno provides the capability to send GraphQL requests, allowing you to interact with APIs that use the GraphQL query language.\n\nCreate GraphQL request\n\n\n1. Create new request inside collection.\n2. Select **GraphQL** as request type.\n3. Provide **URL** and **Name** in the input box.\n4. Click on **Create** button.\n\n![create-graphql-request](/screenshots/send-request/graphql/create-graphql-request.webp)\n\nThe default method for working with GraphQL APIs is POST, but you can adjust it based on your preferences.\n\nGraphQL request with query\n\n\nBruno provides a dedicated section called **Query** where you can write and execute all your GraphQL queries. This section is designed to make it easy for you to interact with the GraphQL API by allowing you to define the data you want to retrieve or manipulate.\n\n![query-graphql](/screenshots/send-request/graphql/graphql-req-query.webp)\n\n\nGet Started with GraphQL APIs\n\n\nExplore our sample REST and GraphQL collection to see practical examples and test GraphQL endpoints:\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/graphql/graphql-api"
  },
  "send-requests/graphql/graphql-variables": {
    "name": "graphql-variables",
    "content": "GraphQL Variables\n\n\nVariables in GraphQL allow you to create dynamic, reusable, and secure queries. Instead of embedding values directly in your query string, you can use variables to pass values separately. This approach offers several benefits:\n\n- **Security**: Prevents GraphQL injection attacks\n- **Reusability**: Same query can be used with different values\n- **Type Safety**: Variables are strongly typed\n- **Readability**: Makes queries cleaner and easier to understand\n\nAdding Variables to Your GraphQL Request\n\n\n1. **Create a GraphQL Request**:\n   - Open Bruno and create a new GraphQL request\n   - Select the appropriate HTTP method (usually POST)\n\n2. **Define Variables**:\n   - Go to the `Variables` section\n   - Add your variables in JSON format\n   - Each variable should match the type defined in your query\n\n  ![query-graphql](/screenshots/send-request/graphql/adding-var-graphql.webp)\n\n3. **Write Your Query with Variables**:\n   - Use the `$` prefix to declare variables\n   - Reference variables in your query using the `$variableName` syntax\n\n![query-graphql](/screenshots/send-request/graphql/using-var-in-graphql.webp)\n\n4. **Execute the Request**:\n   - Bruno will automatically combine your query and variables\n   - The variables will be properly escaped and sent with the request\n\n\n\n\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/graphql/graphql-variables"
  },
  "send-requests/graphql/overview": {
    "name": "overview",
    "content": "Overview\n\n\nBruno can send requests using GraphQL, an open-source query language and runtime for APIs.\n\nGraphQL request\n\n\nGraphQL APIs let clients request only the data they need through a single endpoint. Itâ€™s schema-driven, allowing clients to introspect and avoid overfetching or underfetching data. Each GraphQL request has a URL (the data endpoint) and a query (defining the data to retrieve or modify).\n\nThe API schema defines available fields, and the request may include authentication, headers, and settings as needed.\n\nGraphQL requests support three operations:\n\n- **Query**: Retrieves data, specifying fields and optional arguments for precise results.\n\n- **Mutation**: Modifies data (create, update, delete), with specified fields returned after the operation.\n\n- **Subscription**: Provides real-time updates by listening for changes to specific data fields over a persistent connection.\n\n1. [GraphQL API](./graphql-api.mdx)\n2. [GraphQL Variables](./graphql-variables.mdx)\n",
    "parentName": "send-requests",
    "path": "send-requests/graphql/overview"
  },
  "send-requests/grpc/grpc-proto": {
    "name": "grpc-proto",
    "content": "gRPC Proto Files\n\n\nProto files (`.proto`) are the foundation of gRPC services, defining the contract between clients and servers. Bruno supports adding proto files to enhance your gRPC development experience with better IntelliSense, method discovery, and type safety.\n\nProto File Options\n\n\nYou have two ways to add Proto files for enhanced IntelliSense and method discovery:\n\n**Option 1: Request Level**\n\n1. Open your gRPC request in Bruno\n2. In the gRPC interface, locate the **Using Reflection** section\n3. Click on the **Browse for proto file** button or toggle the proto file option\n4. Click the file browser to select `.proto` files from your local system\n\n![Request Level Proto File](/screenshots/send-request/grpc/req-level-proto-file.webp)\n\n**Option 2: Collection Level**\n\n1. Go to collection level settings\n2. Navigate to the **gRPC** tab\n3. Click the **Browse for proto files** to select `.proto` files from your local system\n\n![Collection Level Proto File](/screenshots/send-request/grpc/coll-level-proto-file.webp)\n\nAdd Proto files at the collection level for reuse across all requests.\n\nBruno will validate that the selected files are valid proto files.\nYou can add multiple proto files if your service uses imports or multiple definitions.\n\nImport Paths\n\n\nWhen working with proto files that import other proto files, Bruno will always try to resolve imports within the folder where the proto file resides. However, when working with multiple services, you may have common types (like `google/protobuf` types or shared definitions) that are used across different services. Instead of duplicating these common proto definitions in each service folder, you can use import paths to define these common types in a single location and reference them from all dependent services.\n\nAdding Import Paths\n\n\nTo configure import paths for your proto files:\n\n1. Go to **Collection Settings**\n2. Navigate to the **Protobuf** tab\n3. In the **Import Paths** section, click **Add Import Path**\n4. Specify the directory path where Bruno should look for imported proto files\n\n![gRPC Collection Level Import Path](/screenshots/send-request/grpc/grpc-collection-level-import-path.webp)\n\nHow Import Paths Work\n\n\nWhen Bruno encounters an import statement in a proto file:\n\n```protobuf\nimport \"common/user.proto\";\nimport \"google/protobuf/timestamp.proto\";\n```\n\nBruno will search for these files in the following order:\n1. The same directory as the importing proto file\n2. All specified import paths (in the order they were added)\n3. Standard protobuf library paths\n\nExample Setup\n\n\nConsider this directory structure:\n```\nmy-api/\nâ”œâ”€â”€ collection/\nâ”‚   â”œâ”€â”€ user_service.proto\nâ”‚   â””â”€â”€ order_service.proto\nâ”œâ”€â”€ shared/\nâ”‚   â”œâ”€â”€ common/\nâ”‚   â”‚   â””â”€â”€ user.proto\nâ”‚   â””â”€â”€ types/\nâ”‚       â””â”€â”€ timestamp.proto\nâ””â”€â”€ external/\n    â””â”€â”€ google/\n        â””â”€â”€ protobuf/\n            â””â”€â”€ timestamp.proto\n```\n\nTo make this work, you would add these import paths in collection settings:\n- `../shared` (for common/user.proto and types/timestamp.proto)\n- `../external` (for google/protobuf/timestamp.proto)\n\nAutomatic Import Path Management\n\n\nBruno automatically manages import paths when you add proto files at the request level:\n\n1. When you add a proto file to a request, Bruno automatically adds its directory to the collection's import paths\n2. This ensures that any imports within that proto file are properly resolved\n3. The import paths are shared across all requests in the collection\n\n![gRPC Request Level Import Path](/screenshots/send-request/grpc/grpc-req-level-import-path.webp)\n\n",
    "parentName": "send-requests",
    "path": "send-requests/grpc/grpc-proto"
  },
  "send-requests/grpc/grpc-request": {
    "name": "grpc-request",
    "content": "import {Callout} from \"nextra/components\";\n\ngRPC Request\n\n\nBruno provides comprehensive support for gRPC requests, enabling you to test and interact with gRPC services directly from the interface. With Bruno's gRPC support, you can:\n\n- **Add Proto files** for enhanced IntelliSense and method discovery\n- **Use Server Reflection** as an alternative to Proto files for automatic method suggestions\n- **Call server methods** with full parameter support and type validation\n- **Test real-time streaming APIs** including unary, server streaming, client streaming, and bidirectional streaming\n\ngRPC Interface\n\n\nBruno gRPC interface provides an intuitive way to interact with gRPC services. The interface automatically adapts based on whether you're using Proto files or Server Reflection.\n\n![gRPC Interface](/screenshots/send-request/grpc/1-grpc-interface.webp)\n\nCreating a gRPC Request\n\n\nStep 1: Create a gRPC Request\n\n\n1. Open the collection context menu and select **New Request** from the dropdown\n2. Select **gRPC** as your request type\n3. Enter the **service endpoint** in the URL field (e.g., `\n\n![Create gRPC Request](/screenshots/send-request/grpc/2-create-grpc-req.webp)\n\nStep 2: Configure the Request\n\n \n1. Click on **Reflection** and choose the **method** you want to call from the dropdown\n\n \n   **Refresh**: The gRPC refresh feature caches server information in memory for better performance. If you're running a local gRPC server and make changes to your service definitions, click the **Refresh** button next to the **Using Reflection** toggle to reload the latest changes from your server.\n\n\n2. Use the **search functionality** in the dropdown to quickly find your desired method by typing the method name\n\n![Select Method](/screenshots/send-request/grpc/3-select-method.webp)\n\nStep 3: Send the Request\n\n\n1. Add any **required inputs** in the message section (auto generate with **Auto Fill** button)\n\n2. Click the **Send** button to execute your gRPC request.\n\n![Add Message and Receive Response](/screenshots/send-request/grpc/4-add-msg-receive-resp.webp)\n\nYou'll see the response in the **Response** section with detailed information about the request execution.\n\n\nTo learn about proto files, navigate to the [Adding Proto file section.](./grpc-proto.mdx)",
    "parentName": "send-requests",
    "path": "send-requests/grpc/grpc-request"
  },
  "send-requests/grpc/grpc-streams": {
    "name": "grpc-streams",
    "content": "gRPC Streams\n\n\ngRPC streaming enables real-time, bidirectional communication between clients and servers. Bruno supports all four types of gRPC streaming patterns, allowing you to test and interact with streaming APIs efficiently.\n\nUnderstanding gRPC Streaming\n\n\ngRPC streaming allows you to send and receive multiple messages over a single connection, making it ideal for:\n- **Unary streaming** (simple request-response, CRUD operations, authentication)\n- **Client streaming** (batch processing, data collection)\n- **Server streaming** (real-time notifications, live data feeds, progress updates)\n- **Bidirectional streaming** (chat applications, collaborative editing, gaming)\n\nStreaming Workflow\n\n\nStep 1: Configure Request\n\n\n1. Open your collection and create a new gRPC request\n2. Add your gRPC server URL (e.g., `\n3. Select a streaming method from the dropdown\n\n![Select Streaming Method](/screenshots/send-request/grpc/grpc-streams/1-grpc-select-stream.webp)\n\nStep 2: Auto-Generate or Add Proto Files\n\n\nYou have two options to add message schema:\n\n**Option A: Auto-Generate Messages**\n- Bruno can auto-generate message templates based on server reflection (Click the **Auto Fill** ðŸ”„ button)\n- This works when your gRPC server has reflection enabled\n\n**Option B: Add Proto Files**\n- Upload your `.proto` files (request or collection level) for enhanced IntelliSense \n- Provides better type safety and method discovery\n\n![Auto-Fill gRPC Messages](/screenshots/send-request/grpc/grpc-streams/2-autofill-grpc-msg.webp)\n\nStep 3: Build Stream Connection\n\n\n1. **Start Stream**: Click the send button to establish the bidirectional connection\n\n![Building Stream Connection](/screenshots/send-request/grpc/grpc-streams/3-building-stream-conn.webp)\n\nStep 4: Send Multiple Messages\n\n\nOnce the stream is active:\n\n1. **Send Message**: Click the **Send gRPC Message** button to transmit your message (next to **Auto Fill** button)\n2. **Add More Messages**: Continue sending additional messages using **Add Message** \n\n![Add Multiple Messages](/screenshots/send-request/grpc/grpc-streams/4-add-multiple-msg.webp)\n\nStep 5: End Stream and View Timeline\n\n\n1. **End Message Stream**: Click the âœ“ icon (end stream button) to stop sending messages\n3. **View Response Timeline**: See the complete conversation timeline with timestamps\n\n![gRPC Response Timeline](/screenshots/send-request/grpc/grpc-streams/5-grpc-res.webp)\n\n\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/grpc/grpc-streams"
  },
  "send-requests/grpc/overview": {
    "name": "overview",
    "content": "import {Callout} from \"nextra/components\"; \nimport BrunoButton from '@/components/BrunoButton'; \n\nOverview \n\n\n\n    GRPC support is available from Bruno 2.10.0.\n\n\ngRPC (Google Remote Procedure Call) is a modern, high-performance Remote Procedure Call (RPC) framework developed by Google. It's designed for efficient communication when one service needs to interact with another. Imagine your Authentication Service needs to tell your Notification Service to send an OTP. \n\nIn a high-traffic scenario, traditional request-response calls (like REST over HTTP/1.1) can be less efficient and introduce latency. gRPC solves this by faster communication, efficient data transfer and streaming capabilities. \n\nLaunch gRPC in Bruno\n\nExplore our sample [gRPC collection]( to get started: \n\n1. Click the **Fetch in Bruno** button below \n2. Choose a location to store the collection locally and start exploring gRPC feature \n\n",
    "parentName": "send-requests",
    "path": "send-requests/grpc/overview"
  },
  "send-requests/overview": {
    "name": "overview",
    "content": "Sending Requests and Handling Responses in Bruno\n\n\nWhether you're developing your own API or testing a third-party one, you can use Bruno as an **API Testing Client** to send requests and receive responses. With Bruno, you can create, update, delete, and send data with custom parameters and authorization details.\n\nWhen you send a request and receive a response through Bruno, the interface displays the information clearly, allowing you to debug errors, handle responses, and resolve any issues efficiently.\n\n![Home Screen](/screenshots/send-request/home-screen.webp)\n\nIn the above example we are sending `Post` request to Bruno echo server with json body. The echo server will respond with same data we sent in a request as a output.\n\nGetting Started with API Requests in Bruno\n\n\nYou can send any kind of API request using Bruno mentioned below:\n\n- [REST API](./REST/overview.mdx)\n- [GraphQL API](./graphql/overview.mdx)\n- [SOAP API](./soap/soap-request.mdx)\n\nWe have plans to support gRPC, WebSocket, and MQTT.  We have a [public rolling roadmap â†—]( that includes some of the bigger items we're working on.\n",
    "parentName": "send-requests",
    "path": "send-requests/overview"
  },
  "send-requests/res-data-cookies/cookies": {
    "name": "cookies",
    "content": "import { Callout } from 'nextra/components'\n \nCookies in Bruno\n\n\nCookies are used to store user information, session data, and provide personalized content. Bruno allows you to add, send, view, and delete request cookies. After executing the request, you can easily inspect the cookies by clicking on the **Cookies** icon.\n\nCookie Attributes\n\n\n- **Domain**: Specifies the domain where the cookie is valid.\n- **Path (optional)**: Specifies the URL path where the cookie will be sent.\n- **Key**: The name/identifier of the cookie.\n- **Value**: The data that the cookie will store.\n- **Expiration**: The expiration date and time for the cookie.\n- **Secure**: Ensures the cookie is only sent over HTTPS.\n- **HTTP Only**: Restricts access to the cookie from JavaScript.\n\nConfiguring Cookies in Bruno\n\n\nAdd Cookie\n\n\n1. Go to cookies section (bottom-left).\n\n![cookie-homepage](/screenshots/send-request/res-data-and-cookie/cookies/1-cookie-homepage.webp)\n\n2. Click on **Add Cookie** button.\n\n![add-cookie-btn](/screenshots/send-request/res-data-and-cookie/cookies/2-add-cookie-btn.webp)\n\n3. Add the cookie attributes and select **Secure** or **HTTP Only** according to your preference.\n\n![cookie-attributes](/screenshots/send-request/res-data-and-cookie/cookies/3-cookie-attributes.webp)\n\n4. Click on **Save** button.\n\n5. You can enable **Raw Edit** mode to quickly customize and make direct changes to your cookies.\n\n![cookie-raw](/screenshots/send-request/res-data-and-cookie/cookies/4-raw-edit.webp)\n\nUpdate Cookie\n\n\nYou can update and delete cookie(s) by clicking the icons next to it.\n\n1. Click on (pencil icon) to update cookie.\n\n![cookie-update](/screenshots/send-request/res-data-and-cookie/cookies/8-update-cookie.webp)\n\n2. Edit values in the cookie panel.\n\n![cookie-update](/screenshots/send-request/res-data-and-cookie/cookies/7-update-cookie.webp)\n\n\n  We restrict editing of values like Domain, Path, and Key once a cookie is\n  created due to security concerns.\n\n\nDelete Cookie\n\n\n1. Click on delete icon (red colour) to delete cookie.\n\n![cookie-delete](/screenshots/send-request/res-data-and-cookie/cookies/6-delete-cookie.webp)\n\nTo manage cookies programmatically, see the [Cookie Management](/testing/script/javascript-reference#cookie-management) section in the JavaScript API Reference.",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/cookies"
  },
  "send-requests/res-data-cookies/debugging/dev-tools": {
    "name": "dev-tools",
    "content": "import { Callout } from 'nextra/components'\n\nDev Tools\n\n\nBruno provides built-in Dev Tools to help you debug your APIs, catch bugs, test functionality, and get all essential details related to your API requests. The Dev Tools feature two main tabs:\n\n1. **Console** - For testing, scripting, and debugging\n2. **Network** - For analyzing network configurations and performance\n\n\n    The Dev Tools are available in [Bruno 2.8.0]( or higher versions.\n\n\nAccessing Dev Tools\n\n\nThe Dev Tools are located in the bottom-right corner of the interface, next to the cookies button. Simply click on the Dev Tools icon to open and start using the debugging features.\n\n![Dev Tools Access](/screenshots/send-request/res-data-and-cookie/devtools/1-console-selection.webp)\n\nConsole\n\n\nThe Console tab is your primary debugging companion in Bruno. It provides a powerful environment for:\n\n- **Testing and Scripting**: Execute JavaScript code and test your API logic\n- **Debugging**: Troubleshoot API issues and scripting problems\n- **Logging**: View console outputs, errors, and debugging information\n- **Interactive Development**: Similar to browser developer tools but customized for Bruno\n\n\n![Console Interface](/screenshots/send-request/res-data-and-cookie/devtools/2-console.webp)\n\n\nNetwork\n\n\nThe Network tab provides comprehensive insights into your API requests and responses. It's essential for:\n\n- **Security Validation**: Review security headers and authentication details\n- **Request/Response Inspection**: Examine headers, body, and status codes\n- **Network Configuration**: Verify proxy settings and connection details\n- **Troubleshooting**: Identify network-related issues and errors\n\nThis tab gives you complete visibility into the network layer of your API interactions, helping you validate response data and understand the full request lifecycle.\n\n![Network Analysis](/screenshots/send-request/res-data-and-cookie/devtools/3-network.webp)\n\n\n\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/debugging/dev-tools"
  },
  "send-requests/res-data-cookies/debugging/dev-utils": {
    "name": "dev-utils",
    "content": "Dev Utils\n\n\nBruno offers powerful developer utilities to help you inspect and troubleshoot APIs. These tools are essential for debugging complex issues within Bruno.\n\n\nHow to use the Dev Utils:\n\n\n1. Open the Bruno app.\n2. Click on the **Main Menu**.\n3. Select **Bruno Dev Utils** from the dropdown menu.\n\n![console-view](/screenshots/send-request/res-data-and-cookie/devtools/dev-utils.webp)\n\nBruno DevTools offers variety of features such as:\n\nFeatures of Dev Utils:\n\n\n1. Prettify JSON\n\n\nThis feature formats and organizes your JSON data in a more readable, indented way. It helps you easily view the structure and nested elements of complex JSON responses, making it easier to debug and inspect the data.\n\n2. Convert JSON to YAML\n\n\nBruno allows you to convert JSON data into YAML format. YAML is often easier to read and work with, especially when dealing with large configurations or settings. This feature is useful for converting API responses or payloads between the two formats.\n\n3. Decode JWT\n\n\nJSON Web Tokens (JWT) are commonly used for authentication. Bruno's JWT Decoder allows you to decode and inspect the contents of a JWT, including its header, payload, and signature. This helps in debugging authentication issues by allowing you to verify the tokenâ€™s data.\n\n![chrome-console](/screenshots/send-request/res-data-and-cookie/devtools/option-dev-utils.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/debugging/dev-utils"
  },
  "send-requests/res-data-cookies/debugging/timeline": {
    "name": "timeline",
    "content": "Timeline\n\n\nThe **Timeline** tab provides detailed insights into the request's response. It includes crucial information such as the body, authentication details, variables, parameters, headers, and other necessary data to inspect and validate the expected response.\n\nAdditionally, the Timeline tab displays HTTP status codes, response time, and execution details for the request.\n\nResponse Structure\n\n\nThe Timeline tab is divided into two sections:\n\n1. **Request Section (Green)**\n2. **Response Section (Purple)**\n\n![timeline-tab](/screenshots/send-request/res-data-and-cookie/devtools/timeline/timeline.webp)\n\n1. Request Section (Green)\n\n\nThe Request section provides details about the request, including:\n\n- URL\n- Query and path variables\n- Request body (data)\n- Headers\n- Authentication details\n- Other parameters sent with the request\n\n2. Response Section (Purple)\n\n\nThe Response section provides details about the response to the request, including:\n\n- Status code\n- Execution details\n- Response headers\n- Size of the response\n\nAdditionally, we have included sample data for example in the image above to demonstrate how you can view both request and response parameters in the Timeline tab.\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/debugging/timeline"
  },
  "send-requests/res-data-cookies/overview": {
    "name": "overview",
    "content": "Response Data and Cookies\n\n\nWhen an API request is executed, the server returns response data. Bruno helps you inspect, debug, and troubleshoot APIs, and even allows you to download the response data as an HTML document. Additionally, you can manage and interact with the cookies associated with the API.\n\nResponse Data\n\n\nOnce the request is executed, Bruno displays the response data from the API. You can view the following in the response panel:\n\n- Request and response headers in the timeline\n- Response body\n- Test results\n\nYou can also:\n\n- Save response as an example for documentation\n- Clear the response data\n- View the request status code\n- View the API response in both web and raw formats\n- Export response data to file\n\nCookies\n\n\nBruno shows the cookies associated with each request. Cookies are typically used for storing user sessions and personalized content.\n\nDebugging\n\n\nBruno includes a Chrome Console and DevTools, which are valuable tools for inspecting requests and troubleshooting issues. Some useful features in DevTools include:\n\n- JSON to YAML conversion\n- JWT decoding\n- Other features to help you work through complex issues when dealing with APIs\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/overview"
  },
  "send-requests/res-data-cookies/res-data": {
    "name": "res-data",
    "content": "Response Data\n\n\nThe API returns data as a response from the server after the request is executed. The response panel in Bruno provides you with an organized view of the API's response, including the body, headers, HTTP status code, raw response code, and more.\n\nResponse Panel\n\n\nAfter executing a request, the response panel provides detailed information on the API's response. It shows the response body, headers, status code, and other relevant data. You can also search within the response using the `cmd+f` or `ctrl+f` keyboard shortcut.\n\n![Response Panel](/screenshots/send-request/res-data-and-cookie/res-data.webp)\n\nHeaders\n\n\nThe request headers are displayed to show what was sent to the API. This can help in debugging and understanding the context of the request.\n\n![Request Headers](/screenshots/send-request/res-data-and-cookie/res-headers.webp)\n\nTimeline\n\n\nThe response timeline displays the response headers sent along with the request body, including details such as content-type, date, cache, and connection status.\n\n![Response Timeline](/screenshots/send-request/res-data-and-cookie/res-timeline.webp)\n\nSave Response\n\n\nYou can save the response data for future reference in two ways:\n\nSave Response as Example\n\n\nSave the response as an example that appears as a sub-request under your main request. This is useful for documenting different API behaviors, error scenarios, and edge cases.\n\n![Save Response](/screenshots/send-request/res-data-and-cookie/save-res/save-response.webp)\n\n**Learn more:** [Response Examples](/send-requests/res-data-cookies/response-examples)\n\nExport Response to File\n\n\nYou can also export the response data to a file, allowing you to store the results in various formats such as HTML.\n\n![Save Response to File](/screenshots/send-request/res-data-and-cookie/res-save.webp)\n\nClear Response\n\n\nIf you want to reset or clear the response data, you can easily do so using the clear response option.\n\n![Clear Response](/screenshots/send-request/res-data-and-cookie/res-clear.webp)\n\nRaw Response\n\n\nThe raw response provides the unprocessed data returned by the server, giving you access to the raw output for advanced inspection.\n\n![Raw Response](/screenshots/send-request/res-data-and-cookie/res-raw.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/res-data"
  },
  "send-requests/res-data-cookies/response-examples": {
    "name": "response-examples",
    "content": "import { Callout } from \"nextra/components\";\n\nResponse Examples\n\n\nResponse examples allow you to save and document different response scenarios directly from your API requests. This feature makes it easy to capture, organize, and share various API response states without cluttering your main request.\n\n\n  Response examples are perfect for documenting success cases, error scenarios, edge cases, and different data states your API might return.\n\n\nWhat are Response Examples?\n\n\nResponse examples are saved snapshots of API responses that are stored as sub-requests under your main request. Each example captures:\n\n- **Request details**: Parameters, headers, and body used to generate the response\n- **Response data**: The complete response returned by the API\n- **Response headers**: All headers returned with the response\n\nThis makes it easy to:\n- Document different API behaviors\n- Share examples with team members\n- Test with realistic data\n- Compare responses over time\n- Maintain API documentation with real examples\n\nSaving a Response as an Example\n\n\nWhen you execute a request and receive a response, you can save it as an example for future reference.\n\nSteps to Save Response Example\n\n\n1. **Execute your request** and wait for the response\n2. **Locate the Save Response icon** in the Response tab (top-right corner)\n3. **Click the Save Response icon**\n\n![Save Response](/screenshots/send-request/res-data-and-cookie/save-res/save-response.webp)\n\n4. **Enter a name** for your example in the dialog that appears\n5. **Click Save** to create the example\n\n![Save Response Dialog](/screenshots/send-request/res-data-and-cookie/save-res/save-response-dialog.webp)\n\n\n  The example will be created as a sub-request under your main request and will be instantly accessible.\n\n\nUnderstanding Example Requests\n\n\nOnce saved, example requests appear as nested items under your main request in the sidebar.\n\n![Response Example](/screenshots/send-request/res-data-and-cookie/save-res/save-response-example.webp)\n\nExample Request Structure\n\n\nExample requests have a **simplified interface** with only the essential tabs:\n\n**Request Pane:**\n- **Params** - View the query parameters used\n- **Headers** - View the request headers sent\n- **Body** - View the request body (for POST, PUT, PATCH requests)\n\n**Response Pane:**\n- **Response** - View the saved response data\n- **Headers** - View the response headers received\n\n\n  Example requests are **read-only** by design. They serve as documentation and reference, not as executable requests.\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/response-examples"
  },
  "send-requests/soap/soap-request": {
    "name": "soap-request",
    "content": "SOAP API request\n\n\nBruno enables you to make HTTP calls using Simple Object Access Protocol (SOAP), a messaging protocol used for exchanging structured information between systems over a network. SOAP defines a standard for request-response communication and is based on XML data format.\n\nimport { Callout } from 'nextra/components'\n\n\n  **Working with WSDL files?** Bruno can automatically import WSDL files and generate SOAP request collections. Learn more in the [WSDL to Bruno Converter guide](/converters/wsdl-to-bruno).\n\n\nKey Components of a SOAP Message\n\n\n1. **Envelope**: The outermost element that defines the start and end of the message.\n2. **Header**: (Optional) Contains meta-information or additional information about the message.\n3. **Body**: The main part of the message that contains the actual data or the request/response payload\n\nCreate SOAP request\n\n\nYou have two options for creating SOAP requests in Bruno:\n\nOption 1: Import from WSDL (Recommended)\n\n\nIf you have a WSDL file, Bruno can automatically generate SOAP requests with pre-configured envelopes:\n\n1. Right-click on a collection and select **Import Collection**\n2. Choose **WSDL** and upload your `.wsdl` file\n3. Bruno will generate all SOAP operations with proper XML structure\n\n[Learn more about WSDL import â†’](/converters/wsdl-to-bruno)\n\nOption 2: Create Manually\n\n\n1. Create new request inside a collection in Bruno.\n2. Select **HTTP** and add URL and name.\n3. Click on **Create** button.\n\n![create-soap-req](/screenshots/send-request/soap/create-soap-req.webp)\n\nAdding body data\n\n\n1. After creating request, Go to **Body**.\n2. Select **XML** from the dropdown list.\n3. Add your XML data in the textarea section.\n4. Save and Execute the request.\n\nIf your request is successful, Bruno will display the response in the **Response** tab.\n\n![soap-xml-data](/screenshots/send-request/soap/soap-xml-data.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/soap/soap-request"
  },
  "send-requests/websocket/create-request": {
    "name": "create-request",
    "content": "import { Callout } from \"nextra/components\";\n\nCreate WebSocket Request\n\n\nCreating a WebSocket request in Bruno allows you to establish real-time connections and test bidirectional communication with WebSocket servers.\n\nCreating a WebSocket Request\n\n\nStep 1: Add New Request\n\n\n1. **Open your collection** in Bruno\n2. **Right-click** on the collection or folder where you want to add the request\n3. **Select \"New Request\"** from the context menu\n4. **Choose \"WebSocket\"** as the request type\n\n![Create WebSocket Request](/screenshots/send-request/ws/create-ws-req.webp)\n\nStep 2: Configure WebSocket URL\n\n\n1. **Enter the WebSocket URL** in the address bar\n   - Use `ws://` for unsecured connections\n   - Use `wss://` for secured connections (recommended for production)\n\n**Example URLs:**\n```\nwss://echo.websocket.org\n```\n\nStep 3: Configure Headers\n\n\n1. **Click the Headers tab**\n2. **Add custom headers** as needed:\n   - **Authorization**: Bearer tokens, API keys\n   - **Custom Headers**: Any additional metadata\n   - **User-Agent**: Custom user agent strings\n\n**Common Headers:**\n```\nAuthorization: Bearer your-token-here\nX-API-Key: your-api-key\nUser-Agent: Bruno-WebSocket-Client\n```\n\nStep 4: Set Connection Options\n\n\n1. **Click the Settings tab**\n2. **Configure connection settings**:\n\n**Connection Timeout**\n- Set the maximum time to wait for connection establishment\n- Default: 30 seconds\n- Range: 1-300 seconds\n\n**Auto-reconnect**\n- Enable automatic reconnection on connection loss\n- Useful for testing resilient WebSocket implementations\n\n![WebSocket Settings](/screenshots/send-request/ws/ws-settings.webp)\n\nStep 5: Configure Subprotocols (Optional)\n\n\nBruno supports WebSocket subprotocols, allowing you to specify the application-level protocol to use over the WebSocket connection.\n\n**Setting a Subprotocol**\n\nWebSocket subprotocols enable your client to specify which protocol variant it wants to use. To set a subprotocol in Bruno:\n- Add the `Sec-WebSocket-Protocol` header in the Headers tab\n- Specify one or multiple subprotocols\n\n**Example:**\n```\nSec-WebSocket-Protocol: mqtt, wamp\n```\n\n**Setting WebSocket Version**\n\nYou can specify the WebSocket protocol version using the `Sec-WebSocket-Version` header. This is useful when testing compatibility with servers that support multiple WebSocket versions:\n\n```\nSec-WebSocket-Version: 13\n```\n\n\n WebSocket protocol version 13 (RFC 6455) is the current standard. Most modern servers use this version by default.\n\n\n**Server Rejections**\n\nIf the server doesn't support the requested subprotocol or version:\n- The connection will be rejected\n- You'll see a **400 Bad Request** response\n- Check the response details to understand why the server rejected the connection\n\n**Advanced Header Overrides**\n\nBruno allows you to override other `Sec-WebSocket-*` headers if needed for testing specific scenarios:\n- `Sec-WebSocket-Key`: Custom key for handshake (auto-generated by default)\n- `Sec-WebSocket-Extensions`: Specify compression or other extensions\n\nSimply add these headers in the Headers tab like any other custom header.\n\n",
    "parentName": "send-requests",
    "path": "send-requests/websocket/create-request"
  },
  "send-requests/websocket/message-types": {
    "name": "message-types",
    "content": "import { Callout } from \"nextra/components\";\n\nWebSocket Message Types\n\n\nBruno supports various message types for WebSocket communication, allowing you to send and receive different data formats based on your application's requirements.\n\nSupported Message Types\n\n\nBruno supports the following WebSocket message types:\n\nText Messages\n\nPlain text messages for simple communication and human-readable data exchange.\n\n**Characteristics:**\n- **Format**: UTF-8 encoded text\n- **Use Case**: Simple messages, commands, status updates\n- **Size**: Limited by WebSocket frame size (typically 64KB)\n- **Encoding**: UTF-8\n\n**Example Text Messages:**\n```\nHello, WebSocket server!\nPING\nGET_STATUS\nUSER_JOINED:john_doe\n```\n\n**When to Use:**\n- Simple commands or instructions\n- Status messages and notifications\n- Human-readable communication\n- Protocol-level messages (PING/PONG)\n\nJSON Messages\n\nStructured data in JSON format for complex data exchange and API-like communication.\n\n**Characteristics:**\n- **Format**: JSON (JavaScript Object Notation)\n- **Use Case**: Structured data, API responses, complex objects\n- **Validation**: JSON syntax validation and formatting\n- **Size**: Limited by WebSocket frame size\n\n**Example JSON Messages:**\n```json\n{\n  \"type\": \"message\",\n  \"content\": \"Hello from Bruno!\",\n  \"timestamp\": \"2025-01-09T10:30:00Z\",\n  \"user\": {\n    \"id\": 123,\n    \"name\": \"Bruno User\"\n  }\n}\n```\n\n**Chat Application Example:**\n```json\n{\n  \"type\": \"chat_message\",\n  \"room\": \"general\",\n  \"user\": \"john_doe\",\n  \"message\": \"Hello everyone!\",\n  \"timestamp\": 1704795000000\n}\n```\n\n**API Response Example:**\n```json\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"user_id\": 123,\n    \"balance\": 1000.50,\n    \"currency\": \"USD\"\n  },\n  \"message\": \"Balance retrieved successfully\"\n}\n```\n\n**When to Use:**\n- Structured data exchange\n- API-like communication\n- Complex objects and arrays\n- When you need data validation\n\nXML Messages\n\nStructured data in XML format for legacy systems and XML-based protocols.\n\n**Characteristics:**\n- **Format**: XML (eXtensible Markup Language)\n- **Use Case**: SOAP messages, legacy systems, XML-based APIs\n- **Validation**: XML syntax validation and formatting\n- **Size**: Limited by WebSocket frame size\n\n**Example XML Messages:**\n```xml\n\n\n  notification\n  Hello from Bruno!\n  2025-01-09T10:30:00Z\n  \n    123\n    Bruno User\n  \n\n```\n\n**SOAP Message Example:**\n```xml\n\n\n  \n    \n      123\n    \n  \n\n```\n\n**When to Use:**\n- Legacy systems requiring XML format\n- SOAP-based WebSocket services\n- XML-based messaging protocols\n- When working with systems that expect XML",
    "parentName": "send-requests",
    "path": "send-requests/websocket/message-types"
  },
  "send-requests/websocket/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\n\nOverview\n\n\n\n    WebSocket support is available from Bruno 2.13.0.\n\n\nBruno now supports WebSocket connections, enabling you to test real-time communication protocols and bidirectional data exchange. This feature allows you to establish WebSocket connections, send messages, and receive responses in real-time.\n\nWhat are WebSockets?\n\n\nWebSockets provide a persistent, full-duplex communication channel between a client and server. Unlike traditional HTTP requests that follow a request-response pattern, WebSockets maintain an open connection that allows both the client and server to send messages at any time.\n\nWebSocket vs HTTP\n\n\n| Feature | HTTP | WebSocket |\n|---------|------|-----------|\n| **Connection** | Request-Response | Persistent |\n| **Latency** | Higher (connection overhead) | Lower (persistent connection) |\n| **Data Flow** | Unidirectional | Bidirectional |\n| **Use Case** | Traditional APIs | Real-time applications |\n| **Overhead** | Higher per request | Lower per message |\n| **Complexity** | Simple | More complex |\n\nNext Steps\n\n\n- WebSocket [Request Interface](./ws-interface.mdx)\n- Learn how to [Create WebSocket Requests](./create-request.mdx)\n\n\n",
    "parentName": "send-requests",
    "path": "send-requests/websocket/overview"
  },
  "send-requests/websocket/ws-interface": {
    "name": "ws-interface",
    "content": "WebSocket Request Interface\n\n\nThe WebSocket request interface consists of several key components:\n\n![WebSocket Interface](/screenshots/send-request/ws/websocket-interface.webp)\n\nRequest Interface\n\n\nConnection Status\n\n- **Disconnected**: Initial state, ready to connect\n- **Connecting**: Establishing connection to server\n- **Connected**: Successfully connected and ready to send messages\n- **Disconnected**: Connection lost or manually closed\n\nMessage Composition\n\n- **Message Type**: Choose between Text, JSON, XML\n- **Message Editor**: Compose your message with syntax highlighting\n- **Send Button**: Send the composed message\n\nMessage History\n\n- **Sent Messages**: All messages you've sent (marked with â†’)\n- **Received Messages**: All messages received from server (marked with â†)\n- **Timestamps**: When each message was sent/received\n- **Message Sorting**: Toggle between newest/oldest first\n\nConnection Management\n\n\nEstablishing Connection\n\n\n1. **Click the \"Connect\" button** to establish the WebSocket connection\n2. **Monitor connection status** in the status indicator\n3. **View connection logs** for detailed connection information\n\nSending Messages\n\n\n1. **Compose your message** in the message editor\n2. **Select message type** (Text, JSON, XML)\n3. **Click \"Send\"** to transmit the message\n4. **View sent message** in the message history\n\n![Send WebSocket Request](/screenshots/send-request/ws/send-ws-req.webp)\n\nReceiving Messages\n\n\n1. **Monitor the message history** for incoming messages\n2. **View message details** including timestamp and content\n3. **Use test scripts** to validate received messages\n\nClosing Connection\n\n\n1. **Click \"Disconnect\"** to close the WebSocket connection\n2. **Connection status** will update to \"Disconnected\"\n3. **Message history** is preserved for review\n\n",
    "parentName": "send-requests",
    "path": "send-requests/websocket/ws-interface"
  },
  "testing/automate-test/automate-test": {
    "name": "automate-test",
    "content": "import { Callout } from \"nextra/components\";\n\nRunning Automated Tests\n\n\nThe [Bruno CLI](/bru-cli/overview) is a command line utility that allows you to call tests from the terminal, or **integrate your test collections into a CI/CD pipeline**.\n\nContinuous integration and continuous delivery (CI/CD) empower teams to ship software updates rapidly and reliably, maximizing user value without compromising quality. By integrating automated API tests into the build pipeline, you verify that every code change is validated and production-ready.\n\nFor more information on the Bruno CLI, go to that [specific section of the documentation](/bru-cli/overview). \n\n",
    "parentName": "testing",
    "path": "testing/automate-test/automate-test"
  },
  "testing/automate-test/data-driven-testing": {
    "name": "data-driven-testing",
    "content": "import Video from \"../../../components/Video\";\nimport { Callout } from \"nextra/components\";\n\nIterate Using Data Files\n\n\nThe **Collection Runner** feature allows you to iterate over data files, making it easy to automate and manage data-driven requests. Bruno supports both CSV and JSON files for running requests, so you can efficiently run tests or process multiple data inputs.\n\nIntroduction\n\n\nIn this tutorial, we'll explore the Collection Runner feature, which enables you to run collections using custom data for each iteration.\n\nSteps to Get Started\n\n\n1. Open the Bruno app.\n2. Create a collection called `runner-example`\n3. Create a POST request and name it `runner-request`\n4. Use the URL: `\n5. Select the JSON format for the request body and add the following data:\n\n```json\n{\n    \"name\": \"morpheus\",\n    \"job\": \"leader\"\n}\n```\n\nUsing the Collection Runner\n\n\nWe will create a sample data file `csv-example.csv` that includes input fields such as `name` and `job` to be used in data-driven testing. You need to create a CSV or JSON file according to the specific requirements of the API you're working with.\n\nSince the API in this case expects two data inputs `name` and `job` the file should contain these fields. Here's an example of how to structure your data:\n\n1. CSV Format Example\n\nA sample CSV file might look like this:\n\n```csv copy\nname,job\nJohn Doe,Software Engineer\nJane Smith,Product Manager\nMark Lee,Data Scientist\n```\n\n2. JSON Format Example\n\nA sample JSON file might look like this:\n\n```json copy\n[\n  { \"name\": \"John Doe\", \"job\": \"Software Engineer\" },\n  { \"name\": \"Jane Smith\", \"job\": \"Product Manager\" },\n  { \"name\": \"Mark Lee\", \"job\": \"Data Scientist\" }\n]\n```\n\nNow you're ready to use the Collection Runner. You can access it in two ways:\n\nUsing the Bruno App\n\n\n1. Click on the runner icon in the right-hand navbar.\n2. Check the **Run with Parameters** option.\n3. Select the file type: CSV or JSON.\n4. Click **Run Collection**.\n\nOnce the execution is complete, you can review the results for each individual request and check their statuses.\n\n\n\nHow to Use Variables from CSV/JSON Files\n\n\nWhen you upload a CSV or JSON file, the variables within the file can be accessed using the `{{var}}` syntax.\nYou can access these variables dynamically in your requests and use them within Bruno.\n\nAccessing Variables in Request Body\n\n\n```json showLineNumbers filename=\"request-body\"\n{\n  \"name\": \"{{name}}\",\n  \"email\": \"{{email}}\"\n}\n```\n\nIn this example, `{{name}}` and `{{email}}` will be replaced by the actual values from the uploaded JSON file.\n\n```json showLineNumbers filename=\"request-body\"\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john.doe@example.com\"\n}\n```\n\nAccessing Variables in Scripts\n\n\nYou can also access these variables directly in your pre-request or post-response scripts using `bru.getVar()`.\n\n```javascript\nconsole.log(bru.getVar(\"name\")); // Outputs: John Doe\nconsole.log(bru.getVar(\"email\")); // Outputs: john.doe@example.com\n```\n\nWhen you run the request, you'll see the output of these variables in the console.\n\nUsing the Bruno CLI\n\n\n1. Navigate to the root directory of your Bruno collection.\n2. Run the following command:\n\n```bash copy\nbru run --reporter-html results.html --csv-file-path /path/to/csv/file.csv\n```\n\n\n\nIt will create a `results.html` file in your Bruno collection's root directory. You can view this file in your browser.\n\nCommand Overview\n\n\n- `--reporter-html results.html`: Generates a human-readable HTML report.\n- `--csv-file-path /path/to/csv/file.csv`: Specifies the path to the CSV file you want to use.\n\n[Bruno CLI Overview](../../bru-cli/overview)\n\nRunner Iteration Utilities\n\n\nBruno provides various utility functions to access and manipulate data from attached data files (CSV/JSON) during collection runs.\n\nAccessing Iteration Data\n\n\nCheck if a variable exists\n\n```javascript\nif (bru.runner.iterationData.has(\"username\")) {\n    console.log(\"Username exists in current iteration\");\n}\n```\n\nGet a specific value\n\n```javascript\nconst username = bru.runner.iterationData.get(\"username\");\nconsole.log(`Current username: ${username}`);\n```\n\nGet all iteration data\n\n```javascript\nconst allData = bru.runner.iterationData.get();\nconsole.log(\"All iteration data:\", allData);\n```\n\nConvert to JSON string\n\n```javascript\nconst jsonData = bru.runner.iterationData.stringify();\nconsole.log(\"JSON data:\", jsonData);\n```\n\nRemove a variable\n\n```javascript\nbru.runner.iterationData.unset(\"password\");\n```\n\nIteration Information\n\n\nGet current iteration index\n\n```javascript\nconst currentIteration = bru.runner.iterationIndex;\nconsole.log(`Running iteration ${currentIteration}`);\n```\n\nGet total iterations\n\n```javascript\nconst total = bru.runner.totalIterations;\nconsole.log(`Total iterations: ${total}`);\n```\n\nExample Usage\n\n\nBasic Data Access\n\n```javascript\n// Get values from current iteration\nconst username = bru.runner.iterationData.get(\"username\");\nconst password = bru.runner.iterationData.get(\"password\");\n\n// Use in request\nbru.request.setBody({\n    username: username,\n    password: password\n});\n```\n\nConditional Logic Based on Iteration\n\n```javascript\n// Only modify data in first iteration\nif (bru.runner.iterationIndex === 0) {\n    bru.runner.iterationData.unset(\"password\");\n}\n\n// Check if variable exists\nif (bru.runner.iterationData.has(\"password\")) {\n    console.log(\"Password available\");\n}\n```\n\nData File Examples\n\n\nCSV Format\n\n```csv\nusername,password\nuser1,pass123\nuser2,pass456\n```\n\nJSON Format\n\n```json\n[\n    { \"username\": \"user1\", \"password\": \"pass123\" },\n    { \"username\": \"user2\", \"password\": \"pass456\" }\n]\n```\n\nNotes\n\n\n- Variables removed with `unset()` only affect the current iteration\n- Each iteration runs with fresh data from the file\n- Supports both CSV and JSON data files\n- Data is automatically loaded from the attached file at the start of each iteration\n",
    "parentName": "testing",
    "path": "testing/automate-test/data-driven-testing"
  },
  "testing/automate-test/manual-test": {
    "name": "manual-test",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nRunning Tests Manually\n\n\nRunning tests manually in Bruno allows you to quickly validate functionality and immediately view results. The most common example of this would be simply hitting an endpoint and seeing if it is working.\n\nRunning a Single Test\n\n\nThe smallest unit of testing in Bruno is a single request. The request itself tests the functionality of any given endpoint. You can add additional logic to requests by using the `Tests` tab. \n\nTo manually trigger a single test:\n\n1. Open a Collection\n2. Select the Request that you would like to run\n3. Click Enter or press the send icon \n4. View the results in the `Tests` section of the response pane\n\nRunning a Test Suite \n\n\nOften times a Bruno Collection can represent a test suite of different actions or workflows of an API. You can use the Collection Runner to execute this entire suite, and also iterate through data using [data driven testing](/testing/automate-test/data-driven-testing). \n\nFollow these steps to run your collection, view the results, and optionally download the test report as an HTML document.\n\n1. Open the **Bruno** collection\n2. Click on the **Run** option from the dropdown menu.\n\n![select-run.webp](/screenshots/testing/1-select-run.webp)\n\n3. Click **Run Collection** to initiate the test.\n\n![click-runner.webp](/screenshots/testing/2-click-runner.webp)\n\n4. Once the test run is complete, a test report will be automatically generated.\n\n![generate-test-report.webp](/screenshots/testing/3-generate-test-report.webp)\n\nDownload Test Report \n\n\nAfter the test report is generated, you can download it as an HTML document (`report.html`).\n\n1. Click the **Download Report** button to save the report.\n\n![details-test-reports.webp](/screenshots/testing/4-details-test-reports.webp)\n\nManaging Request Execution\n\n\nBruno allows you to filter which requests to run in your collection using tags. You can add tags to your requests and then filter them during collection runs.\n\n\n  This feature requires Bruno version 2.8.0 or higher.\n\n\nTag-Based Request Filtering\n\n\nWhen running a collection in the Bruno app, you can filter requests by tags:\n\n1. **Add tags to your requests**: Go to request settings and add tags to categorize your requests\n   \n![Add Tags to Requests](/screenshots/collection-runner/1-add-tags.webp)\n\n2. **Go to Collection Runner**: Open the collection runner to start filtering requests\n3. **Use tag filter options**: Use the tag filter options to include or exclude requests based on their tags\n4. **Run filtered collection**: Only requests matching your tag criteria will be executed\n\n![Run Collection with Tags](/screenshots/collection-runner/2-run-collection-tags.webp)\n\nTag Filtering Options\n\n\n- **Include tags**: Only run requests that have ALL of the specified tags\n- **Exclude tags**: Skip requests that have ANY of the specified tags\n- **Combined filtering**: Use both include and exclude filters together\n\nLearn more about tag filtering in Bruno CLI in the [CLI tag filtering documentation](/bru-cli/runCollection#filtering-requests-with-tags).\n\nReordering Request Execution\n\n\nYou can reorder, select, and deselect requests by enabling the **Configure requests to run** option in the Collection Runner. This feature allows you to:\n\n- **Select specific requests** to execute while ignoring others\n- **Reorder requests** to control the execution sequence\n- **Customize test runs** without modifying the collection structure\n\nBy default, the Collection Runner executes all requests in the collection. When you enable request configuration, only the selected requests will be executed.\n\n![Reorder Requests](/screenshots/testing/reorder-req.webp)\n\n\nView Test Report\n\n\nOnce the report is downloaded, you can open the `report.html` file in any web browser to review the detailed test results.\n\n![test-web-view.webp](/screenshots/testing/test-web-view.webp)\n\n",
    "parentName": "testing",
    "path": "testing/automate-test/manual-test"
  },
  "testing/automate-test/overview": {
    "name": "overview",
    "content": "Overview\n\n\nBruno offers multiple ways to run your API tests. Testing is crucial for APIs, as a single failure can bring down the entire application. With Bruno, you can automate API tests using the [Collection Runner â†—]( or the [Bruno CLI â†—]( to integrate testing into your CI/CD pipeline.\n\nAutomated Testing in CI/CD\n\n\nBruno offers a command-line utility to run Collections. This allows you to integrate your tests into a CI and build process.\n\nFor more information, head to the page for [Bruno CLI â†—](\n\n1. [Run Manual Test](./manual-test.mdx)\n2. [Run Automate Test](./automate-test.mdx)\n",
    "parentName": "testing",
    "path": "testing/automate-test/overview"
  },
  "testing/script/dynamic-variables": {
    "name": "dynamic-variables",
    "content": "import { Callout } from 'nextra/components'\n\nDynamic Variables\n\n\nDynamic variables enable you to generate and use random data in your testing workflow. Bruno uses the [faker.js â†—]( library to generate random data. You can use these variables like any other variables in Bruno. The syntax to use dynamic variables is `{{$randomData}}`, and you can use them in the request body, authentication, parameters, and other fields.\n\n\n  Dynamic variables are case-sensitive and follow the camelCase convention. This feature is available in Bruno version 2.x and above.\n\n\nUsing Dynamic Variables in Scripts\n\n\nTo use dynamic variables in pre-request or post-response scripts, use the `bru.interpolate()` function. For example:\n\n```javascript\n// Generate a random first name\nconst firstName = bru.interpolate('{{$randomFirstName}}');\nconsole.log('Random first name:', firstName);\n\n// Generate a random email\nconst email = bru.interpolate('{{$randomEmail}}');\nconsole.log('Random email:', email);\n\n// Generate multiple dynamic values in one call\nconst userInfo = bru.interpolate(`\n  Name: {{$randomFullName}}\n  Job: {{$randomJobTitle}}\n  Email: {{$randomEmail}}\n`);\nconsole.log(userInfo);\n\n// Use with environment variables\nconst greeting = bru.interpolate('Hello {{user}} from {{$randomCity}}');\n```\n\nThe `bru.interpolate()` function allows you to embed dynamic variables in strings and have them evaluated at runtime within scripts, just like they would be in request bodies or headers.\n\nUsage Examples\n\n\nHere are some common use cases for dynamic variables:\n\n1. **Test Data Generation**:\n   ```json\n   {\n     \"user\": {\n       \"id\": \"{{$randomUUID}}\",\n       \"name\": \"{{$randomFullName}}\",\n       \"email\": \"{{$randomEmail}}\",\n       \"phone\": \"{{$randomPhoneNumber}}\",\n       \"address\": {\n         \"street\": \"{{$randomStreetAddress}}\",\n         \"city\": \"{{$randomCity}}\",\n         \"country\": \"{{$randomCountry}}\"\n       }\n     }\n   }\n   ```\n\n2. **Authentication**:\n   ```json\n   {\n     \"credentials\": {\n       \"username\": \"{{$randomUserName}}\",\n       \"password\": \"{{$randomPassword}}\",\n       \"lastLogin\": \"{{$isoTimestamp}}\"\n     }\n   }\n   ```\n\n3. **Business Data**:\n   ```json\n   {\n     \"company\": {\n       \"name\": \"{{$randomCompanyName}}\",\n       \"catchPhrase\": \"{{$randomCatchPhrase}}\",\n       \"department\": \"{{$randomDepartment}}\",\n       \"account\": {\n         \"number\": \"{{$randomBankAccount}}\",\n         \"type\": \"{{$randomTransactionType}}\"\n       }\n     }\n   }\n   ```\n\nAvailable Dynamic Variables\n\n\nBruno provides a comprehensive set of dynamic variables for generating test data. These variables are organized into categories based on their functionality.\n\nBasic Data Types\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$guid}}` | A random UUID | 550e8400-e29b-41d4-a716-446655440000 |\n| `{{$timestamp}}` | Current timestamp in milliseconds | 1562757107 |\n| `{{$isoTimestamp}}` | Current timestamp in ISO format | 2024-03-20T12:34:56.789Z |\n| `{{$randomUUID}}` | A random UUID | 550e8400-e29b-41d4-a716-446655440000 |\n| `{{$randomNanoId}}` | A random Nano ID | V1StGXR8_Z5jdHi6B5cEn4c8b8w |\n| `{{$randomAlphaNumeric}}` | A random alpha-numeric character | 6, y, z |\n| `{{$randomBoolean}}` | A random boolean value | true, false |\n| `{{$randomInt}}` | A random integer between 0 and 1000 | 802, 494, 200 |\n| `{{$randomColor}}` | A random color | red, fuchsia, grey |\n| `{{$randomHexColor}}` | A random hex value | #47594a, #431e48, #106f21 |\n| `{{$randomAbbreviation}}` | A random abbreviation | SQL, PCI, JSON |\n| `{{$randomWord}}` | A random word | protocol, interface |\n| `{{$randomWords}}` | Multiple random words | quick brown fox |\n\nInternet and Network\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomIP}}` | A random IPv4 address | 241.102.234.100, 216.7.27.38 |\n| `{{$randomIPV4}}` | A random IPv4 address | 192.168.1.1 |\n| `{{$randomIPV6}}` | A random IPv6 address | dbe2:7ae6:119b:c161:1560:6dda:3a9b:90a9 |\n| `{{$randomMACAddress}}` | A random MAC address | 33:d4:68:5f:b4:c7, 1f:6e:db:3d:ed:fa |\n| `{{$randomPassword}}` | A random 15-character alpha-numeric password | t9iXe7COoDKv8k3, QAzNFQtvR9cg2rq |\n| `{{$randomLocale}}` | A random two-letter language code (ISO 639-1) | ny, sr, si |\n| `{{$randomUserAgent}}` | A random user agent | Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6 |\n| `{{$randomProtocol}}` | A random internet protocol | http, https |\n| `{{$randomSemver}}` | A random semantic version number | 7.0.5, 2.5.8, 6.4.9 |\n| `{{$randomDomainName}}` | A random domain name | example.com |\n| `{{$randomDomainSuffix}}` | A random domain suffix | .com, .org, .net |\n| `{{$randomDomainWord}}` | A random domain word | example, test, demo |\n| `{{$randomExampleEmail}}` | A random example email | user@example.com |\n| `{{$randomEmail}}` | A random email address | john.doe@example.com |\n| `{{$randomUserName}}` | A random username | johndoe123 |\n| `{{$randomUrl}}` | A random URL |  |\n\nNames and Personal Information\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomFirstName}}` | A random first name | Ethan, Chandler, Megane |\n| `{{$randomLastName}}` | A random last name | Schaden, Schneider, Willms |\n| `{{$randomFullName}}` | A random first and last name | Connie Runolfsdottir, Sylvan Fay, Jonathon Kunze |\n| `{{$randomNamePrefix}}` | A random name prefix | Dr., Ms., Mr. |\n| `{{$randomNameSuffix}}` | A random name suffix | I, MD, DD |\n| `{{$randomJobArea}}` | A random job area | Marketing, Engineering, Sales |\n| `{{$randomJobDescriptor}}` | A random job descriptor | Senior, Lead, Junior |\n| `{{$randomJobTitle}}` | A random job title | Software Engineer, Product Manager |\n| `{{$randomJobType}}` | A random job type | Full-time, Contract, Part-time |\n| `{{$randomPhoneNumber}}` | A random phone number | +1-555-123-4567 |\n| `{{$randomPhoneNumberExt}}` | A random phone number with extension | +1-555-123-4567 ext. 123 |\n\nLocation\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomCity}}` | A random city name | New York, London, Tokyo |\n| `{{$randomStreetName}}` | A random street name | Main Street, Park Avenue |\n| `{{$randomStreetAddress}}` | A random street address | 123 Main St, 456 Park Ave |\n| `{{$randomCountry}}` | A random country name | United States, Japan, Germany |\n| `{{$randomCountryCode}}` | A random country code | US, JP, DE |\n| `{{$randomLatitude}}` | A random latitude | 40.7128, 35.6762 |\n| `{{$randomLongitude}}` | A random longitude | -74.0060, 139.6503 |\n\nImages\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomAvatarImage}}` | A random avatar image URL |  |\n| `{{$randomImageUrl}}` | A random image URL |  |\n| `{{$randomAbstractImage}}` | A random abstract image |  |\n| `{{$randomAnimalsImage}}` | A random animal image |  |\n| `{{$randomBusinessImage}}` | A random business image |  |\n| `{{$randomCatsImage}}` | A random cat image |  |\n| `{{$randomCityImage}}` | A random city image |  |\n| `{{$randomFoodImage}}` | A random food image |  |\n| `{{$randomNightlifeImage}}` | A random nightlife image |  |\n| `{{$randomFashionImage}}` | A random fashion image |  |\n| `{{$randomPeopleImage}}` | A random people image |  |\n| `{{$randomNatureImage}}` | A random nature image |  |\n| `{{$randomSportsImage}}` | A random sports image |  |\n| `{{$randomTransportImage}}` | A random transport image |  |\n| `{{$randomImageDataUri}}` | A random image data URI | data:image/png;base64,... |\n\nFinance\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomBankAccount}}` | A random bank account number | 1234567890 |\n| `{{$randomBankAccountName}}` | A random bank account name | Checking Account |\n| `{{$randomCreditCardMask}}` | A masked credit card number | **** **** **** 1234 |\n| `{{$randomBankAccountBic}}` | A random BIC code | DEUTDEFF |\n| `{{$randomBankAccountIban}}` | A random IBAN | DE89370400440532013000 |\n| `{{$randomTransactionType}}` | A random transaction type | deposit, withdrawal |\n| `{{$randomCurrencyCode}}` | A random currency code | USD, EUR, JPY |\n| `{{$randomCurrencyName}}` | A random currency name | US Dollar, Euro, Yen |\n| `{{$randomCurrencySymbol}}` | A random currency symbol | $, â‚¬, Â¥ |\n| `{{$randomBitcoin}}` | A random Bitcoin address | 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa |\n\nBusiness\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomCompanyName}}` | A random company name | TechCorp Inc. |\n| `{{$randomCompanySuffix}}` | A random company suffix | LLC, Inc., Ltd. |\n| `{{$randomBs}}` | A random business buzz phrase | revolutionize end-to-end systems |\n| `{{$randomBsAdjective}}` | A random business adjective | innovative, scalable |\n| `{{$randomBsBuzz}}` | A random business buzz word | synergize, leverage |\n| `{{$randomBsNoun}}` | A random business noun | solutions, platform |\n| `{{$randomCatchPhrase}}` | A random company catch phrase | Innovate. Create. Transform. |\n| `{{$randomCatchPhraseAdjective}}` | A random catch phrase adjective | innovative, revolutionary |\n| `{{$randomCatchPhraseDescriptor}}` | A random catch phrase descriptor | next-generation, cutting-edge |\n| `{{$randomCatchPhraseNoun}}` | A random catch phrase noun | solutions, platform |\n\nDatabase\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomDatabaseColumn}}` | A random database column name | id, name, created_at |\n| `{{$randomDatabaseType}}` | A random database type | varchar, int, timestamp |\n| `{{$randomDatabaseCollation}}` | A random database collation | utf8_general_ci, latin1_swedish_ci |\n| `{{$randomDatabaseEngine}}` | A random database engine | InnoDB, MyISAM |\n\nDates\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomDateFuture}}` | A random future date | 2024-12-31T23:59:59.999Z |\n| `{{$randomDatePast}}` | A random past date | 2020-01-01T00:00:00.000Z |\n| `{{$randomDateRecent}}` | A random recent date | 2024-03-15T12:34:56.789Z |\n| `{{$randomWeekday}}` | A random weekday | Monday, Tuesday |\n| `{{$randomMonth}}` | A random month | January, February |\n\nFiles and System\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomFileName}}` | A random file name | document.pdf |\n| `{{$randomFileType}}` | A random file type | application/pdf |\n| `{{$randomFileExt}}` | A random file extension | .pdf, .jpg |\n| `{{$randomCommonFileName}}` | A random common file name | document.pdf |\n| `{{$randomCommonFileType}}` | A random common file type | application/pdf |\n| `{{$randomCommonFileExt}}` | A random common file extension | .pdf, .jpg |\n| `{{$randomFilePath}}` | A random file path | /path/to/file.txt |\n| `{{$randomDirectoryPath}}` | A random directory path | /usr/local/bin |\n| `{{$randomMimeType}}` | A random MIME type | application/json |\n\nCommerce\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomPrice}}` | A random price | 99.99, 149.95 |\n| `{{$randomProduct}}` | A random product | Chair, Table |\n| `{{$randomProductAdjective}}` | A random product adjective | Ergonomic, Modern |\n| `{{$randomProductMaterial}}` | A random product material | Wood, Metal |\n| `{{$randomProductName}}` | A random product name | Ergonomic Wooden Chair |\n| `{{$randomDepartment}}` | A random department name | Electronics, Clothing |\n\nHacker and Lorem\n\n\n| Variable Name | Description | Examples |\n|--------------|-------------|----------|\n| `{{$randomNoun}}` | A random noun | protocol, interface |\n| `{{$randomVerb}}` | A random verb | hack, override |\n| `{{$randomIngverb}}` | A random -ing verb | hacking, overriding |\n| `{{$randomAdjective}}` | A random adjective | digital, virtual |\n| `{{$randomPhrase}}` | A random phrase | Try to reboot the SQL bus |\n| `{{$randomLoremWord}}` | A random Lorem Ipsum word | lorem, ipsum |\n| `{{$randomLoremWords}}` | Multiple Lorem Ipsum words | lorem ipsum dolor |\n| `{{$randomLoremSentence}}` | A random Lorem Ipsum sentence | Lorem ipsum dolor sit amet. |\n| `{{$randomLoremSentences}}` | Multiple Lorem Ipsum sentences | Lorem ipsum dolor sit amet. Consectetur adipiscing elit. |\n| `{{$randomLoremParagraph}}` | A random Lorem Ipsum paragraph | Lorem ipsum dolor sit amet... |\n| `{{$randomLoremParagraphs}}` | Multiple Lorem Ipsum paragraphs | Lorem ipsum dolor sit amet...\\n\\nConsectetur adipiscing elit... |\n| `{{$randomLoremText}}` | A random Lorem Ipsum text | Lorem ipsum dolor sit amet... |\n| `{{$randomLoremSlug}}` | A random Lorem Ipsum slug | lorem-ipsum-dolor |\n| `{{$randomLoremLines}}` | Multiple Lorem Ipsum lines | Lorem ipsum dolor\\nConsectetur adipiscing elit |\n",
    "parentName": "testing",
    "path": "testing/script/dynamic-variables"
  },
  "testing/script/external-libraries": {
    "name": "external-libraries",
    "content": "import { Callout } from \"nextra/components\";\nimport { FileTree } from \"nextra/components\";\n\nExternal Libraries\n\n\nBruno allows you to load any npm module for use in your scripting workflows.\n\nPrerequisites\n\n\nBefore you begin, ensure that you have the following:\n\n1. Node.js installed on your system.\n2. Bruno installed.\n\nProject Structure\n\n\nThe folder structure for this example will be:\n\n\n  \n    \n    \n    \n    \n    \n    \n      \n    \n  \n\n\nConfiguration\n\n\nYou need to initialize `package.json` file inside your collection.\n\nNavigate to your Bruno collection directory in the terminal.\n\n```bash\ncd path/to/your/bruno-collection\n```\n\nInitialize `package.json` file inside your collection.\n\n```bash\nnpm init -y\n```\n\nNow you can install any npm package or module to use in your collection.\n\nSpectral Integration\n\n\nIn this example we're using [Spectral CLI â†—]( as a npm package which help you to validate OpenSpec API YAML or JSON files with the built-in ruleset.\n\nYou need to have OpenAPI JSON or YAML file to work with spectral or you can download from [here â†—]( as example.\n\nSpectral CLI Setup\n\n\nYou can install `spectral-cli` by running following command:\n\n```bash\nnpm install @stoplight/spectral-cli\n```\n\nRun this command in your terminal to initialize `.spectral.yml` file which is predefined ruleset.\n\n```js copy\necho 'extends: [\"spectral:oas\", \"spectral:asyncapi\", \"spectral:arazzo\"]' > .spectral.yaml\n```\n\nValidate your **openapi.yaml** file from Bruno collection by running following CLI command:\n\n```js copy\nspectral lint openspec.yaml --r .spectral.yaml\n```\n\nOutput Overview\n\n\nAfter following the process outlined above, warning messages will be displayed on the CLI such as duplicates and empty tags. This is how you can validate your OpenSpec files using Spectral.\n\n```bash\nopenspec.yaml:\n 2:6  warning  info-contact    Info object must have \"contact\" object.      info\n 10:9 warning  operation-tags  Operation must have non-empty \"tags\" array.  paths./pets.get\n 36:9 warning  operation-tags  Operation must have non-empty \"tags\" array.  paths./pets/{petId}.get\n```\n",
    "parentName": "testing",
    "path": "testing/script/external-libraries"
  },
  "testing/script/inbuilt-libraries": {
    "name": "inbuilt-libraries",
    "content": "import { Callout } from 'nextra/components'\n\n\nInbuilt Libraries\n\n\nBruno supports **CommonJS** syntax `require` for importing libraries. ES Modules `import/export` are not supported at this time.\n\nHere's an example demonstrating how to use the **chai** library in Bruno:\n\n```js copy\nconst chai = require('chai');\n\nconst { expect } = chai;\n\nfunction add(a, b) {\n  return a + b;\n}\n\nconst result = add(2, 3);\n\nexpect(result).to.equal(5);\n\nconsole.log('Test passed!');\n```\nYou can include this code in the pre-request script section of Bruno to test it out.\n\nBelow is the list of inbuilt libraries supported by Bruno.\n\n- [axios]( - Promise based HTTP client for the browser and node.js\n- [atob]( -  Turn base64-encoded ascii data back to binary.\n- [btoa]( -  Turn binary data to base64-encoded ascii.\n- [chai]( -  BDD/TDD assertion library for node.js and the browser.\n- [moment]( -  Parse, validate, manipulate, and display dates and times in JavaScript.\n- [uuid]( -  For the creation of RFC4122 UUIDs.\n- [nanoid]( - A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n- [crypto-js]( - JavaScript library of crypto standards.\n- [tv4]( - Tiny Validator for JSON Schema v4.\n- [jsonwebtoken]( - An implementation of JSON Web Tokens.\n\n\nTo use below inbuilt libraries in Bruno, you must be in **Developer Mode**.\n\n\n- [node-fetch]( - A light-weight module that brings Fetch API to Node.js.\n- [lodash]( -  A modern JavaScript utility library delivering modularity, performance & extras.\n- [ajv]( - Ajv JSON schema validator.\n- [cheerio]( - Library for parsing and manipulating HTML and XML.\n- [xml2js]( - Simple XML to JavaScript object converter for Node.js.\n",
    "parentName": "testing",
    "path": "testing/script/inbuilt-libraries"
  },
  "testing/script/javascript-reference": {
    "name": "javascript-reference",
    "content": "import {Callout} from \"nextra/components\"\n\nJavaScript API Reference\n\n\nBruno offers powerful scripting capabilities that allow you to extend and automate your API testing workflows.\nHere is the complete set of API reference for the scripting feature in Bruno.\n\nRequest\n\n\nThe `req` variable represents the HTTP request object and is automatically available inside your scripting and testing context. It provides methods to access and modify the current request's properties such as URL, method, headers, body, and other configuration options before the request is sent to the server.\n\n\n  The `req` object is available in pre-request scripts and test scripts, allowing you to modify request properties before execution and access them after completion.\n\n\nHere is a complete table for all available methods on the `req` object.\n\n| Method                         | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| req.getUrl()                   | Get the current request URL.                                         |\n| req.setUrl(url)                | Set the current request URL.                                         |\n| req.getAuthMode()              | Get the current authentication mode.                                 |\n| req.getMethod()                | Get the current request method.                                      |\n| req.setMethod(method)          | Set the current request method.                                      |\n| req.getName()                  | Get the current request name.                                        |\n| req.getTags()                  | Get the current request tags as an array of strings.                 |\n| req.getHeader(name)            | Get the request header by name.                                      |\n| req.getHeaders()               | Get all request headers.                                             |\n| req.setHeader(name, value)     | Set a request header by name.                                        |\n| req.setHeaders(headers)        | Set multiple request headers.                                        |\n| req.getBody(options?)          | Get the current request body/payload (supports raw option).          |\n| req.setBody(body)              | Set the request body/payload.                                        |\n| req.setMaxRedirects(count)     | Set the maximum number of redirects to follow.                       |\n| req.getTimeout()               | Get the current timeout value of the request.                        |\n| req.setTimeout(milliseconds)   | Set a timeout for the request.                                       |\n| req.getExecutionMode()         | Get the current active execution mode (runner or standalone).        |\n| req.getExecutionPlatform()     | Get the platform on which the request is being executed (app or cli).|\n| req.onFail(callback)           | Handle request errors with a custom callback function.               |\n\nBelow is the API documentation for the methods available on `req`\n\nURL Methods\n\n\n- **`getUrl()`** - Get the current request URL.\n  ```javascript\n  let url = req.getUrl();\n  ```\n\n- **`setUrl(url)`** - Set the current request URL.\n  ```javascript\n  req.setUrl(\"\n  ```\n\nHTTP Method\n\n\n- **`getMethod()`** - Get the current request method.\n  ```javascript\n  const method = req.getMethod();\n  ```\n\n- **`setMethod(method)`** - Set the current request method.\n  ```javascript\n  req.setMethod(\"POST\");\n  ```\n\nRequest Information\n\n\n- **`getName()`** - Get the current request name.\n  ```javascript\n  const name = req.getName();\n  ```\n\n- **`getAuthMode()`** - Get the current authentication mode.\n  ```javascript\n  let authMode = req.getAuthMode();\n  ```\n\n- **`getTags()`** - Get the current request tags as an array of strings. This method allows you to access the tags associated with the current request, which can be useful for conditional logic, filtering, or organizing requests based on their tags.\n  \n  **Returns:** Array of strings representing the request tags\n  ```javascript\n  const tags = req.getTags();\n  console.log(\"Request tags:\", tags);\n\n  // Check if request has specific tags\n  if (tags.includes(\"smoke-test\")) {\n      console.log(\"This is a smoke test request\");\n  }\n\n  // Use tags for conditional logic\n  if (tags.includes(\"skip-in-ci\")) {\n      bru.runner.skipRequest();\n  }\n\n  // Filter based on tags\n  if (tags.includes(\"integration-test\")) {\n      // Run additional integration test logic\n      console.log(\"Running integration test validations\");\n  }\n  ```\n\nHeader Methods\n\n\n- **`getHeader(name)`** - Get the request header by name.\n  ```javascript\n  req.getHeader(\"transaction-id\");\n  ```\n\n- **`getHeaders()`** - Get all request headers.\n  ```javascript\n  const headers = req.getHeaders();\n  ```\n\n- **`setHeader(name, value)`** - Set a request header by name.\n  ```javascript\n  req.setHeader(\"content-type\", \"application/json\");\n  ```\n\n- **`setHeaders(headers)`** - Set multiple request headers.\n  ```javascript\n  req.setHeaders({\n    \"content-type\": \"application/json\",\n    \"transaction-id\": \"foobar\",\n  });\n  ```\n\nBody Methods\n\n\n- **`getBody(options?)`** - Get the current request body/payload.\n  \n  **Parameters:**\n  - `options` (object, optional): Configuration options\n    - `raw` (boolean): When `true`, returns the raw body without any parsing. When `false` or not provided, returns the parsed body (default behavior).\n\n  **Examples:**\n  ```javascript\n  // Get parsed body (default)\n  const body = req.getBody();\n\n  // Get raw body without parsing\n  const rawBody = req.getBody({ raw: true });\n  ```\n\n- **`setBody(body)`** - Set the request body/payload.\n  ```javascript\n  req.setBody({\n    username: \"john nash\",\n    password: \"governingdynamics\",\n  });\n  ```\n\nRequest Configuration\n\n\n- **`setTimeout(milliseconds)`** - Set a timeout for the request.\n  ```javascript\n  req.setTimeout(5000); // Sets the timeout to 5000 milliseconds (5 seconds)\n  ```\n\n- **`getTimeout()`** - Get the current timeout value of the request.\n  ```javascript\n  const timeout = req.getTimeout();\n  console.log(timeout); // Logs the current timeout value\n  ```\n\n- **`setMaxRedirects(count)`** - Set the maximum number of redirects to follow.\n  ```javascript\n  req.setMaxRedirects(5);\n  ```\n\nExecution Context\n\n\n- **`getExecutionMode()`** - Get the current active execution mode of the request.\n  \n  **Returns:**\n  - `runner`: When the request is being executed as part of a collection run\n  - `standalone`: When the request is being executed individually\n  ```javascript\n  const executionMode = req.getExecutionMode();\n  console.log(`Request is running in ${executionMode} mode`);\n  ```\n\n- **`getExecutionPlatform()`** - Get the platform on which the request is being executed.\n  \n  **Returns:**\n  - `app`: When running in the Bruno desktop application\n  - `cli`: When running through the Bruno CLI\n  ```javascript\n  const platform = req.getExecutionPlatform();\n  console.log(`Request is running on ${platform} platform`);\n  ```\n\nError Handling\n\n\n- **`onFail(callback)`** - Handle request errors with a custom callback function. This is useful for implementing custom error handling logic, logging, or taking specific actions when a request fails.\n  \n  **Parameters:**\n  - `error`: The error object containing details about the request failure\n\n  **Example:**\n  ```javascript\n  // Handle request failures with custom logic\n  req.onFail((error) => {\n    console.error('Request failed:', error.message);\n    \n    // Log error details for debugging\n    console.log('Error details:', {\n      status: error.status,\n      statusText: error.statusText,\n      url: error.url,\n      method: error.method\n    });\n    \n    // Set a variable to track failure\n    bru.setVar('lastError', error.message);\n  });\n  ```\n\n\nThe `onFail` function is only available in Developer mode and should be called in pre-request scripts.\n\n\nResponse\n\n\nThe `res` variable represents the HTTP response object and is automatically available inside your scripting and testing context after a request is executed. It contains all the information about the response received from the server, including status codes, headers, body data, and timing information.\n\n\n  The `res` object is only available in post-request scripts and test scripts, as it contains the response data from the completed request.\n\n\nHere is a complete table for all available properties and methods on the `res` object.\n\n| Property / Method              | Description                                                                    |\n| ------------------------------ | ------------------------------------------------------------------------------ |\n| res.status                     | The HTTP response status code (e.g., 200, 404, 500).                          |\n| res.statusText                 | The HTTP response status text (e.g., \"OK\", \"Not Found\").                      |\n| res.headers                    | An object containing all response headers.                                     |\n| res.body                       | The response body data (automatically parsed as JSON if applicable).           |\n| res.responseTime               | The total time taken for the request in milliseconds.                          |\n| res.url                        | The final response URL (after following redirects).                            |\n| res.getStatus()                | Get the response status code.                                                  |\n| res.getStatusText()            | Get the response status text.                                                  |\n| res.getHeader(name)            | Get a specific response header by name.                                        |\n| res.getHeaders()               | Get all response headers.                                                      |\n| res.getBody(options?)          | Get the response body data (supports raw option).                              |\n| res.setBody(body)              | Set the response body data.                                                    |\n| res.getResponseTime()          | Get the response time in milliseconds.                                         |\n| res.getUrl()                   | Get the response URL (final URL after redirects).                              |\n| res.getSize()                  | Get the response size in bytes (returns object with body, headers, total).     |\n\n\n  The `body` property is automatically parsed as JSON if the response has a JSON content type. For other content types, it will be a string.\n\n\nBelow are the detailed descriptions for properties and methods available on the `res` object.\n\nResponse Properties\n\n\n- **`res.status`** - The HTTP response status code (e.g., 200, 404, 500).\n  ```javascript\n  console.log(res.status); // 200\n  ```\n\n- **`res.statusText`** - The HTTP response status text (e.g., \"OK\", \"Not Found\", \"Internal Server Error\").\n  ```javascript\n  console.log(res.statusText); // \"OK\"\n  ```\n\n- **`res.headers`** - An object containing all response headers.\n  ```javascript\n  console.log(res.headers);\n  ```\n\n- **`res.body`** - The response body data (automatically parsed as JSON if the response has a JSON content type).\n  ```javascript\n  console.log(res.body);\n  ```\n\n- **`res.responseTime`** - The total time taken for the request in milliseconds.\n  ```javascript\n  console.log(res.responseTime); // 245\n  ```\n\n- **`res.url`** - The final response URL (after following redirects).\n  ```javascript\n  console.log(res.url);\n  ```\n\nStatus Methods\n\n\n- **`getStatus()`** - Get the response status code.\n  ```javascript\n  let status = res.getStatus();\n  ```\n\n- **`getStatusText()`** - Get the response status text.\n  ```javascript\n  let statusText = res.getStatusText();\n  ```\n\nHeader Methods\n\n\n- **`getHeader(name)`** - Get a specific response header by name.\n  ```javascript\n  let transactionId = res.getHeader(\"transaction-id\");\n  ```\n\n- **`getHeaders()`** - Get all response headers.\n  ```javascript\n  let headers = res.getHeaders();\n  ```\n\nBody Methods\n\n\n- **`getBody(options?)`** - Get the response body data.\n  \n  **Parameters:**\n  - `options` (object, optional): Configuration options\n    - `raw` (boolean): When `true`, returns the raw response body without any parsing. When `false` or not provided, returns the parsed body (default behavior).\n\n  **Examples:**\n  ```javascript\n  // Get parsed response data (default)\n  let data = res.getBody();\n\n  // Get raw response body without parsing\n  let rawData = res.getBody({ raw: true });\n  ```\n\n- **`setBody(body)`** - Set the response body data.\n  ```javascript\n  res.setBody({ message: \"Custom response data\" });\n  ```\n\nURL Methods\n\n\n- **`getUrl()`** - Get the response URL. In case of redirects, you will get the final URL which may be different from the original request URL if redirects were followed. This functionality is also available as a property `res.url`.\n\n  \n    This method is only available in post-response scripts and test scripts.\n  \n\n  **Returns:** Response URL as a string.\n\n  **Example:**\n  ```javascript\n  // Get the response URL\n  const responseUrl = res.getUrl();\n  console.log(\"Response URL:\", responseUrl);\n\n  // Test that the response URL is as expected\n  test(\"should end up at correct URL after redirects\", () => {\n    const url = res.getUrl();\n    expect(url).to.equal(\"\n  });\n  ```\n\nTiming & Size Methods\n\n\n- **`getResponseTime()`** - Get the response time in milliseconds.\n  ```javascript\n  let responseTime = res.getResponseTime();\n  ```\n\n- **`getSize()`** - Get the response size in bytes. Returns an object with the following properties:\n  - `body`: number\n  - `headers`: number\n  - `total`: number\n\n  **Example:**\n  ```javascript\n  const responseSize = res.getSize();\n  \n  test(\"Response body size is less than 1KB\", () => {\n    const responseSize = res.getSize().body;\n    expect(responseSize).to.be.lessThan(1024);\n  });\n  ```\n\nBru\n\n\nThe `bru` variable is available inside your scripting and testing context.\nIt exposes methods that allow you to interact with, e.g., process variables,\nenvironment variables and collection variables.\n\nHere is a complete table for all available methods with the `bru`.\n\n| Title                            | Description                                               |\n| -------------------------------- | --------------------------------------------------------- |\n| bru.cwd()                        | Returns the current working directory.                    |\n| bru.getEnvName()                 | Retrieves the environment name.                           |\n| bru.getProcessEnv(key)           | Fetches the process environment variable for a given key. |\n| bru.hasEnvVar(key)               | Checks if the environment variable exists.                |\n| bru.getEnvVar(key)               | Retrieves the value of an environment variable.           |\n| bru.getFolderVar(key)            | Fetches a folder-specific variable by key.                |\n| bru.getCollectionVar(key)        | Retrieves the collection-level variable for the key.      |\n| bru.setEnvVar(key, value)        | Sets a new environment variable.                          |\n| bru.deleteEnvVar(key)            | Deletes a specific environment variable.                  |\n| bru.hasVar(key)                  | Checks if a variable exists.                              |\n| bru.getVar(key)                  | Retrieves the value of a variable.                        |\n| bru.setVar(key, value)           | Sets a new variable with a key-value pair.                |\n| bru.deleteVar(key)               | Deletes a specific variable.                              |\n| bru.deleteAllVars()              | Deletes all runtime variables.                                    |\n| bru.setNextRequest(requestName)  | Sets the next request to execute.                         |\n| req.disableParsingResponseJson() | Disables JSON response parsing for the request.           |\n| bru.getRequestVar(key)           | Retrieves the value of a request variable.                |\n| bru.runRequest(requestPathName)  | Executes a request by its path name.                      |\n| bru.getAssertionResults()        | Retrieves the results of assertions.                      |\n| bru.getTestResults()             | Fetches the test                                          |\n| bru.sendRequest(options, callback) | Sends a programmatic HTTP request within your script |\n| bru.getOauth2CredentialVar(key)  | Retrieves an OAuth2 credential variable value.            |\n| bru.getCollectionName()          | Retrieves the current collection name.                    |\n| bru.cookies.jar()                | Creates a cookie jar instance for managing cookies.        |\n\n\nBelow is the API documentation for the methods available on `bru`\n\nHTTP Request Methods\n\n\n- **`sendRequest(options, callback)`** - Send a programmatic HTTP request within your script. This allows you to make additional API calls during script execution.\n  \n  **Parameters:**\n  - `method`: HTTP method (GET, POST, PUT, etc.)\n  - `url`: The URL to send the request to\n  - `headers`: (Optional) Request headers\n  - `data`: (Optional) Request data. Can be a string or object\n  - `timeout`: (Optional) Request timeout in milliseconds\n  - `callback`: Function to handle the response with signature `(err, res)`\n\n  **Example:**\n  ```javascript\n  await bru.sendRequest({\n    method: 'POST',\n    url: '\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    data: { key: 'value' },\n  }, function (err, res) {\n    if (err) {\n      console.error('Error:', err);\n      return;\n    }\n    console.log('Response:', res.data);\n  });\n  ```\n\nHelper Functions\n\n\n- **`sleep(milliseconds)`** - Pauses execution for the specified duration. This is useful for introducing delays or waiting for a specific amount of time before proceeding with the next operation.\n  ```javascript\n  await bru.sleep(3000);\n  ```\n\n- **`interpolate(string)`** - Evaluates dynamic variables and environment variables within a string. This function allows you to use Bruno's dynamic variables (like `{{$randomFirstName}}`) directly in your scripts.\n  ```javascript\n  // Generate a random first name\n  const firstName = bru.interpolate('{{$randomFirstName}}');\n  console.log('Random first name:', firstName);\n\n  // Generate a random email\n  const email = bru.interpolate('{{$randomEmail}}');\n\n  // Generate multiple dynamic values in one call\n  const userInfo = bru.interpolate(`\n    Name: {{$randomFullName}}\n    Job: {{$randomJobTitle}}\n    Email: {{$randomEmail}}\n  `);\n  ```\n\n- **`disableParsingResponseJson()`** - Prevent the automatic parsing of the JSON response body and work directly with the raw data. Use this in the pre-request script of the request.\n  ```javascript\n  bru.disableParsingResponseJson();\n  ```\n\n- **`cwd()`** - Returns the current working directory.\n  ```javascript\n  const currentDir = bru.cwd();\n  console.log('Current directory:', currentDir);\n  ```\n\nVariables\n\n\nBruno provides a comprehensive variable system that allows you to manage and access different types of variables throughout your scripts. These include process environment variables, environment variables, collection variables, folder variables, request variables, and runtime variables.\n\n**Process Environment Variables**\n\n- **`getProcessEnv(key)`** - Get the Node process environment variable. This allows secret token usage without committing secrets to version control.\n  ```javascript\n  let secret_token = bru.getProcessEnv(\"secret_access_token\");\n  ```\n\n**Environment Variables**\n\n- **`getEnvName()`** - Retrieves the current environment name.\n  ```javascript\n  const envName = bru.getEnvName();\n  console.log('Current environment:', envName);\n  ```\n\n- **`getEnvVar(key)`** - Get the Bruno environment variable.\n  ```javascript\n  let token = bru.getEnvVar(\"access_token\");\n  ```\n\n- **`setEnvVar(key, value, options?)`** - Set the Bruno environment variable. By default, environment variables are temporary and do not persist between app restarts.\n  \n  **Parameters:**\n  - `key` (string): The environment variable name\n  - `value` (any): The value to set\n  - `options` (object, optional): Configuration options\n    - `persist` (boolean): When `true`, saves the variable to file system. When `false` or not provided, maintains in-memory behavior.\n\n  **Examples:**\n  ```javascript\n  // In-memory only (default behavior)\n  bru.setEnvVar(\"sessionId\", \"temp\");\n\n  // Persist to file system\n  bru.setEnvVar(\"apiToken\", \"12345\", { persist: true });\n\n  // In post-response script\n  function onResponse(res) {\n    let data = res.getBody();\n    let token = bru.setEnvVar(\"access_token\", data.token, { persist: true });\n  }\n  ```\n\n- **`hasEnvVar(key)`** - Check if the environment variable exists.\n  ```javascript\n  if (bru.hasEnvVar(\"access_token\")) {\n    console.log(\"Token exists\");\n  }\n  ```\n\n- **`deleteEnvVar(key)`** - Delete a specific environment variable.\n  ```javascript\n  bru.deleteEnvVar(\"access_token\");\n  ```\n\n- **`getGlobalEnvVar(key)`** - Get the Bruno global environment variable.\n  ```javascript\n  const val = bru.getGlobalEnvVar(\"val\");\n  ```\n\n- **`setGlobalEnvVar(key, value)`** - Set the Bruno global environment variable.\n  ```javascript\n  bru.setGlobalEnvVar(\"val\", \"bruno\");\n  ```\n\n**Collection Variables**\n\n- **`getCollectionVar(key)`** - Get the collection variable.\n  ```javascript\n  let namespace = bru.getCollectionVar(\"namespace\");\n  ```\n\n- **`getCollectionName()`** - Retrieve the name of the current collection.\n  ```javascript\n  const collectionName = bru.getCollectionName();\n  console.log('Current collection:', collectionName);\n  ```\n\n**Folder Variables**\n\n- **`getFolderVar(key)`** - Get the folder variable.\n  ```javascript\n  let company = bru.getFolderVar(\"company\");\n  ```\n\n**Request Variables**\n\n- **`getRequestVar(key)`** - Get the request variable.\n  ```javascript\n  let source = bru.getRequestVar(\"source\");\n  let destination = bru.getRequestVar(\"destination\");\n  ```\n\n**Runtime Variables**\n\n- **`hasVar(key)`** - Check if a runtime variable exists.\n  ```javascript\n  if (bru.hasVar(\"petId\")) {\n    console.log(\"Pet ID exists\");\n  }\n  ```\n\n- **`getVar(key)`** - Get the runtime variable.\n  ```javascript\n  let petId = bru.getVar(\"petId\");\n  ```\n\n- **`setVar(key, value)`** - Set the runtime variable.\n  ```javascript\n  let data = res.getBody();\n  bru.setVar(\"petId\", data.id);\n  ```\n\n- **`deleteVar(key)`** - Delete the runtime variable.\n  ```javascript\n  bru.deleteVar(\"petId\");\n  ```\n\n- **`deleteAllVars()`** - Delete all runtime variables.\n  ```javascript\n  bru.deleteAllVars();\n  ```\n\nRequest Execution & Order\n\n\nThis section covers methods for executing requests and controlling the execution flow in Bruno, including collection runner utilities.\n\n**Running Requests**\n\n- **`runRequest(requestPathName)`** - Execute any request in the collection and retrieve the response directly within the script.\n\n  \n    Avoid using `bru.runRequest()` in **collection-level scripts**. Since collection scripts run for all requests, calling `bru.runRequest()` from a collection script will trigger the target request, which will also execute the collection script again, creating an infinite loop.\n  \n\n  **Example:**\n  ```javascript\n  const requestResponse = await bru.runRequest(\"echo/echo json\");\n  ```\n\n**Controlling Execution Order**\n\n- **`setNextRequest(requestName)`** - Change the order of request execution. By default, the collection runner (UI) and the CLI run requests in order. You can change the order by calling `setNextRequest` with the name of the next request to be run. This works only in a post-request script or test-script.\n\n  **How it works:**\n  - `setNextRequest` works with **single requests** - it executes the current request first, then jumps to the specified request\n  - It **skips** all requests between the current one and the target request\n  - The target request must exist in the collection and be specified by its exact name\n  - **For requests inside folders**: Use just the request name (e.g., \"request-name\"), not the full path\n  - Works the same way with both `bru.setNextRequest()` and `bru.runner.setNextRequest()`\n\n  **Examples:**\n  ```javascript\n  // Basic usage - in post-request script of \"one.bru\"\n  bru.setNextRequest(\"three\"); // Will skip \"two.bru\" and jump to \"three.bru\"\n\n  // Request inside folder - use just the request name\n  bru.setNextRequest(\"request-name\");\n\n  // Abort the run gracefully\n  bru.setNextRequest(null);\n  ```\n\n- **`bru.runner.setNextRequest(requestName)`** - Alter the order of requests by specifying the name of the next request to execute. This function is applicable only within post-request scripts or test scripts.\n  ```javascript\n  bru.runner.setNextRequest(\"Get process status\");\n  ```\n\n**Collection Runner Utilities**\n\n- **`bru.runner.skipRequest()`** - Skip the execution of the current request. Use this in the pre-request script section. This function is valid only within the context of a collection run.\n  ```javascript\n  bru.runner.skipRequest();\n  ```\n\n- **`bru.runner.stopExecution()`** - Terminate a collection run. This function can be called from a pre-request, post-response, or test script and only takes effect during a collection run.\n  ```javascript\n  bru.runner.stopExecution();\n  ```\n\nTest Utilities\n\n\n- **`getTestResults()`** - Obtain the test results of a request. Use this within test scripts.\n  ```javascript\n  const testResults = await bru.getTestResults();\n  ```\n\n- **`getAssertionResults()`** - Obtain the assertion results of a request. Use this within test scripts.\n  ```javascript\n  const assertionResults = await bru.getAssertionResults();\n  ```\n\nOAuth2 Credentials\n\n\n- **`getOauth2CredentialVar(key)`** - Retrieve an OAuth2 credential variable value. This is useful for accessing OAuth2 tokens and credentials.\n  ```javascript\n  const accessToken = bru.getOauth2CredentialVar(\"access_token\");\n  ```\n\nCookie Management\n\n\nBruno provides Cookie Jar APIs that enable programmatic cookie management in request scripts. These APIs allow you to set, get, and delete cookies programmatically using a cookie jar instance.\n\n\n  Cookie management APIs are available in pre-request scripts, post-request scripts, and test scripts.\n\n\n**Creating a Cookie Jar**\n\n- **`cookies.jar()`** - Create a cookie jar instance for managing cookies.\n  \n  **Returns:** A cookie jar instance with methods for cookie management\n  ```javascript\n  const jar = bru.cookies.jar();\n  ```\n\n**Cookie Jar Methods**\n\nOnce you have a cookie jar instance, you can use the following methods:\n\n- **`jar.setCookie(url, name, value)`** or **`jar.setCookie(url, cookieObject)`** - Set a single cookie with specified attributes. This method has two overloads for different use cases.\n  \n  **Parameters (Key-value format):**\n  - `url`: The URL for which the cookie should be set\n  - `name`: The name of the cookie\n  - `value`: The value of the cookie\n\n  **Parameters (Object format):**\n  - `url`: The URL for which the cookie should be set\n  - `cookieObject`: Cookie object with properties: `key`, `value`, `domain`, `path`, `expires`, `maxAge`, `secure`, `httpOnly`, `sameSite`\n\n  **Example:**\n  ```javascript\n  const jar = bru.cookies.jar();\n\n  // Set a simple cookie using key-value format\n  jar.setCookie(\" \"sessionId\", \"abc123\");\n\n  // Set a cookie with options using object format\n  jar.setCookie(\" {\n    key: \"userToken\",\n    value: \"xyz789\",\n    domain: \"example.com\",\n    path: \"/api\",\n    secure: true,\n    httpOnly: true,\n    maxAge: 3600 // 1 hour\n  });\n  ```\n\n- **`jar.setCookies(url, cookies)`** - Set multiple cookies at once using an array of cookie objects.\n  \n  **Parameters:**\n  - `url`: The URL for which the cookies should be set\n  - `cookies`: Array of cookie objects\n\n  **Example:**\n  ```javascript\n  const jar = bru.cookies.jar();\n\n  jar.setCookies(\" [\n    {\n      key: \"sessionId\",\n      value: \"abc123\",\n      secure: true,\n      httpOnly: true\n    },\n    {\n      key: \"userPreference\",\n      value: \"dark-mode\",\n      path: \"/\",\n      maxAge: 86400 // 24 hours\n    }\n  ]);\n  ```\n\n- **`jar.getCookie(url, name)`** - Get a specific cookie by name.\n  \n  **Returns:** The cookie object or `null` if not found\n\n  **Example:**\n  ```javascript\n  const jar = bru.cookies.jar();\n  const sessionCookie = await jar.getCookie(\" \"sessionId\");\n  if (sessionCookie) {\n    console.log(\"Session ID:\", sessionCookie.value);\n    console.log(\"Expires:\", sessionCookie.expires);\n  }\n  ```\n\n- **`jar.getCookies(url)`** - Get all cookies for a specific URL.\n  \n  **Returns:** Array of cookie objects or empty array if no cookies found\n\n  **Example:**\n  ```javascript\n  const jar = bru.cookies.jar();\n  const allCookies = await jar.getCookies(\"\n  console.log(\"All cookies:\", allCookies);\n  ```\n\n- **`jar.deleteCookie(url, name)`** - Delete a specific cookie by name.\n\n  \n    When deleting cookies, the domain and path options must match the original cookie's domain and path for the deletion to be successful.\n  \n\n  **Example:**\n  ```javascript\n  const jar = bru.cookies.jar();\n  jar.deleteCookie(\" \"sessionId\");\n  ```\n\n- **`jar.deleteCookies(url)`** - Delete all cookies for a specific URL.\n  ```javascript\n  const jar = bru.cookies.jar();\n  jar.deleteCookies(\"\n  ```\n\n- **`jar.clear()`** - Clear all cookies from the cookie jar.\n  ```javascript\n  const jar = bru.cookies.jar();\n  jar.clear();\n  ```\n\n",
    "parentName": "testing",
    "path": "testing/script/javascript-reference"
  },
  "testing/script/js-file": {
    "name": "js-file",
    "content": "import Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nCreating a JS File in Bruno \n\n\nBruno provides the ability to create JavaScript tests where you can modularize common code and reuse the tests across different requests or collections.\n\nThis can be especially helpful in complex scripting scenarios where the same test will be run across multiple requests, or you're looking to leverage data that lays outside of Bruno.\n\nCreate a New Script\n\n\nYou can generate a JS File by:\n\n1. Right clicking on any collection or folder\n2. Select `New Script` from dropdown.\n\n![select-script](/screenshots/create-js-file/new-script.webp)\n\n3. Enter name and select **Create**\n\n![create-script](/screenshots/create-js-file/sample-js.webp)\n\nImport the Function(s)\n\n\nOnce your JS File has been created, you can now import the functions into any `Script` tab across your resources.\n\n![import-script](/screenshots/create-js-file/js-file.webp)\n\n![import-script](/screenshots/create-js-file/import-js-file.webp)\n\nHere:\n\n1. `getUserById` finds and returns a user object from the users array based on the provided id.\n2. `bru.setVar()` sets the `val` variable to the id of the fetched user.\n3. In the url `{{val}}` is replaced with value (e.g., 2), resulting in `\n\nWhen the requests are run, you will see the script being invoked.\n\nSharing Scripts Across Collections\n\n\nThe `additionalContextRoots` feature in Bruno allows you to share scripts across multiple collections, eliminating code duplication and promoting better code organization. This is particularly useful when you have common utility functions or shared logic that you want to use across different collections.\n\n\nMake sure you're in Developer Mode to use `additionalContextRoots` feature.\n\n\nHow to Use\n\n\n1. Create a Shared Scripts Directory\n\n\nFirst, create a directory to store your shared scripts. This can be anywhere in your project structure, but it's common to place it at the root level of your project.\n\n```bash\nproject/\nâ”œâ”€â”€ collection-a/\nâ”‚   â””â”€â”€ bruno.json\nâ”œâ”€â”€ collection-b/\nâ”‚   â””â”€â”€ bruno.json\nâ””â”€â”€ shared-scripts/\n    â””â”€â”€ utils.js\n```\n\n2. Configure bruno.json\n\n\nIn each collection's `bruno.json` file, add the `additionalContextRoots` configuration under the `scripts` object:\n\n```json showLineNumbers\n{\n  \"scripts\": {\n    \"additionalContextRoots\": [\"./path/to/shared/scripts\"]\n  }\n}\n```\n\n3. Create Shared Scripts\n\n\nCreate your shared scripts in the specified directory. For example: `shared-scripts/utils.js`:\n\n```javascript showLineNumbers\n// shared-scripts/utils.js\nconst formatDate = (date) => {\n  return new Date(date).toISOString();\n};\n\nconst generateAuthToken = (apiKey) => {\n  return `Bearer ${apiKey}`;\n};\n\nmodule.exports = {\n  formatDate,\n  generateAuthToken\n};\n```\n\n4. Use Shared Scripts in Collections\n\n\nYou can now use these shared scripts in your collection's pre-request or post-response scripts:\n\n```javascript showLineNumbers\n// In your collection's pre-request script\nconst { formatDate, generateAuthToken } = require('../shared-scripts/utils.js');\n\n// Use the shared functions\nconst today = formatDate(new Date());\nconst token = generateAuthToken('your-api-key');\n\n// Set environment variables or request headers\nbru.setEnvVar('auth_token', token);\nbru.setEnvVar('current_date', today);\n```\n\n",
    "parentName": "testing",
    "path": "testing/script/js-file"
  },
  "testing/script/request/request-object": {
    "name": "request-object",
    "content": "Request Object\n\n\nThe `req` object represents the HTTP request made to the server. It contains various properties that define the request details.\n\n`req` Sub-Object\n\n\nThe `req` sub-object contains detailed information about the request.\n\n- `assertions` : An array containing any assertions associated with the request. *See [assertions](../../tests/assertions)*.\n- `auth` : An object containing authentication credentials, such as username and password.\n- `headers` : A sub-object representing the HTTP headers associated with the request.\n- `method` : The HTTP method used for the request (e.g., \"GET\", \"POST\").\n- `mode` : The mode of the request (e.g., \"none\", \"cors\").\n- `responseType` : The expected response type for the request (e.g., \"text\", \"json\").\n- `script` : An object containing script-related information for the request.\n- `signal` : A signal object used to abort the request.\n- `url` : The URL of the request.\n- `vars` : An object containing any variables associated with the request. *See [variables](../../script/vars)*.\n\nHeaders\n\n\nThe `headers` sub-object of the `req` object contains key-value pairs representing the HTTP headers associated with the request.\n\n```javascript\n// Example usage\nconsole.log(req.headers);\n/* Output: {\n  authorization: 'Bearer ',\n  'content-type': 'application/json',\n  accept: 'application/json',\n  // Add more headers as needed...\n} */\n```\n\nMethod\n\n\nThe `method` property of the `req` object specifies the HTTP method used for the request. Common HTTP methods include \"GET\", \"POST\", \"PUT\", \"DELETE\", etc. The method indicates the type of action the request wishes to perform on the resource. The value of the `method` property should be a string representing the desired HTTP method for the request.\n\n```javascript\n// Example usage\nconsole.log(req.method); // Output: \"GET\"\n```\n\nURL\n\n\nThe `url` property of the `req` object represents the Uniform Resource Locator (URL) of the request. It specifies the address of the resource being requested by the client. Variables enclosed within double curly braces (`{{...}}`) in the URL string are placeholders that may be replaced with actual values at runtime. These variables are not directly visible within the URL string and are typically encapsulated during request processing.\n\n```javascript\n// Example usage\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\n```\n\n\nExample Usage\n\n\n```javascript\n// Example request object\nconst req = {\n  assertions: [],\n  auth: { username: 'myUsername', password: 'mySuperPassword' },\n  headers: {\n    authorization: 'Bearer ',\n    'content-type': 'application/json',\n    accept: 'application/json',\n    // Add more headers as needed...\n  },\n  method: 'GET',\n  mode: 'none',\n  responseType: 'arraybuffer',\n  script: {\n    req: \"// Create an array of objects\\nconst data = [\\n  { iâ€¦q);\\nconst myVariable = bru.getEnvVar('password');\"\n  },\n  signal: {},\n  url: '{{base.url}}/users/2?queryTest=queryResult',\n  vars: {}\n};\n\n\n// Accessing request properties\nconsole.log(req.method); // Output: \"GET\"\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\nconsole.log(req.headers.authorization); // Output: \"Bearer \"\nconsole.log(req.auth.username); // Output: \"myUsername\"\n```",
    "parentName": "testing",
    "path": "testing/script/request/request-object"
  },
  "testing/script/request/sync-requests": {
    "name": "sync-requests",
    "content": "Sync requests\n\n\nYou can make synchronous requests in your pre/post scripts. By synchronous, we mean that you can await a request in your scripting code.\n\nBelow is an inbuilt example of using `axios` library to\n```js\nconst axios = require(\"axios\");\n\nconst response = await axios.get(\"\n\nbru.setVar(\"avatarUrl\", response.data.avatar_url);\n```\n\n**Example:**\n![sync requests](/screenshots/sync-requests.webp)\n\n",
    "parentName": "testing",
    "path": "testing/script/request/sync-requests"
  },
  "testing/script/request-chaining": {
    "name": "request-chaining",
    "content": "import { Callout } from \"nextra/components\";\n\nRequest Chaining\n\n\nRequest chaining in Bruno allows you to execute multiple requests in sequence, pass data between them, and control the flow of your API testing workflow. This powerful feature enables you to build complex test scenarios where the output of one request becomes the input for the next.\n\nOverview\n\n\nBruno provides several methods for request chaining:\n\n- **`bru.runRequest()`** - Execute requests within your collection\n- **`bru.sendRequest()`** - Send programmatic HTTP requests\n- **`bru.runner.setNextRequest()`** - Control request execution order in collection runs\n\n`bru.runRequest()`\n\n\nExecute any request in your collection and retrieve the response directly within your script.\n\n\n  Avoid using `bru.runRequest()` in **collection-level scripts**. Since collection scripts run for all requests, calling `bru.runRequest()` from a collection script will trigger the target request, which will also execute the collection script again, creating an infinite loop.\n\n\nSyntax\n\n\n```javascript showLineNumbers\nconst requestResponse = await bru.runRequest(\n  \"absolute/path/to/a/request/from/collection/root\"\n);\n```\n\nParameters\n\n\n- **requestPath**: The absolute path to the request from the collection root (string)\n\nReturns\n\n\nReturns a response object containing:\n- `status`: HTTP status code\n- `statusText`: HTTP status text\n- `headers`: Response headers object\n- `body`: Response body (automatically parsed if JSON)\n- `responseTime`: Response time in milliseconds\n\nExamples\n\n\nBasic Request Execution\n\n\n```javascript showLineNumbers {2,5-6}\n// Execute a request and get the response\nconst response = await bru.runRequest(\"auth/login\");\n\n// Check if login was successful\nif (response.status === 200) {\n  const data = response.body;\n  bru.setVar(\"authToken\", data.token);\n  console.log(\"Login successful, token saved\");\n} else {\n  console.error(\"Login failed:\", response.statusText);\n}\n```\n\n`bru.sendRequest()`\n\n\nSend a programmatic HTTP request within your script. This allows you to make additional API calls during script execution.\n\nSyntax\n\n\n```javascript showLineNumbers \nawait bru.sendRequest({\n  method: string,\n  url: string,\n  headers?: object,\n  data?: string | object,\n  timeout?: number\n}, callback)\n```\n\nParameters\n\n\n- **method**: HTTP method (GET, POST, PUT, DELETE, etc.)\n- **url**: The URL to send the request to\n- **headers**: (Optional) Request headers object\n- **data**: (Optional) Request data. Can be a string or object\n- **timeout**: (Optional) Request timeout in milliseconds\n- **callback**: Function to handle the response with signature `(err, res)`\n\nExamples\n\n\nBasic HTTP Request\n\n\n```javascript showLineNumbers {1,8-9}\nawait bru.sendRequest({\n  method: 'GET',\n  url: '\n  headers: {\n    'Authorization': 'Bearer ' + bru.getVar('authToken'),\n    'Content-Type': 'application/json'\n  }\n}, function (err, res) {\n  if (err) {\n    console.error('Error:', err);\n    return;\n  }\n  console.log('Users:', res.data);\n  bru.setVar('users', res.data);\n});\n```\n\nPOST Request with Data\n\n\n```javascript showLineNumbers {1-4,13}\nconst userData = {\n  name: 'John Doe',\n  email: 'john@example.com'\n};\n\nawait bru.sendRequest({\n  method: 'POST',\n  url: '\n  headers: {\n    'Authorization': 'Bearer ' + bru.getVar('authToken'),\n    'Content-Type': 'application/json'\n  },\n  data: userData,\n  timeout: 10000\n}, function (err, res) {\n  if (err) {\n    console.error('Error creating user:', err);\n    return;\n  }\n  \n  if (res.status === 201) {\n    console.log('User created:', res.data);\n    bru.setVar('newUserId', res.data.id);\n  }\n});\n```\n\n`bru.runner.setNextRequest()`\n\n\nControl the order in which requests are executed during collection runs. This allows you to skip requests or change the execution flow based on conditions.\n\n\n  `bru.runner.setNextRequest()` works only in **post-request scripts** or **test scripts**.\n\n\nSyntax\n\n\n```javascript showLineNumbers\nbru.runner.setNextRequest(\"request-name\");\n```\n\nParameters\n\n\n- **requestName**: The name of the next request to execute (string) or `null` to stop execution\n\nHow it works\n\n\n- `setNextRequest` works with **single requests** - it executes the current request first, then jumps to the specified request\n- It **skips** all requests between the current one and the target request\n- The target request must exist in the collection and be specified by its exact name\n- **For requests inside folders**: Use just the request name (e.g., \"request-name\"), not the full path\n\nExamples\n\n\nConditional Request Execution\n\n\n```javascript showLineNumbers\n// In post-request script\nconst response = res.getBody();\n\nif (response.status === 'active') {\n  // Continue to next request\n  bru.runner.setNextRequest(\"process-active-user\");\n} else if (response.status === 'inactive') {\n  // Skip to different request\n  bru.runner.setNextRequest(\"handle-inactive-user\");\n} else {\n  // Stop execution\n  bru.runner.setNextRequest(null);\n}\n```\n\n- **Use `bru.runRequest()`** for requests within your collection (faster, uses existing configuration)\n- **Use `bru.sendRequest()`** for external APIs or when you need custom request configuration\n- **Avoid nested loops** that could cause infinite request chains\n\n",
    "parentName": "testing",
    "path": "testing/script/request-chaining"
  },
  "testing/script/response/response-object": {
    "name": "response-object",
    "content": "Response Object\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](../../tests/assertions), [scripting](../getting-started) and [testing](../../tests/introduction)\ncontexts can be used to extract values from the response body, headers and status.\n\n*Note that the `res` object is only available in the context of a request.*\n\nYou can also access it with [response queries](./response-query).\n\nObject Structure\n\n\nThe `res` object has the following properties:\n\n- `body`: Represents the response body containing data returned to the client.\n- `headers`: Contains key-value pairs representing HTTP headers associated with the response.\n- `status`: Represents the HTTP status code indicating the outcome of the request.\n\nProperty Descriptions\n\n\n`body`\n\n\nThe `body` property of the `res` object contains the response data sent to the client. It can be a string, an object, or a stream, depending on the application's needs.\n\n`headers`\n\n\nThe `headers` property contains HTTP headers associated with the response. These headers provide metadata about the response, such as content type, encoding, and caching directives.\n\n`status`\n\n\nThe `status` property represents the HTTP status code of the response. It indicates the outcome of the request, such as success, redirection, client error, or server error.\n\nExample Usage\n\n\n```javascript\n// Example response object\nconst res = {\n  body: '{\"message\": \"Hello, world!\"}',\n  headers: {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache',\n  },\n  status: 200,\n};\n\n// Accessing response properties\nconsole.log(res.body); // Output: '{\"message\": \"Hello, world!\"}'\nconsole.log(res.headers['Content-Type']); // Output: 'application/json'\nconsole.log(res.status); // Output: 200\n```\n\n\n\n\n\n\n\n",
    "parentName": "testing",
    "path": "testing/script/response/response-object"
  },
  "testing/script/response/response-query": {
    "name": "response-query",
    "content": "Response Query\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](../../tests/assertions), [scripting](../getting-started) and [testing](../../tests/introduction) contexts can be queried for data by invoking it like below.\n\nThink of it as `lodash.get()` on steroids\n\n```javascript\nres('order.total')\n```\n\nExamples\n\n```javascript\nconst data = {\n  customer: {\n    address: {\n      city: \"bangalore\"\n    },\n    orders: [\n      {\n        id: \"order-1\",\n        items: [\n          { id: 1, amount: 10 },\n          { id: 2, amount: 20 }\n        ]\n      },\n      {\n        id: \"order-2\",\n        items: [\n          { id: 3, amount: 30 },\n          { id: 4, amount: 40 }\n        ]\n      }\n    ]\n  },\n};\n```\n| Query                                   | Output                             |\n|-----------------------------------------|------------------------------------|\n| res(\"customer.address.city\")            | bangalore                          |\n| res(\"customer.orders.items.amount\")     | [10, 20, 30, 40]                   |\n| res(\"customer.orders.items.amount[0]\") | 10                                 |\n| res(\"..items.amount\")                   | [10, 20, 30, 40]                   | |\n| res(\"..amount\")                         | [10, 20, 30, 40]                   |\n| res(\"..items.amount[0]\")                | 10                                 |\n| res(\"..items[0].amount\")                | 10                                 |\n| res(\"..items[5].amount\")                | undefined                          |\n| res(\"..id\")                             | [\"order-1\", 1, 2, \"order-2\", 3, 4] |\n| res(\"customer.orders.foo\")              | undefined                          |\n| res(\"..customer.foo\")                   | undefined                          |\n| res(\"..address\")                        | [\\{ city: \"bangalore\" \\}]          |\n| res(\"..address[0]\")                     | \\{ city: \"bangalore\" \\}            |\n\nAPI\n\n\nStandard dot notation\n\n\n**Example:**\n```javascript\nres('customer.orders.items.amount')\n```\n\nDeep navigation .. double dots\n\n\n**Example:**\n```javascript\nres('..items.amount')\n```\n\nArray indexing\n\n\n**Example:**\n```javascript\nres('..items[0].amount')\n```\n\nArray filtering [?] with corresponding filter function\n\n\n**Example:**\n```javascript\nres('..items[?].amount', i => i.amount > 20)\n```\n\n\nArray mapping [?] with corresponding mapper function\n\n\n**Example:**\n```javascript\nres('..items..amount[?]', amt => amt + 10)\n```\n\n\n\n\n\n\n\n\n",
    "parentName": "testing",
    "path": "testing/script/response/response-query"
  },
  "testing/script/script-flow": {
    "name": "script-flow",
    "content": "import { Callout } from 'nextra/components'\n \nScript Flow in Bruno\n\n\nIn Bruno, we provide two types of script flows: **Sandwich** and **Sequential (Natural)**. These flows control the order in which the scripts at various levels of your API test collections are executed, allowing for flexibility and control over your automation.\n\nFlow Types\n\n\n1. Sandwich Flow\n2. Sequential (Natural) Flow\n\n1. Sandwich Flow\n\n\nIn the **Sandwich Flow**, scripts are executed in the following order:\n\n```bash\nsandwich-flow/\nâ”œâ”€â”€ Collection Pre Script\nâ”‚   â””â”€â”€ Folder Pre Script\nâ”‚       â””â”€â”€ Request Pre Script\nâ””â”€â”€ Request Post Script\n    â””â”€â”€ Folder Post Script\n        â””â”€â”€ Collection Post Script\n```\n\nThis order allows you to execute actions at multiple levels (collection, folder, and request) before and after each test. It is useful when you need to configure different environments or states before and after running tests at various levels.\n\n2. Sequential (Natural) Flow\n\n\nIn the **Sequential Flow**, scripts are executed in this order:\n\n```bash\nsequential-flow/\nâ”œâ”€â”€ Collection Pre Script\nâ”‚   â””â”€â”€ Folder Pre Script\nâ”‚       â””â”€â”€ Request Pre Script\nâ””â”€â”€ Collection Post Script\n    â””â”€â”€ Folder Post Script\n        â””â”€â”€ Request Post Script\n```\n\nThis flow executes scripts in a more natural, linear order. After the **Request Pre Script**, it runs the **Collection Post Script**, followed by **Folder Post Script**, and finally, the **Request Post Script**. This flow may be better suited when you want a clean execution from top to bottom.\n\n\n  If the `flow` property is not specified, Sandwich is used by default.\n\n\nYou can set the flow type (either `sandwich` or `sequential`) in your `bruno.json` configuration file:\n\n```json showLineNumbers filename=\"bruno.json\" {7}\n{\n  \"scripts\": {\n    \"moduleWhitelist\": [\"crypto\", \"buffer\", \"form-data\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    },\n    \"flow\": \"sequential\" // Or \"sandwich\"\n  }\n}\n```",
    "parentName": "testing",
    "path": "testing/script/script-flow"
  },
  "testing/script/vars": {
    "name": "vars",
    "content": "import { Callout } from \"nextra/components\";\n\nVars tab\n\n\nThe **Vars** tab in Bruno allows you to manage variables at different stages of your request lifecycle. You can set and use variables:\n- Before the request (Pre Request)\n- After receiving the response (Post Response)\n\n\n  Variables are scoped within the request and cannot be accessed outside of it. This ensures clean separation between different requests.\n\n\nPre Request Vars\n\n\nIn the **Vars** tab > **Pre Request** variables section, you can write any strings, numbers or any valid JavaScript literal.\n\nExample:\n\n![bru vars](/screenshots/set-vars.webp)\n\nPost Response Vars\n\n\nIn the **Vars** tab > **Post Response** variables section, you can write any valid JavaScript expression. The `res` object is available, allowing you to declaratively parse the [response object](/testing/script/response/response-object) and set variables, instead of writing scripts to do the same.\n\nExample:\n\n![Screenshot showing how to use defined variables in the request body](/screenshots/vars.webp)\n\nFor parsing the response, you can checkout the [response query](/testing/script/response/response-query) that allows you to easily query your response.",
    "parentName": "testing",
    "path": "testing/script/vars"
  },
  "testing/script/whitelisting-modules": {
    "name": "whitelisting-modules",
    "content": "import { Callout } from \"nextra/components\";\n\nWhitelisting Modules\n\n\nThe scripts can use both [external libraries](external-libraries) (via package.json and npm install) and certain [built-in](inbuilt-libraries) modules in Node.js (like fs, path, etc.). However, for security reasons, not all built-in Node.js modules are made accessible by default in Bruno scripts.\n\nWhy Whitelisting\n\n\nBruno requires you to explicitly enable (whitelist) modules before they can be used in scripts due to security reasons. The whitelisting process ensures that only the modules you specifically choose to enable will be available to your scripts.\n\nYou can manually enable or whitelist these modules by editing your `bruno.json` file. Make sure to add the `script` section to the file.\n\n```json copy filename=\"bruno.json\" showLineNumbers {6-11}\n{\n  \"version\": \"1\",\n  \"name\": \"collection_name\",\n  \"type\": \"collection\",\n  \"ignore\": [\"node_modules\", \".git\"],\n  \"scripts\": {\n    \"moduleWhitelist\": [\"child_process\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    }\n  }\n}\n```\n\n\n  filesystemAccess is required for reading and writing files, especially for\n  modules that depend on it.\n\n\nWhitelisting Multiple Modules\n\n\nIf you need to use multiple built-in or trusted third-party modules in your Bruno script, you can whitelist them by adding them to the `moduleWhitelist` array. For example:\n\n```json copy filename=\"bruno.json\" showLineNumbers\n \"scripts\": {\n      \"moduleWhitelist\": [\"crypto\", \"jwt\", \"child_process\"],\n      \"filesystemAccess\": {\n        \"allow\": true\n      }\n    }\n```\n\nOnly whitelist modules that you trust and that are necessary for your script to function properly.\n",
    "parentName": "testing",
    "path": "testing/script/whitelisting-modules"
  },
  "testing/tests/assertions": {
    "name": "assertions",
    "content": "Assertions\n\n\nAssertions allow you to declaratively write tests.\n\nThis should cover most of your testing needs. For complex tests, you can write test scripts.\n\nGetting Started with Assertions\n\n\nTo get started with basic tests using assertions, follow these steps:\n\n1.  **Open a Collection**: Navigate to the Collection containing the request you want to test.\n2.  **Select a Request**: Click on a request within the Collection.\n3.  **Go to the Assertions Tab**: Click on the Assertions tab to access the testing interface.\n4.  **Write Your Test**: You can now specify an **expression**, an **operator**, and the **value** to test against the API response.\n\n![bru assertions](/screenshots/get-started/bruno-basics/create_test/bru_test_assert.webp)\n\nThis method allows you to quickly test different conditions and verify that the API returns the expected results.\n\nExample:\n\n\n- **Expression**: Verify the body response status (e.g., response.body.status).\n- **Operator**: Choose the operator (e.g., equals, contains).\n- **Value**: Provide the expected value (e.g., 200).\n\nBruno will then automatically run the test and give you the results, letting you know if the assertion passes or fails.\n",
    "parentName": "testing",
    "path": "testing/tests/assertions"
  },
  "testing/tests/introduction": {
    "name": "introduction",
    "content": "import { Callout } from \"nextra/components\";\n\nTesting\n\n\n\n  Bruno uses the [Chai library â†—]( so you can follow the\n  same syntax for writing assertions in your tests.\n\n\nBruno supports writing automation test scripts in JavaScript for your API requests to assert its behaviour.\n\nSome of the benefits include\n\n- Increased efficiency: The tests can be run repeatedly, reducing the time and effort required for manual testing.\n- Increased coverage: Automated tests can cover a larger range of scenarios and edge cases compared to manual testing.\n- Continuous integration/continuous delivery (CI/CD): Automated API tests can be integrated into a CI/CD pipeline, ensuring that API changes are thoroughly tested before deployment.\n- Easier maintenance: Automated tests can be easily updated as the API evolves, reducing the maintenance burden compared to manual tests.\n- Easier regression testing: Automated tests can be easily repeated after changes are made to the API, reducing the time required for regression testing.\n\n**Example:**\n\n```javascript\ntest(\"should be able to login\", function () {\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should return json\", function () {\n  expect(res.getBody()).to.eql({\n    hello: \"Bruno\",\n  });\n});\n```\n\n**Screenshot:**\n\n![bru lang sample](/screenshots/test-script.webp)\n\nScripting API\n\n\nPlease see the [Scripting API](../script/javascript-reference) for a comprehensive set of methods that enable you to write custom JavaScript code to automate and test your API requests in Bruno. It allows you to manipulate request variables, modify headers, handle response data, and implement complex logic directly within your test scripts.\n",
    "parentName": "testing",
    "path": "testing/tests/introduction"
  },
  "variables/collection-variables": {
    "name": "collection-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nCollection Variables\n\n\nCollection variables are variables that are scoped to a specific collection. They are useful for storing variables that are used across multiple requests in a collection.\n\nCreating a Collection Variable\n\n* Go to Collection Settings\n* Go to the Variables tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Collection Variables](/screenshots/variables/collection-variables.webp)\n\nUsing a Collection Variable\n\nYou can use the `{{varName}}` syntax to use a collection variable in a request.\n\n![Collection Variables Usage](/screenshots/variables/collection-variables-usage.webp)\n\nAccess Collection Variable inside scripts\n\nYou can also use the `bru.getCollectionVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nlet namespace = bru.getCollectionVar(\"namespace\");\n```\n\nImport/Export Collection Variables\n\n\nYou can import and export collection variables to share them across teams or back them up for later use.\n\nAccessing Import/Export Options\n\n\n1. Go to the **Environments** section (top right corner).\n\n![No-Environment](/screenshots/variables/no-environment.webp)\n\n2. Click on **Configure** to access the environment settings.\n\n3. You will see the **Import** and **Export** options in the bottom left corner.\n\n![Export Option](/screenshots/variables/click-export-option.webp)\n\nImporting Environment Variables\n\n\nThe import feature accepts environment files in both **Bruno** and **Postman** formats:\n\n1. Click on the **Import** button.\n2. Select the environment file you want to import\n3. The variables will be added to your collection.\n\nExporting Environment Variables\n\n\n1. Click on the **Export** button.\n2. If you have multiple environments, select which environments you want to export.\n3. Choose the location where you want to save the exported JSON file.\n\n![Export Collection Environment Location](/screenshots/variables/export-collection-env-location.webp)\n\n4. The environment variables will be saved as a JSON file that can be shared or backed up.\n\n\n  Secret variables (variables marked as secret) will not be included in the exported JSON file for security reasons.\n\n",
    "parentName": "variables",
    "path": "variables/collection-variables"
  },
  "variables/environment-variables": {
    "name": "environment-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nEnvironment Variables\n\n\nEnvironment variables are variables that are scoped to an environment, such as local development or production. They are useful for storing variables that can be re-used across the collection that are different depending on the environment. An example would be the host url of the server you want to test.\n\nCreating an Environment Variable\n\n\n- Go to environments (top right) and press **No environment**.\n\n![No-Environment](/screenshots/variables/no-environment.webp)\n\n- If there are no environments, you will be prompted to create one.\n\n![No-Environment](/screenshots/variables/collection-environment.webp)\n\n- Add your variable name and value for the specific environment.\n- Save your changes.\n\n![Environment Variables location](/screenshots/variables/environment-variables.webp)\n\nUsing an Environment Variable\n\n\nJust like other variables you can use the `{{varName}}` syntax to use an environment variable in a request. On the top-right, you can see which environment you are currently using and select a different one.\n\nUsing the ./environment directory\n\n\nEnvironment variables are synced with the `/environments` directory inside your collection. You can also create and manage environments there.\n\nEach environment is saved in a `.bru` file, which looks like this:\n\n```bash filename=\"local.bru\"\nvars {\n  host: \n}\n```\n\n\n  Check out the [Collection Variables](/variables/collection-variables#import-export-collection-variables) and [Global Environment Variables](/variables/global-environment-variables#import-export-global-environment-variables) documentation for import and export options.\n\n",
    "parentName": "variables",
    "path": "variables/environment-variables"
  },
  "variables/folder-variables": {
    "name": "folder-variables",
    "content": "Folder Variables\n\n\nFolder variables are variables that are scoped to a specific folder. They are useful for storing variables that are used across multiple requests in a folder.\n\nCreating a Folder Variable\n\n* Go to Folder Settings (can be accessed from dropdown menu of the folder in the sidebar)\n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Folder Variables](/screenshots/variables/folder-variables.webp)\n\nUsing a Folder Variable\n\nYou can use the `{{varName}}` syntax to use a folder variable in a request.\n\n![Folder Variables Usage](/screenshots/variables/folder-variables-usage.webp)\n\nAccess Folder Variable inside scripts\n\nYou can also use the `bru.getFolderVar()` function to get the value of a folder variable and use it inside your scripts.\n\n```javascript\nlet bearerToken = bru.getFolderVar(\"bearerToken\");\n```\n",
    "parentName": "variables",
    "path": "variables/folder-variables"
  },
  "variables/global-environment-variables": {
    "name": "global-environment-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nGlobal Environment Variables\n\n\n\n\nGlobal variables are stored in the application's memory. You can access them by visiting the About section from Preferences and navigating to the AppData path location.\n\n\n\nGlobal environment variables can be used across all collections and requests. Think of them as a global store accessible throughout the app.\n\nInstead of creating the same collection variable repeatedly in each collection, you can use global variables to store common values that need to be accessed across different collections. This eliminates the repetitive task of defining the same variables every time.\n\nCreate a Global Environment Variable\n\n\n1. Go to the **Environments** section (top right corner).\n\n![No-Environment](/screenshots/variables/no-environment.webp)\n\n2. Navigate to the **Global** tab and click on **Create**.\n3. (Optional) If you need to import an existing environment, you can use the **Import Environment** option.\n\n![global-environment](/screenshots/variables/global-environment.webp)\n\n4. Enter a name for your environment and click **Create**.\n\n![Environment Variables location](/screenshots/variables/select-env-name.webp)\n\n5. Add a variable by specifying the **Name** and **Value**.\n\n![Environment Variables location](/screenshots/variables/create-env-key-value-pair.webp)\n\n6. Click **Save**.\n\nYour global environment variable is now created and can be accessed across your workspace.\n\n\n  You can click the secret checkbox to hide the values of variables while\n  hovering over them.\n\n\nUsing Global Environment Variables\n\n\nTo use a global environment variable, reference it using the format `{{var_name}}` in any request or collection. These variables can be combined with other variables and used throughout your workspace, making them ideal for consistent value sharing.\n\n![Environment Variables location](/screenshots/variables/env-action.webp)\n\nImport/Export Global Environment Variables\n\n\nYou can import and export global environment variables to share them across teams or back them up for later use.\n\nAccessing Import/Export Options\n\n\n1. Go to the **Environments** section (top right corner).\n\n![No-Environment](/screenshots/variables/no-environment.webp)\n\n2. Click on **Configure** to access the environment settings.\n\n3. You will see the **Import** and **Export** options in the bottom left corner.\n\n![Export Option](/screenshots/variables/click-export-option.webp)\n\nImporting Environment Variables\n\n\nThe import feature accepts environment files in both **Bruno** and **Postman** formats:\n\n1. Click on the **Import** button.\n2. Select the environment file you want to import\n3. The variables will be added to your global environment.\n\nExporting Environment Variables\n\n\n1. Click on the **Export** button.\n2. If you have multiple environments, select which environments you want to export.\n3. Choose the location where you want to save the exported JSON file.\n\n![Export Global Environment Location](/screenshots/variables/export-global-env-location.webp)\n\n4. The environment variables will be saved as a JSON file that can be shared or backed up.\n\n\n  Secret variables (variables marked as secret) will not be included in the exported JSON file for security reasons.\n\n",
    "parentName": "variables",
    "path": "variables/global-environment-variables"
  },
  "variables/interpolation": {
    "name": "interpolation",
    "content": "import { Callout } from \"nextra/components\";\n\nVariable Interpolation\n\n\nVariable interpolation in Bruno allows you to use variables in your requests using the `{{variableName}}` syntax. Let's explore how interpolation works with different data types.\n\nBasic Interpolation\n\n\nStrings\n\n\n```javascript\n// Setting a string variable\nbru.setVar(\"greeting\", \"Hello World\");\n\n// Using in request\nGET \n// Interpolates to:  World\n```\n\nNumbers\n\n\n```javascript\n// Setting a number variable\nbru.setVar(\"userId\", 123);\n\n// Using in request\nGET \n// Interpolates to: \n```\n\nBooleans\n\n\n```javascript\n// Setting a boolean variable\nbru.setVar(\"isActive\", true);\n\n// Using in request body\n{\n  \"active\": {{isActive}}\n}\n// Interpolates to: { \"active\": true }\n```\n\nObject Interpolation\n\n\n\n  Object interpolation is available from Bruno v2.2.0 onwards.\n\n\nYou can access object properties using dot notation. Here's how to work with objects containing different data types:\n\n```javascript\n// Define your object with multiple data types\nconst userProfile = {\n  username: \"john_doe\",           // string\n  accountId: 12345,              // number\n  isVerified: true,              // boolean\n  preferences: {                  // nested object\n    theme: \"dark\",\n    notifications: true\n  }\n};\n\n// Set the object as a variable\nbru.setVar(\"user\", userProfile);\n\n// Using in request body\n{\n  \"username\": \"{{user.username}}\",\n  \"verified\": {{user.isVerified}},\n  \"preferences\": {{user.preferences}},\n}\n\n// Interpolates to:\n// {\n//   \"username\": \"john_doe\",\n//   \"verified\": true,\n//   \"preferences\": {\n//    \"theme\": \"dark\",\n//    \"notifications\": true\n //   }\n// }\n```\n\nArray Interpolation\n\n\n\n  Array interpolation is available from Bruno v2.2.0 onwards.\n\n\n```javascript\n// Define your arrays\nconst technologies = [\"REST\", \"GraphQL\", \"gRPC\"];\n\nconst settings = [\n  { port: 3000, env: \"dev\" },\n  { port: 8080, env: \"prod\" }\n];\n\n// Set arrays as variables\nbru.setVar(\"apiTypes\", technologies);\nbru.setVar(\"configs\", settings);\n\n// Using array elements in request\n{\n  // Simple array access\n  \"primaryAPI\": \"{{apiTypes[0]}}\",        // \"REST\"\n  \"alternativeAPI\": {{apiTypes}},    \n  \n  // Accessing object properties in arrays\n  \"devPort\": {{configs[0].port}},         // 3000\n  \"prodEnv\": {{configs}},        \n  \n  // Using multiple array elements\n  \"supported\": {\n    \"apis\": [\"{{apiTypes[0]}}\", \"{{apiTypes[1]}}\"],\n  }\n}\n\n// Interpolates to:\n// {\n//   \"primaryAPI\": \"REST\",\n//    \"alternativeAPI\": [\n//    \"REST\",\n//    \"GraphQL\",\n//    \"gRPC\"\n//    ]\n//   \"devPort\": 3000,\n//   \"prodEnv\": [\n//    {\n//      \"port\": 3000,\n//      \"env\": \"dev\"\n//    },\n//    {\n//      \"port\": 8080,\n//     \"env\": \"prod\"\n//    }\n//  ]\n\n//   \"supported\": {\n//     \"apis\": [\"REST\", \"GraphQL\"],\n//   }\n// }\n```\n\nDate Interpolation\n\n\n\n```javascript\n\n// Bruno v2.2.0+\nbru.setVar(\"timestamp\", new Date());\n\n// Using in request\n{\n  \"createdAt\": \"{{timestamp}}\"\n}\n// Interpolates to:\n// {\n//   \"createdAt\": \"2025-04-23T13:57:56.341Z\"\n// }\n```\n\nPractical Examples\n\n\nAPI Authentication\n\n\n```javascript\nbru.setVar(\"authConfig\", {\n  apiKey: \"your-api-key\",\n  secret: \"your-secret\"\n});\n\n// In request headers\nheaders {\n  \"X-API-Key\": \"{{authConfig.apiKey}}\",\n  \"X-Secret\": \"{{authConfig.secret}}\"\n}\n```\n\nDynamic Query Parameters\n\n\n```javascript\nbru.setVar(\"searchParams\", {\n  limit: 10,\n  offset: 0,\n  filter: \"active\"\n});\n\n// In URL\nGET \n```\n\nRequest Body with Mixed Types\n\n\n```javascript\nbru.setVar(\"product\", {\n  name: \"Bruno Pro\",\n  price: 99.99,\n  features: [\"Git Integration\", \"Offline First\"],\n  metadata: {\n    version: \"2.2.0\",\n    released: new Date()\n  }\n});\n\n// In request body\n{\n  \"productName\": \"{{product.name}}\",\n  \"price\": {{product.price}},\n  \"firstFeature\": \"{{product.features[0]}}\",\n  \"releaseDate\": \"{{product.metadata.released}}\"\n}\n```\n\n\n  Remember that variables set using `bru.setVar()` are available throughout your collection's scope. Use them to make your requests more dynamic and maintainable.\n ",
    "parentName": "variables",
    "path": "variables/interpolation"
  },
  "variables/overview": {
    "name": "overview",
    "content": "Variables\n\n\nOverview\n\n\nVariables in the Bruno allow you to store dynamic values that can be reused across multiple API requests, environments, and workflows. This feature enhances flexibility, maintainability, and efficiency by enabling you to manage frequently changing data points such as tokens, environment-specific URLs, or user-defined values in one place.\n\nTypes\n\n\nThere are 6 types of variables you can create:\n\n- [Global Environments Variables](./global-environment-variables.mdx)\n- [Environment Variables](./environment-variables.mdx)\n- [Collection Variables](./collection-variables.mdx)\n- [Folder Variables](./folder-variables.mdx)\n- [Request Variables](./request-variables.mdx)\n- [Runtime Variables](./runtime-variables.mdx)\n\nAdditionally, Process Environment Variables can be defined in an external environment configuration file:\n\n- [Process Environment Variables](./process-env.mdx)\n\nRuntime variables get the highest precedence. Process Environment Variables are accessed using the `{{process.env.VAR_NAME}}` syntax and hence don't compete with the above.\n\nVariable Precedence and Scope\n\n\nWhen a variable is accessed, the following precedence is used to determine which value is used:\n\n\n  \n    \n      â†‘ Higher Precedence\n      â†“ Broader Scope\n    \n    \n      Runtime Variables\n      Request Variables\n      Folder Variables\n      Environment Variables\n      Collection Variables\n      Global Variables\n    \n  \n\n\nRuntime variables get the highest precedence. Process Environment Variables are accessed using the `{{process.env.VAR_NAME}}` syntax and hence don't compete with the above.\n\nVariable Storage\n\n\nEach variable has its own storage location either within your collection file or within the app's memory. **All storage is local.**\n\n\n  \n    \n      \n        Variable Type\n        Storage Location\n      \n    \n    \n      \n        Collection\n        `.bru`\n      \n      \n        Folder\n        `.bru`\n      \n      \n        Request\n        `.bru`\n      \n      \n        Environment\n        `.bru`\n      \n      \n        Runtime\n        Local storage\n      \n      \n        Global\n        Local storage\n      \n      \n        Process Environment\n        Separate `.env` file\n      \n    \n  \n\n\n\nVariable Data Type\n\n\nAll variables are stored as strings. Bruno does not infer or change the data type of the variable based on the value you set.\n\nDebugging Variables in Console\n\n\nYou can access and debug variables in the console using the following pattern:\n\nThe pattern follows `bru.get[Type]Var(key)` where:\n- `[Type]` is the variable type (Runtime, Request, Folder, etc.)\n- `key` is the variable name you want to access\n\nExample: \n\n\n```javascript\n// Basic syntax: console.log(bru.get[Type]Var(key))\nconsole.log(bru.getVar('myVar'))           // Runtime variables\n```\n\nScripting API\n\n\nPlease see the [Scripting API](/scripting/javascript-reference#collection-variables) for more information on how to access variables in your scripts.\n",
    "parentName": "variables",
    "path": "variables/overview"
  },
  "variables/process-env": {
    "name": "process-env",
    "content": "import { Callout } from \"nextra/components\";\nimport { FileTree } from \"nextra/components\";\n\nProcess Environment Variables\n\n\nOverview\n\n\nProcess environment variables are used to store sensitive information, such as API keys, passwords, and other secret values. These values are typically stored in a .env file. For more details on secret management, refer to the [secret management](/secrets-management/dotenv-file) section.\n\n\n  You must create the `.env` file in your local project directory (e.g., using\n  VS Code) to store your process environment variables. Bruno cannot create or\n  manage the `.env` file for you.\n\n\nCreating a Process Environment Variables\n\n\nTo create process environment variables, you can add a .env file to the root of your Bruno collection. This file will store your secrets, which can then be accessed throughout the collection.\n\nExample\n\n\nIn your Bruno collection, the structure might look like this:\n\n\n  \n    \n    \n      \n    \n    \n  \n  \n  \n  \n  \n\n\nIn the `.env` file, you would store a key-value pair, like this:\n\n```bash showLineNumbers filename=\".env\"\nkey = bruno\n```\n\nUsing the Process Environment Variables\n\n\nTo access the values stored in the `.env` file, you can use the `process.env` global object. For example, if you want to retrieve the key value from your `.env` file, you would use:\n\n![image](/screenshots/variables/creating-process-env-variables.webp)\n\nYou can use `process.env.` throughout your Bruno collection to securely manage and access your environment variables.\n\n![image](/screenshots/variables/using-process-env-variables.webp)\n",
    "parentName": "variables",
    "path": "variables/process-env"
  },
  "variables/request-variables": {
    "name": "request-variables",
    "content": "Request Variables\n\n\nRequest variables are variables that are scoped to a specific request. They are useful for storing variables that is used in a specific request.\n\nCreating a Request Variable\n\n* Go to the Request \n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Request Variables](/screenshots/variables/request-variables.webp)\n\nUsing a Request Variable\n\nYou can use the `{{varName}}` syntax to use a request variable in a request.\n\n![Request Variables Usage](/screenshots/variables/request-variables-usage.webp)\n\nAccess Request Variable inside scripts\n\nYou can also use the `bru.getRequestVar()` function to get the value of a request variable and use it inside your scripts.\n\n```javascript\nlet source = bru.getRequestVar(\"source\");\nlet destination = bru.getRequestVar(\"destination\");\n```\n",
    "parentName": "variables",
    "path": "variables/request-variables"
  },
  "variables/runtime-variables": {
    "name": "runtime-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nRuntime Variables\n\n\nOverview\n\n\nRuntime variables are **ephemeral variables** that exist only during the runtime of the API client. These variables are scoped within a collection, meaning they are accessible to all requests within that collection. However, once the API client is closed or restarted, the values of these variables are lost. They are ideal for managing temporary data such as session tokens, dynamic parameters, or other values that are generated or updated during the execution of requests.\n\nCreating a Runtime Variable\n\n\nTo create a runtime variable, you can use the `bru.setVar(name, value)` function. This function allows you to store any value (e.g., tokens, response data, temporary user inputs) as a runtime variable.\n\nExample:\n\n\nSuppose you receive an authentication token as part of a response body and want to reuse it in subsequent requests. You can capture it using the `bru.setVar()` function in your post response script.\n\n```javascript\nbru.setVar(\"token\", res.body.token);\n```\n\nUsing a Runtime Variable\n\n\nOnce a runtime variable is created, you can use it in subsequent API requests by referencing it with the `{{variableName}}`syntax. The variable's value will be dynamically injected into the request at runtime.\n\nExample:\n\n\nIf youâ€™ve stored a token variable using `bru.setVar()`, you can use it in headers, query parameters, body, or URL of subsequent requests like this:\n\n```plaintext\nAuthorization: Bearer {{token}}\n```\n\nYou can also use the `bru.getVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nconst token = bru.getVar(\"token\");\nreq.setHeader(\"Authorization\", `Bearer ${token}`);\n```\n\nViewing Runtime Variables\n\n\nYou can view all runtime variables by clicking on the **Eye** icon located in the top-right corner of the navigation bar\n\n\n  The request must be executed before you can view the runtime variables.\n\n\nExample:\n\nConsider the following script inside Bruno, which creates a runtime variable with a `key` and value `pair`. In this case, the key is _hey_ and the value is _Bruno_.\n\n```js\nbru.setVar(\"hey\", \"Bruno\");\n```\n\nOnce the request is executed, the runtime variable will be available for viewing. You should see something like this:\n\n![runtime-var](/screenshots/variables/runtime-var.webp)\n",
    "parentName": "variables",
    "path": "variables/runtime-variables"
  },
  "vs-code-extension/install-config": {
    "name": "install-config",
    "content": "Install and Configure\n\n\nTo start using the Bruno VS Code extension, install it from the official [Visual Studio Code Marketplace]( or simply open the Extensions panel in your editor and search for **Bruno**.\n\nOnce installed, open a Bruno collection and begin sending API requests right from your editor.\n\nUsage\n\n\nDual View Mode\n\n\nBruno VS Code extension offers two distinct viewing modes to suit different workflows:\n\n1. **Using the Explorer** - File mode with syntax highlighting\n2. **Using the Extension** - GUI mode with visual interface\n\nUsing the Explorer\n\n\nIf you already have loaded Bruno collection into the editor the File mode will be default view to switch GUI mode click on **Bruno** icon. \n\n\n![VS Code Extension Create Request](/screenshots/vs-code-extension/filemode.webp)\n\nUsing the Extension\n\n\nBy clicking the extension in VS Code, you will have a similar experience to the Bruno Desktop App.\nTo switch between view modes, click the arrow icons in the top right of your editor.\n\n\n![VS Code Extension Create Request](/screenshots/vs-code-extension/gui-view.webp)\n\nWorking with Collections\n\n\nSimilar to the desktop application, the extension will first start as a clean slate. Click the \"+\" icon to either open, create, or import a collection.\n\n![VS Code Extension Create Request](/screenshots/vs-code-extension/collection.webp)\n",
    "parentName": "vs-code-extension",
    "path": "vs-code-extension/install-config"
  },
  "vs-code-extension/overview": {
    "name": "overview",
    "content": "Overview\n\n\nThe Bruno VS Code extension brings the full power of Bruno's API testing capabilities directly into your development environment. This extension transforms VS Code into a comprehensive API development and testing platform, eliminating the need to switch between multiple tools during your development workflow.\n\nYou can install the extension from the official [Visual Studio Code Marketplace](\nand share your feedback to help us improve.\n\nCore Features\n\n\n- **Native .bru file support** - Open and edit Bruno request files with rich GUI interface\n\n- **Inline API testing** - Send requests directly from VS Code without switching applications\n\n- **Dual view modes** - Switch seamlessly between GUI and text editor views\n\n- **Collection management** - Organize and manage your API collections within VS Code\n\n- **Syntax highlighting** - Rich syntax highlighting for `.bru` files and API request formats\n\nAdvanced Capabilities\n\n\n- **Environment variables** - Manage multiple environments and switch between them easily\n\n- **Request scripting** - Write pre-request and post-response scripts for advanced testing\n\n- **Authentication support** - Handle various auth methods including Basic, Bearer, OAuth, and more\n\n- **GraphQL support** - Send and test GraphQL queries with syntax highlighting\n\n- **File uploads** - Handle multipart form data and file uploads in requests\n\n\n\n\n",
    "parentName": "vs-code-extension",
    "path": "vs-code-extension/overview"
  },
  "vs-code-extension/send-req": {
    "name": "send-req",
    "content": "import { Callout } from \"nextra/components\"\n\nSend Request\n\n\nBruno VS Code extension allows you to send API requests directly from your editor. This feature integrates seamlessly with your development workflow, enabling you to test APIs without leaving your coding environment.\n\nCreate Request\n\n\nYou can create requests by navigating to the Bruno extension:\n\n- Click on **New Request** \n- Provide request `name` and `URL` \n\nTo create a new collection, you can press the **\"+\"** button and provide a location to store it. Once you have a collection, you can create folders, configure settings, and organize your requests.\n\nYou can also open existing collections from your system by simply opening the collection folder in the editor.\n\n![VS Code Extension Create Request](/screenshots/vs-code-extension/create-req.webp)\n\n\nCreate Environment\n\n\nTo create a new environment:\n\n- Click on **No Environment**\n- Go to **Configure** (Global or Collection) as per your preference\n- Enter name for the environment and create values\n- Set up variables for different environments (dev, staging, production)\n\nIf you have Collection environments in Bruno, the extension will automatically pick them up from the environment folder.\n\n\n[Global environment](../variables/global-environment-variables.mdx) variables created within Bruno desktop app are not accessible in the extension due to security reasons.\n\n\n![VS Code Extension Create Environment](/screenshots/vs-code-extension/create-env.webp)\n\nConsole\n\n\nTo test, debug, and troubleshoot script issues, the Bruno console is available in the terminal as the **Bruno Console** tab.\n\n**Features:**\n- View console output from your scripts\n- Debug pre-request and test scripts\n- Monitor variable values and execution flow\n\n![VS Code Extension Console](/screenshots/vs-code-extension/console.webp)\n\nConfigurations\n\n\nTo add configurations such as SSL, CA certificates, Cookies, and more, click on the **Gear** icon available on the home screen of the extension.\n\n**Available Settings:**\n- **SSL/TLS**: Configure client certificates and CA certificates\n- **Cookies**: Manage cookie policies\n- **Request Timeout**: Configure default timeout values\n- **Response Formatting**: Choose how responses are displayed\n\n![VS Code Extension Settings](/screenshots/vs-code-extension/2-settings.webp)\n\nJavaScript Sandbox \n\n\nTo switch between safe and developer mode to use JavaScript libraries and APIs features, navigate to the sandbox icon next to environments.\n\n**Sandbox Modes:**\n- **Safe Mode**: Restricted environment with limited API access for security\n- **Developer Mode**: Full access to Node.js APIs and external libraries\n\n![VS Code Extension Sandbox](/screenshots/vs-code-extension/sandbox.webp)\n\nDefaults\n\n\n- **File Mode**: Default in explorer view, UI mode for extension\n- **Proxy Configuration**: If you have proxy configuration set up in the editor, Bruno will pick up the values directly\n- **Cookie Management**: Manage cookies separately from the cookies setting available in the extension home screen\n\nFuture Development \n\n\n- **gRPC Support**: Currently in development (available in Bruno as beta feature)\n- **OAuth2 Authentication**: Not yet supported in the extension \n\nFeedback\n\n\nIf you encounter any issues or have feature requests, feel free to [share your feedback](\n\n\n",
    "parentName": "vs-code-extension",
    "path": "vs-code-extension/send-req"
  }
}